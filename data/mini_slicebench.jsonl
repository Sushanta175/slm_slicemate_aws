{"code": "funcdef void SOME_FUNCDEF(const string &in);\n\nvoid print_proxy_test(const string &in str)\n{\n    print(str);\n}\n\nvoid test_system()\n{\n    SOME_FUNCDEF@ printer = @print;\n    printer(\"hello\");\n}\n\nvoid test_script()\n{\n    SOME_FUNCDEF@ printer = @print_proxy_test;\n    printer(\"hello\");\n}\n", "line": 5, "slice": ["void print_proxy_test(const string &in str)", "{", "    print(str);", "}", "", "void test_script()", "{", "    SOME_FUNCDEF@ printer = @print_proxy_test;", "    printer(\"hello\");", "}"]}
{"code": "# Declare a trait for integers.\ntrait Integer<T> {\n    def add(self: T, y: T): T;\n    def sub(self: T, y: T): T;\n}\n\n# Declare a trait for printing.\ntrait Printable {\n    def print(self);\n}\n\n# Declare a parameterized trait.\ntrait Sequence<T> {\n    def set(self, index: int);\n    def get(self): T;\n    def size(self): uint;\n}\n\n# Equality trait.\ntrait Eq {\n    def eq(self, other: Self): bool;\n    def ne(self, other: Self): bool { not self.eq(other); }\n}\n", "line": 9, "slice": ["The code does not have a line 9."]}
{"code": "/* Uses string format_date_time(string, string, string) as reference */\nstring str_in_format = \"YYYY\";\nstring str_date = \"2000\";\nstring str_out_format = \"YY\";\n\nstring format_date_time_private(string inFormat, string dateTimeString, string outFormat) {\n\treturn format_date_time(inFormat, dateTimeString, outFormat);\n}\n\nprint(\"> original format_date_time_private(string-string-string)\");\nprint(format_date_time_private(str_in_format, str_date, str_out_format)); /*Should print \"00\"*/\nprint();\n\n/* Define 2 different layers of typedef */\ntypedef string str2;\ntypedef str2 str3;\n\nstr2 str2_in_format = str_in_format;\nstr2 str2_date = str_date;\nstr2 str2_out_format = str_out_format;\nstr3 str3_in_format = str2_in_format;\nstr3 str3_date = str2_date;\nstr3 str3_out_format = str2_out_format;\n\nprint(\"> pre-overload; all coerce to original\");\nprint(format_date_time_private(str2_in_format, str2_date, str2_out_format));\nprint(format_date_time_private(str3_in_format, str3_date, str3_out_format));\nprint();\n\nstring format_date_time_private(str2 inFormat, str2 dateTimeString, str2 outFormat) {\n\treturn \"str2-str2-str2\";\n}\n\nprint(\"> overloaded with str2-str2-str2\");\nprint(format_date_time_private(str2_in_format, str2_date, str2_out_format));\nprint(\"> str3-str3-str3 -> string-string-string (accessing str2-str2-str2 without an exact match is impossible)\");\nprint(format_date_time_private(str3_in_format, str3_date, str3_out_format));\n", "line": 10, "slice": ["string str_in_format = \"YYYY\";", "string str_date = \"2000\";", "string str_out_format = \"YY\";", "", "string format_date_time_private(string inFormat, string dateTimeString, string outFormat) {", "\treturn format_date_time(inFormat, dateTimeString, outFormat);", "}", "", "typedef string str2;", "typedef str2 str3;", "", "str2 str2_in_format = str_in_format;", "str2 str2_date = str_date;", "str2 str2_out_format = str_out_format;", "str3 str3_in_format = str2_in_format;", "str3 str3_date = str2_date;", "str3 str3_out_format = str2_out_format;", "", "string format_date_time_private(str2 inFormat, str2 dateTimeString, str2 outFormat) {", "\treturn \"str2-str2-str2\";", "}", "", "print(format_date_time_private(str2_in_format, str2_date, str2_out_format));"]}
{"code": "#test basic_main\n#source\n    def main := () -> {\n        (import std::io)::print(\"Hello world\");\n    }\n#expected\n    Define\n        Name\n        InferredType\n        Function\n            List\n            InferredType\n            Block\n                Call\n                    Access\n                        Import\n                            Path\n                                Name\n                                Name\n                        Name\n                    List\n                        ListMember\n                            None\n                            None\n                            String", "line": 4, "slice": ["#source", "    def main := () -> {", "        (import std::io)::print(\"Hello world\");", "    }"]}
{"code": "\n#define cryptokey 845\n\nvoid Validate_Data () {\n  if (content == CMD_GET){\n    if (!iscryptvalid) {\n      if (keytrylock) {\n        randomSeed(millis());\n        randomkey = random(0,1024);       // chave de resposta\n        checkkey = randomkey ^ cryptokey; // xor challenge\n//        checkkey = randomkey ^ mcu_vars.AuthPass; // xor challenge\n#ifdef ENABLE_CRYPTO_DEBUG        \n        Serial.print(F(\"<DEBUGKEY=\"));\n        Serial.print(mcu_data.mcu_vars.AuthPass);\n        Serial.print(F(\",\"));\n        Serial.print(randomkey);\n        Serial.println(F(\">\"));\n#endif\n        Serial.print(F(\"<CHECK=\"));\n        Serial.print(checkkey);\n        Serial.println(F(\">\"));\n      }else{\n        Serial.println(F(\"<AUTH=LOCK>\"));\n      }\n    }else{\n      Serial.println(F(\"<AUTH=PASS>\"));\n    }\n  }\n  if (content == CMD_SET){\n    Serial.print(F(\"<AUTH=\"));\n    if (keytrylock) {\n      if (value_string.toInt() == randomkey) {\n        iscryptvalid = 1;\n        keytrylock = 3;\n        Serial.print(F(\"PASS\"));\n      }else{\n        iscryptvalid = 0;\n        keytrylock--;\n        Serial.print(F(\"FAIL\"));\n      }\n    }else{\n      Serial.print(F(\"LOCK\"));\n    }\n    Serial.println(F(\">\"));\n  }\n}\n\r\n", "line": 13, "slice": ["#define cryptokey 845", "", "void Validate_Data () {", "  if (content == CMD_GET){", "    if (!iscryptvalid) {", "      if (keytrylock) {", "        randomSeed(millis());", "        randomkey = random(0,1024);       // chave de resposta", "        checkkey = randomkey ^ cryptokey; // xor challenge", "      }", "    }", "  }", "  if (content == CMD_SET){", "    if (keytrylock) {", "      if (value_string.toInt() == randomkey) {", "        iscryptvalid = 1;", "        keytrylock = 3;", "      }else{", "        iscryptvalid = 0;", "        keytrylock--;", "      }", "    }", "  }", "}"]}
{"code": "#ifndef _DEMO_NUMERIC_INO_\r\n#define _DEMO_NUMERIC_INO_\r\n\r\nvoid demoNumeric()\r\n{\r\n  showDemoText(TN_NUMERIC);\r\n\r\n  myOLED.setFont(OLED_font6x8);\r\n  myOLED.printFlashMsg(0,0, tname[TN_NUMERIC]);\r\n  \r\n  myOLED.print(0, 2, (long) random(0,1000000), 0, false);\r\n  myOLED.print(64, 2, (int) random(0,32767), 5, true);\r\n  myOLED.println(0, 3, \"1.2345: (2) : (5,8)\");\r\n  myOLED.printFloat(1.2345,2);\r\n  myOLED.print(\" : \");\r\n  myOLED.printFloat(1.2345, 5, 8);\r\n  myOLED.println(0, 6, \"Display HEX 0xF\");\r\n  myOLED.printHex(0,7, 0xF, 0, false);\r\n  myOLED.print(\":\");\r\n  myOLED.printHex(0xF, 2, false);\r\n  myOLED.print(\":\");\r\n  myOLED.printHex(0xF, 2, true);\r\n  myOLED.print(\":\");\r\n  myOLED.printHex(0xF, 3, false);\r\n  myOLED.print(\":\");\r\n  myOLED.printHex(0xF, 3, true);\r\n  myOLED.print(\":\");\r\n  myOLED.printHex(0xF, 4, true);\r\n\r\n  // to verify the buffer\r\n  OLEDshow();\r\n  delay(3000);\r\n  \r\n}\r\n\r\n#endif", "line": 11, "slice": ["void demoNumeric()", "{", "  myOLED.setFont(OLED_font6x8);", "  myOLED.println(0, 3, \"1.2345: (2) : (5,8)\");", "  myOLED.printFloat(1.2345,2);", "  myOLED.print(\" : \");", "  myOLED.printFloat(1.2345, 5, 8);", "}"]}
{"code": "/*\n * ESP32 Webserver with SPIFFS and WiFi AP mode\n * By Shreyas K\n */\n\n#include \"WiFi.h\"\n#include \"ESPAsyncWebServer.h\"\n#include \"SPIFFS.h\"\n#define PasswordProtectAP true; //Comment out if you do not want password for AP.\n\nconst char* keyword = \"Hello\";\nconst char* ssid = \"ESP32_WebServer\"; //Webserver AP SSID\nconst char* password = \"password\"; //Webserver AP Password\n\nAsyncWebServer server(80); //Start Async Webserver on port 80.\n\nvoid setup() {\n  Serial.begin(9600);\n  #ifdef PasswordProtectAP\n  WiFi.softAP(ssid, password); //Use password protected AP\n  #else\n  WiFi.softAP(ssid); //Use open AP\n  #endif\n  \n  SPIFFS.begin(); //Begin the SPIFFS\n  server.begin(); //Begin Webserver\n  \n  //Return MIME types as per HTTP requests:\n   server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest * request) {\n    request->send(SPIFFS, \"/index.html\",\"text/html\");\n  });\n  server.on(\"/WindowsClient.exe\", HTTP_GET, [](AsyncWebServerRequest * request) {\n    request->send(SPIFFS, \"/WindowsClient.exe\",\"application/octet-stream\");\n  });\n  server.on(\"/style.css\", HTTP_GET, [](AsyncWebServerRequest * request) {\n    request->send(SPIFFS, \"/style.css\", \"text/css\");\n  });\n  server.on(\"/1\", HTTP_GET, [](AsyncWebServerRequest * request) {\n    Serial.print(keyword);\n    delay(300);\n    Serial.print(keyword);\n    delay(300);\n    Serial.print(keyword); //Send keyword thrice just for good measure :D\n    request->send(SPIFFS, \"/index.html\",\"text/html\");\n  });\n}\nvoid loop() {\n}\n", "line": 39, "slice": ["#include \"WiFi.h\"", "#include \"ESPAsyncWebServer.h\"", "#include \"SPIFFS.h\"", "#define PasswordProtectAP true; //Comment out if you do not want password for AP.", "const char* keyword = \"Hello\";", "const char* ssid = \"ESP32_WebServer\"; //Webserver AP SSID", "const char* password = \"password\"; //Webserver AP Password", "AsyncWebServer server(80); //Start Async Webserver on port 80.", "void setup() {", "  Serial.begin(9600);", "  #ifdef PasswordProtectAP", "  WiFi.softAP(ssid, password); //Use password protected AP", "  #else", "  WiFi.softAP(ssid); //Use open AP", "  #endif", "  SPIFFS.begin(); //Begin the SPIFFS", "  server.begin(); //Begin Webserver", "  server.on(\"/1\", HTTP_GET, [](AsyncWebServerRequest * request) {", "    Serial.print(keyword);", "    delay(300);", "    Serial.print(keyword);", "    delay(300);", "    Serial.print(keyword); //Send keyword thrice just for good measure :D", "    request->send(SPIFFS, \"/index.html\",\"text/html\");", "  });", "}"]}
{"code": "#include <float.h>\n#include <Wire.h>\n\n#define __DEBUG__\n#ifdef __DEBUG__\n#define DEBUG(...) Serial.print(__VA_ARGS__)\n#define DEBUGLN(...) Serial.println(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#define DEBUGLN(...)\n#endif\n\n#define BAUD_RATE 500000\n#define INTERRUPT0_PIN 2\n#define INTERRUPT1_PIN 3\n\nvolatile unsigned long interrupt_counter0;\nvolatile unsigned long interrupt_counter1;\nvoid countup0(){\n  interrupt_counter0 += 1;\n}\n\nvoid countup1(){\n  interrupt_counter1 += 1;\n}\n\nvoid setup(){\n\tSerial.begin(BAUD_RATE);\n\tpinMode(INTERRUPT0_PIN, INPUT);\n\tpinMode(INTERRUPT1_PIN, INPUT);\n  interrupt_counter0 = 0;\n  interrupt_counter1 = 0;\n  attachInterrupt(digitalPinToInterrupt(INTERRUPT0_PIN), countup0, RISING);\n  attachInterrupt(digitalPinToInterrupt(INTERRUPT1_PIN), countup1, RISING);\n}\n\nvoid loop(){\n\tDEBUG(\"interrupt_counter0=\");\n\tDEBUG(interrupt_counter0);\n\tDEBUG(\" interrupt_counter1=\");\n\tDEBUG(interrupt_counter1);\n\tDEBUGLN();\n  delay(10);\n}\n", "line": 6, "slice": ["#include <Wire.h>", "", "#define __DEBUG__", "#ifdef __DEBUG__", "#define DEBUG(...) Serial.print(__VA_ARGS__)", "#define DEBUGLN(...) Serial.println(__VA_ARGS__)", "#else", "#define DEBUG(...)", "#define DEBUGLN(...)", "#endif", "", "#define BAUD_RATE 500000", "", "volatile unsigned long interrupt_counter0;", "volatile unsigned long interrupt_counter1;", "", "void setup(){", "\tSerial.begin(BAUD_RATE);", "  interrupt_counter0 = 0;", "  interrupt_counter1 = 0;", "}", "", "void loop(){", "\tDEBUG(\"interrupt_counter0=\");", "\tDEBUG(interrupt_counter0);", "\tDEBUG(\" interrupt_counter1=\");", "\tDEBUG(interrupt_counter1);", "\tDEBUGLN();", "}"]}
{"code": "#include <SoftwareSerial.h>\n#include <Wisol.h>\n\n\ntypedef struct {\n  uint8_t counter;\n} Payload;\n\n\nSoftwareSerial stream(10, 11);\nWisol sigfox(&stream);\n\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  stream.begin(9600);\n}\n\n\nvoid loop() {\n  Payload p = { rand() * 100 };\n  \n  Serial.println(sigfox.dumpInfo());\n  Serial.print(\"Temp: \"); Serial.println(sigfox.getTemp());\n  Serial.print(\"Send: \"); Serial.println(sigfox.send(&p, sizeof(p)) ? \"OK\" : \"ERR\");\n  delay(30000);\n}", "line": 25, "slice": ["#include <SoftwareSerial.h>", "#include <Wisol.h>", "", "typedef struct {", "  uint8_t counter;", "} Payload;", "", "SoftwareSerial stream(10, 11);", "Wisol sigfox(&stream);", "", "void setup() {", "  stream.begin(9600);", "}", "", "void loop() {", "  Payload p = { rand() * 100 };", "  Serial.println(sigfox.send(&p, sizeof(p)) ? \"OK\" : \"ERR\");", "}"]}
{"code": "#include <dtostrg.h>\n//#define MAXPREC 10\ndouble number;\nchar buff[31];\n\n#ifdef DTOSTR_D\nvoid debug_print(char *msg, double d) {\n  Serial.print(msg);\n  Serial.println(d);\n}\n#endif\n\nvoid setup() {\n  // put your setup code here, to run once:\n\n  char width = 29;\n  long startt;\n\n  Serial.begin(115200);\n\n  number = 1234.567890123456789;\n  Serial.println(\"number: 1234.567890123456789\");\n\n  for (char prec = 0; prec <= MAXPREC; prec++) {\n    Serial.println((int)prec);\n    Serial.println(dtostrg(number, width, prec, buff));\n    Serial.print(dtostrg(-number, width, prec, buff));\n    startt = millis();\n    for (int i = 0; i < 3000; i++) {\n      dtostrg(number, width, prec, buff);\n    }\n    startt = millis() - startt;\n    delay(0);//To do background procesing and prevent watchdog reset\n    Serial.print('\\t');\n    Serial.println(startt / 3000.);\n    Serial.println(dtostre(-number,  buff , prec,0));\n  }\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  Serial.print('#');\n  delay(1000);\n\n}\n", "line": 7, "slice": ["#include <dtostrg.h>", "double number;", "char buff[31];", "void setup() {", "  char width = 29;", "  Serial.begin(115200);", "  number = 1234.567890123456789;", "  Serial.println(\"number: 1234.567890123456789\");", "  for (char prec = 0; prec <= MAXPREC; prec++) {", "    Serial.println((int)prec);", "    Serial.println(dtostrg(number, width, prec, buff));", "    Serial.print(dtostrg(-number, width, prec, buff));", "    for (int i = 0; i < 3000; i++) {", "      dtostrg(number, width, prec, buff);", "    }", "    Serial.println(dtostre(-number,  buff , prec,0));", "  }", "}"]}
{"code": "// This is obsoloute so you will get default temprature around 52 or 53 from chip,=.\r\n#include <WiFi.h> \r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\nuint8_t temprature_sens_read();\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\nuint8_t temprature_sens_read();\r\n\r\n\r\nconst char *ssid =  \"Excitel\";     \r\nconst char *pass =  \"9998332670\";\r\n\r\nWiFiClient client;\r\n\r\n\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n       delay(10);\r\n \r\n       Serial.println(\"Connecting to \");\r\n       Serial.println(ssid);\r\n \r\n \r\n       WiFi.begin(ssid, pass);\r\n \r\n      while (WiFi.status() != WL_CONNECTED) \r\n     {\r\n            delay(500);\r\n            Serial.print(\".\");\r\n     }\r\n      Serial.println(\"\");\r\n      Serial.println(\"WiFi connected\");\r\n  \r\n}\r\n\r\nvoid loop() {\r\n  Serial.print(\"Temperature: \");\r\n  \r\n  Serial.print((temprature_sens_read() - 32) / 1.8);\r\n  Serial.println(\" C\");\r\n  delay(500);\r\n}\r\n", "line": 34, "slice": ["uint8_t temprature_sens_read();", "void loop() {", "  Serial.print(\"Temperature: \");", "  ", "  Serial.print((temprature_sens_read() - 32) / 1.8);", "  Serial.println(\" C\");", "  delay(500);", "}"]}
{"code": "// -----------------------------------------------------------------------------\n// Test a something to add to Processor.ino.\n\n#define RUN_DELAY 1\n\n// -----------------------------------------------------------------------------\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);        // Give the serial connection time to start before the first print.\n  Serial.println(\"\"); // Newline after garbage characters.\n  Serial.println(F(\"+++ Setup.\"));\n\n  Serial.println(F(\"+++ Start the processor loop.\"));\n}\n\n// -----------------------------------------------------------------------------\n// Device Loop for processing each byte of machine code.\n\n#ifdef RUN_DELAY\nstatic unsigned long timer = millis();\n#endif\nint counter = 0;\nvoid loop() {\n\n#ifdef RUN_DELAY\n  Serial.println(\"+ Delay.\");\n  // When testing, can add a cycle delay.\n  // Clock process timing is controlled by the timer.\n  // Example, 50000 : once every 1/2 second.\n  if (millis() - timer >= 2000) {\n    //  timer = millis();\n  }\n#endif\n\n  Serial.print(F(\"+ Loop: \"));\n  Serial.println(counter);\n\n  delay(500);\n\n}\n// -----------------------------------------------------------------------------\n", "line": 35, "slice": ["#define RUN_DELAY 1", "", "#ifdef RUN_DELAY", "static unsigned long timer = millis();", "#endif", "int counter = 0;", "void loop() {", "", "#ifdef RUN_DELAY", "  Serial.println(\"+ Delay.\");", "  if (millis() - timer >= 2000) {", "  }", "#endif", "", "  Serial.print(F(\"+ Loop: \"));", "  Serial.println(counter);", "", "  delay(500);", "", "}"]}
{"code": "#include <CircularBuffer.h>\n\nnamespace data {\n\ttypedef struct {\n\t\tunsigned long time;\n\t\tunsigned int value;\n\t\tbool flag;\n\t} record;\n\n\tvoid print(record r) {\n\t\tSerial.print(r.time);\n\t\tSerial.print(\"  \");\n\t\tSerial.print(r.value);\n\t\tSerial.print(\"  \");\n\t\tSerial.print(r.flag);\n\t}\n}\n\nCircularBuffer<data::record, 10> structs;\n\n#define SAMPLE_PIN A0\n\nvoid setup() {\n\tSerial.begin(9600);\n\tpinMode(SAMPLE_PIN, INPUT);\n\tSerial.println(\"STARTING UP\");\n}\n\nvoid loop() {\n\tunsigned int sample = analogRead(SAMPLE_PIN);\n\tif (sample != structs.last().value) {\n\t\tstructs.push(data::record{millis(), sample, sample > 512});\n\t\tSerial.println(\"---\");\n\t\tdelay(50);\n\t}\n\tif (structs.isFull()) {\n\t\tSerial.println(\"Stack is full:\");\n\t\twhile (!structs.isEmpty()) {\n\t\t\tdata::print(structs.shift());\n\t\t\tSerial.println();\n\t\t}\n\t\tSerial.println(\"START AGAIN\");\n\t}\n}\n", "line": 10, "slice": ["#include <CircularBuffer.h>", "", "namespace data {", "\ttypedef struct {", "\t\tunsigned long time;", "\t\tunsigned int value;", "\t\tbool flag;", "\t} record;", "}", "", "CircularBuffer<data::record, 10> structs;", "", "#define SAMPLE_PIN A0", "", "void setup() {", "\tpinMode(SAMPLE_PIN, INPUT);", "}", "", "void loop() {", "\tunsigned int sample = analogRead(SAMPLE_PIN);", "\tif (sample != structs.last().value) {", "\t\tstructs.push(data::record{millis(), sample, sample > 512});", "\t}", "\tif (structs.isFull()) {", "\t\twhile (!structs.isEmpty()) {", "\t\t\tdata::print(structs.shift());", "\t\t}", "\t}", "}"]}
{"code": "#include <Arduino.h>\r\n#include <U8g2lib.h>\r\n\r\n#ifdef U8X8_HAVE_HW_SPI\r\n#include <SPI.h>\r\n#endif\r\n#ifdef U8X8_HAVE_HW_I2C\r\n#include <Wire.h>\r\n#endif\r\n\r\n\r\n/*\r\n  U8g2lib Example Overview:\r\n    Frame Buffer Examples: clearBuffer/sendBuffer. Fast, but may not work with all Arduino boards because of RAM consumption\r\n    Page Buffer Examples: firstPage/nextPage. Less RAM usage, should work with all Arduino boards.\r\n    U8x8 Text Only Example: No RAM usage, direct communication with display controller. No graphics, 8x8 Text only.\r\n    \r\n  This is a frame buffer example.    \r\n*/\r\n\r\n\r\n//U8G2_SSD1306_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // if you use Hardware I2C port, page buffer, size = 128Bytes\r\n//U8G2_SSD1306_128X64_NONAME_2_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // if you use Hardware I2C port, page buffer, size = 256Bytes\r\nU8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // if you use Hardware I2C port, full framebuffer, size = 1024 bytes\r\n\r\n//U8G2_SSD1306_128X64_NONAME_1_SW_I2C u8g2(U8G2_R0, /* SCL= */ 2, /* SDA= */3, /* reset=*/ U8X8_PIN_NONE); // if you use software I2C port\uff0cpage buffer, size = 128Bytes\r\n//U8G2_SSD1306_128X64_NONAME_2_SW_I2C u8g2(U8G2_R0, /* SCL= */ 2, /* SDA= */3, /* reset=*/ U8X8_PIN_NONE); // if you use software I2C port, page buffer, size = 256Bytes\r\n//U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, /* SCL= */ 2, /* SDA= */3, /* reset=*/ U8X8_PIN_NONE); // if you use software I2C port, full framebuffer, size = 1024 bytes\u200b\r\n\r\nvoid setup(void) {\r\n  u8g2.begin();\r\n}\r\nvoid loop(void) {\r\n  u8g2.clearBuffer();          // clear the internal memory\r\n  u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font\r\n  u8g2.drawStr(0,10,\"Hello World!\");  // write something to the internal memory\r\n  u8g2.setFont(u8g2_font_ncenB18_tr); // choose a suitable font\r\n  u8g2.drawStr(0,40,\"Hello World!\");  // write something to the internal memory\r\n  u8g2.setFont(u8g2_font_pieceofcake_mel_tr); // choose a suitable font\r\n  u8g2.drawStr(0,60,\"Hello World!\");  // write something to the internal memory\r\n  u8g2.setCursor(40, 80);\r\n  u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font\r\n  u8g2.print(\"Hello World!\");\r\n  u8g2.setFont(u8g2_font_unifont_t_symbols);\r\n  u8g2.drawGlyph(40, 100, 0x2603);\r\n  u8g2.sendBuffer();          // transfer internal memory to the display\r\n  delay(1000);  \r\n}\r\n", "line": 43, "slice": ["#include <Arduino.h>", "#include <U8g2lib.h>", "U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE); // if you use Hardware I2C port, full framebuffer, size = 1024 bytes", "void setup(void) {", "  u8g2.begin();", "}", "void loop(void) {", "  u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font", "  u8g2.setCursor(40, 80);", "  u8g2.print(\"Hello World!\");", "  u8g2.sendBuffer();          // transfer internal memory to the display", "}"]}
{"code": "//Gravity Acceleration \n#include \"LIS3DHTR.h\" \n\n#ifdef SOFTWAREWIRE\n  #include <SoftwareWire.h>\n  SoftwareWire myWire(3, 2); \n  LIS3DHTR<SoftwareWire> LIS(I2C_MODE);//IIC \n  #define WIRE myWire\n#else\n  #include <Wire.h>\n  LIS3DHTR<TwoWire> LIS;//IIC \n  #define WIRE Wire\n#endif\n\nvoid setup() {\n  Serial.begin(9600);\n  while (!Serial) {};\n  LIS.begin(WIRE); //IIC init\n  delay(100); \n  LIS.setOutputDataRate(LIS3DHTR_DATARATE_50HZ);\n}\nvoid loop() {\n  if (!LIS) {\n    Serial.println(\"LIS3DHTR didn't connect.\"); \n    while (1);\n    return;\n  }\n  //3 axis\n  Serial.print(\"x:\"); \n  Serial.print(LIS.getAccelerationX()); \n  Serial.print(\" \");\n  Serial.print(\"y:\"); \n\n  Serial.print(LIS.getAccelerationY()); \n  Serial.print(\" \");\n  Serial.print(\"z:\"); \n\n  Serial.println(LIS.getAccelerationZ()); \n\n  delay(500);\n}\n", "line": 29, "slice": ["#include \"LIS3DHTR.h\" ", "#ifdef SOFTWAREWIRE", "  SoftwareWire myWire(3, 2); ", "  LIS3DHTR<SoftwareWire> LIS(I2C_MODE);//IIC ", "  #define WIRE myWire", "#else", "  #include <Wire.h>", "  LIS3DHTR<TwoWire> LIS;//IIC ", "  #define WIRE Wire", "#endif", "void setup() {", "  LIS.begin(WIRE); //IIC init", "  LIS.setOutputDataRate(LIS3DHTR_DATARATE_50HZ);", "}", "void loop() {", "  if (!LIS) {", "    return;", "  }", "  Serial.println(LIS.getAccelerationZ()); ", "  delay(500);", "}"]}
{"code": "// RFID_UART.ino\n\n#include <SoftwareSerial.h>\n#include <SeeedRFID.h>\n\n#define RFID_RX_PIN 10\n#define RFID_TX_PIN 11\n\n// #define DEBUG\n// #define TEST\n\nSeeedRFID RFID(RFID_RX_PIN, RFID_TX_PIN);\nRFIDdata tag;\n\nvoid setup() {\n    Serial.begin(57600);\n    Serial.println(\"RFID Test..\");\n}\n\nvoid loop() {\n    if (RFID.isAvailable()) {\n        tag = RFID.data();\n        Serial.print(\"RFID card number: \");\n        Serial.println(RFID.cardNumber());\n        #ifdef TEST\n        Serial.print(\"RFID raw data: \");\n        for (int i = 0; i < tag.dataLen; i++) {\n            Serial.print(tag.raw[i], HEX);\n            Serial.print('\\t');\n        }\n        #endif\n    }\n}\n\n", "line": 23, "slice": ["#include <SoftwareSerial.h>", "#include <SeeedRFID.h>", "", "#define RFID_RX_PIN 10", "#define RFID_TX_PIN 11", "", "SeeedRFID RFID(RFID_RX_PIN, RFID_TX_PIN);", "RFIDdata tag;", "", "void loop() {", "    if (RFID.isAvailable()) {", "        tag = RFID.data();", "        Serial.print(\"RFID card number: \");", "        Serial.println(RFID.cardNumber());", "    }", "}"]}
{"code": "#include \"Seeed_vl53l0x.h\"\nSeeed_vl53l0x VL53L0X;\n\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n    #define SERIAL SerialUSB\n#else\n    #define SERIAL Serial\n#endif\n\n\n\nvoid setup() {\n    VL53L0X_Error Status = VL53L0X_ERROR_NONE;\n    SERIAL.begin(115200);\n    Status = VL53L0X.VL53L0X_common_init();\n    if (VL53L0X_ERROR_NONE != Status) {\n        SERIAL.println(\"start vl53l0x mesurement failed!\");\n        VL53L0X.print_pal_error(Status);\n        while (1);\n    }\n    VL53L0X.VL53L0X_continuous_ranging_init();\n    if (VL53L0X_ERROR_NONE != Status) {\n        SERIAL.println(\"start vl53l0x mesurement failed!\");\n        VL53L0X.print_pal_error(Status);\n        while (1);\n    }\n}\n\n\nvoid loop() {\n    VL53L0X_RangingMeasurementData_t RangingMeasurementData;\n    VL53L0X.PerformContinuousRangingMeasurement(&RangingMeasurementData);\n    if (RangingMeasurementData.RangeMilliMeter >= 2000) {\n        SERIAL.println(\"out of ranger\");\n    } else {\n        SERIAL.print(\"distance::\");\n        SERIAL.println(RangingMeasurementData.RangeMilliMeter);\n    }\n    delay(100);\n}\n\n\n", "line": 36, "slice": ["#include \"Seeed_vl53l0x.h\"", "Seeed_vl53l0x VL53L0X;", "", "#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE", "    #define SERIAL SerialUSB", "#else", "    #define SERIAL Serial", "#endif", "", "void setup() {", "    VL53L0X.VL53L0X_continuous_ranging_init();", "}", "", "void loop() {", "    VL53L0X_RangingMeasurementData_t RangingMeasurementData;", "    VL53L0X.PerformContinuousRangingMeasurement(&RangingMeasurementData);", "    if (RangingMeasurementData.RangeMilliMeter >= 2000) {", "        SERIAL.println(\"out of ranger\");", "    } else {", "        SERIAL.print(\"distance::\");", "        SERIAL.println(RangingMeasurementData.RangeMilliMeter);", "    }", "    delay(100);", "}"]}
{"code": "/*  Example of reading and writing USB Host Shield GPI output using low-level functions\n    This example uses low-level UHS interface. See Blink for example of using \"Wiring\" style interface\n    Author: Brian Walton (brian@riban.co.uk)\n*/\n#include <Usb.h>\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include <spi4teensy3.h>\n#endif\n#include <SPI.h>\n\nUSB     Usb;\n\nvoid setup() {\n  Serial.begin( 115200 );\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  Serial.println(\"Start\");\n\n  if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n\n  delay( 200 );\n}\n\nvoid loop() {\n  // Get the current output value, toggle then wait half a second\n  uint8_t nGPO = Usb.gpioRdOutput();\n  uint8_t nValue = ((nGPO & 0x01) == 0x01) ? 0 : 1;\n  nGPO &= 0xFE; // Clear bit 0\n  nGPO |= nValue;\n  Usb.gpioWr(nGPO);\n  Serial.print(nValue ? \"+\" : \".\"); // Debug to show what the output should be doing\n  delay(500);\n}\n\n", "line": 35, "slice": ["#include <Usb.h>", "USB     Usb;", "uint8_t nGPO = Usb.gpioRdOutput();", "uint8_t nValue = ((nGPO & 0x01) == 0x01) ? 0 : 1;", "nGPO &= 0xFE; // Clear bit 0", "nGPO |= nValue;", "Usb.gpioWr(nGPO);"]}
{"code": "/*\r\n * This is a speed unit test for the STM32F103\r\n * Specify the tickRatio, SAMPLE_TIME and QUAD_TIMER_x (timers with encoder mode)\r\n * See the \"SpeedEncoder.h\" file for the pinouts for each quadrature encoder timer\r\n*/\r\n#ifdef SPEED\r\n\r\n#include \"src/SpeedEncoder.h\"\r\n\r\n#define tickRatio 1920\r\n#define SAMPLE_TIME 8e3   // microseconds\r\n\r\nSpeedEncoder leftEncoder(QUAD_TIMER_2, tickRatio, SAMPLE_TIME);\r\n\r\nvoid setup() {\r\n  // Start up serial\r\n  Serial.begin(115200);\r\n\r\n  // Config encoders\r\n  leftEncoder.begin();\r\n}\r\n\r\nvoid loop() {\r\n  // Update every SAMPLE_TIME\r\n  if(leftEncoder.sampleData()) {\r\n    printData();\r\n  }\r\n}\r\n\r\n// Prints data\r\nvoid printData() {\r\n  // Get data\r\n  float w = leftEncoder.getTickSpeed();\r\n  float t = leftEncoder.getCurrTime();\r\n\r\n  // Print details\r\n  Serial.print(t); Serial.print(\", \");\r\n  Serial.print(w); Serial.println();  \r\n}\r\n\r\n#endif\r\n", "line": 37, "slice": ["#include \"src/SpeedEncoder.h\"", "", "#define tickRatio 1920", "#define SAMPLE_TIME 8e3   // microseconds", "", "SpeedEncoder leftEncoder(QUAD_TIMER_2, tickRatio, SAMPLE_TIME);", "", "void loop() {", "  // Update every SAMPLE_TIME", "  if(leftEncoder.sampleData()) {", "    printData();", "  }", "}", "", "void printData() {", "  // Get data", "  float w = leftEncoder.getTickSpeed();", "  float t = leftEncoder.getCurrTime();", "", "  // Print details", "  Serial.print(t); Serial.print(\", \");", "  Serial.print(w); Serial.println();  ", "}"]}
{"code": "typedef struct sensordata\n{\n  float outTemp;\n  float inTemp;\n  float humidity;\n  float pressure;\n}bmp;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // Creating variable of weather datatype\n  bmp bmp1;\n  bmp1.outTemp = random(1, 50);\n  bmp1.inTemp = random(1, 24);\n  bmp1.humidity = random(1, 50);\n  bmp1.pressure = random(0, 1);\n\n  Serial.print(\"The outdoor temp was: \");\n  Serial.println(bmp1.outTemp);\n  delay(1000);\n\n  Serial.print(\"The indoor temp was: \");\n  Serial.println(bmp1.inTemp);\n  delay(1000);\n\n  Serial.print(\"The humidity was: \");\n  Serial.println(bmp1.humidity);\n  delay(1000);\n\n  Serial.print(\"The pressure was: \");\n  Serial.println(bmp1.pressure);\n  delay(1000);\n}\n", "line": 21, "slice": ["typedef struct sensordata", "{", "  float outTemp;", "  float inTemp;", "  float humidity;", "  float pressure;", "}bmp;", "", "bmp bmp1;", "bmp1.pressure = random(0, 1);", "", "Serial.print(\"The pressure was: \");", "Serial.println(bmp1.pressure);"]}
{"code": "// Interactive Astronomy SkyAlert simulator for Arduino\n//\n// Copyright (c) 2021 CloudMakers, s. r. o.\n// All rights reserved.\n//\n// You can use this software under the terms of 'INDIGO Astronomy\n// open-source license' (see LICENSE.md).\n//\n// THIS SOFTWARE IS PROVIDED BY THE AUTHORS 'AS IS' AND ANY EXPRESS\n// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#ifdef ARDUINO_SAM_DUE\n#define Serial SerialUSB\n#endif\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.setTimeout(500);\n  while (!Serial)\n    ;\n}\n\nvoid loop() {\n  String command = Serial.readStringUntil('\\r');\n  if (command.equals(\"send\")) {\n    Serial.print(\"Data\\r\");\n    Serial.print(\"20.3\\r\");\n    Serial.print(\"1\\r\");\n    Serial.print(\"1008\\r\");\n    Serial.print(\"751\\r\");\n    Serial.print(\"66.3\\r\");\n    Serial.print(\"415\\r\");\n    Serial.print(\"1\\r\");\n    Serial.print(\"1.8m\\r\");\n    Serial.print(\"101791.83\\r\");\n  }\n}\n", "line": 35, "slice": ["void loop() {", "  String command = Serial.readStringUntil('\\r');", "  if (command.equals(\"send\")) {", "    Serial.print(\"Data\\r\");", "    Serial.print(\"20.3\\r\");", "    Serial.print(\"1\\r\");", "    Serial.print(\"1008\\r\");", "    Serial.print(\"751\\r\");", "    Serial.print(\"66.3\\r\");", "    Serial.print(\"415\\r\");", "    Serial.print(\"1\\r\");", "    Serial.print(\"1.8m\\r\");", "    Serial.print(\"101791.83\\r\");", "  }", "}"]}
{"code": "#include <LiquidCrystal.h>\n#include <NmraDcc.h>\n#include <Zeus.h>\n#include \"global.h\"\n\nunsigned long myTime;\n\nLiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);\nZeus          zeus ;\nNmraDcc       Dcc ;\n\n#define DCC_PIN     2\n\nvoid setupDCCDecoder()\n{\n  Serial.println(F(\"Setting up DCC Decorder...\"));\n\n#ifdef digitalPinToInterrupt\n  Dcc.pin(DCC_PIN, 0);\n#else\n  Dcc.pin(0, DCC_PIN, 1);\n#endif\n  \n  Dcc.init( MAN_ID_DIY, 10, CV29_ACCESSORY_DECODER | CV29_OUTPUT_ADDRESS_MODE, 0 );\n}\n\nvoid setup() {\n  Serial.begin(9600);\n  lcd.begin(16, 2);\n}\n\nvoid loop() {\n  zeus.Read();\n\n  lcd.setCursor(0, 0);\n  lcd.print( \"rx:  Installed \");\n\n  lcd.setCursor(0, 1);\n  lcd.print( \"A:\"  + zeus.Address()   );\n\n  lcd.setCursor(6, 1);\n  lcd.print( \"C:\"  + zeus.Command()   );\n\n  lcd.setCursor(13, 1);\n  lcd.print( \"R:\"  + zeus.Status()   );\n  \n  Serial.println( zeus.Status() );                   // Send Time Back to USB \n\n  Dcc.process();\n}\n", "line": 36, "slice": ["#include <LiquidCrystal.h>", "#include <Zeus.h>", "#include \"global.h\"", "", "LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);", "Zeus          zeus ;", "", "void setup() {", "  lcd.begin(16, 2);", "}", "", "void loop() {", "  zeus.Read();", "", "  lcd.setCursor(13, 1);", "  lcd.print( \"R:\"  + zeus.Status()   );", "}"]}
{"code": "#ifdef ESP8266\r\n#include <ESP8266WiFi.h>\r\n#include <ESP8266mDNS.h>\r\n#include <ArduinoOTA.h>\r\n#include <ESP8266WebServer.h>\r\nESP8266WebServer server(80);\r\n#else\r\n#include <WiFi.h>\r\n#include <ESPmDNS.h>\r\n#include <ArduinoOTA.h>\r\n#include <WebServer.h>\r\nWebServer server(80);\r\n#endif\r\n\r\nconst char* ssid = \"........\";\r\nconst char* password = \"........\";\r\n\r\nconst char* www_username = \"admin\";\r\nconst char* www_password = \"esp8266esp32\";\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  WiFi.mode(WIFI_STA);\r\n  WiFi.begin(ssid, password);\r\n  if(WiFi.waitForConnectResult() != WL_CONNECTED) {\r\n    Serial.println(\"WiFi Connect Failed! Rebooting...\");\r\n    delay(1000);\r\n    ESP.restart();\r\n  }\r\n  ArduinoOTA.begin();\r\n\r\n  server.on(\"/\", [](){\r\n    if(!server.authenticate(www_username, www_password))\r\n      return server.requestAuthentication();\r\n    server.send(200, \"text/plain\", \"Login OK\");\r\n  });\r\n  server.begin();\r\n\r\n  Serial.print(\"Open http://\");\r\n  Serial.print(WiFi.localIP());\r\n  Serial.println(\"/ in your browser to see it working\");\r\n}\r\n\r\nvoid loop() {\r\n  ArduinoOTA.handle();\r\n  server.handleClient();\r\n}\r\n", "line": 39, "slice": ["#ifdef ESP8266", "#include <ESP8266WebServer.h>", "ESP8266WebServer server(80);", "#else", "#include <WebServer.h>", "WebServer server(80);", "#endif", "", "const char* www_username = \"admin\";", "const char* www_password = \"esp8266esp32\";", "", "server.on(\"/\", [](){", "    if(!server.authenticate(www_username, www_password))", "      return server.requestAuthentication();", "    server.send(200, \"text/plain\", \"Login OK\");", "  });", "server.begin();", "", "void loop() {", "  server.handleClient();", "}"]}
{"code": "// SPDX-FileCopyrightText: 2021 BlueMicro_HID_Common contributors (https://github.com/jpconstantineau/BlueMicro_HID_Common/graphs/contributors)\n//\n// SPDX-License-Identifier: BSD-3-Clause\n\n#ifdef USE_TINYUSB \n#include \"Adafruit_TinyUSB.h\"\n#endif\n\nvoid setup() {\n  // put your setup code here, to run once:\nSerial.begin(115200);\n#if CFG_TUSB_MCU == OPT_MCU_RP2040\n  Serial.print(\"hello RP2040\");\n#endif\n\n#ifdef NRF52\n  Serial.print(\"hello nRF52\");\n#endif\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n", "line": 13, "slice": ["void setup() {", "  // put your setup code here, to run once:", "Serial.begin(115200);", "#ifdef NRF52", "  Serial.print(\"hello nRF52\");", "#endif", "}"]}
{"code": "#include <SPI.h>  \r\n#include \"nRF24L01.h\"\r\n#include \"RF24.h\" \r\n\r\nRF24 myRadio (9, 10); \r\nstruct package\r\n{\r\n  int id=0;\r\n  float temperature = 0.0;\r\n  char  text[100] =\"\";\r\n};\r\n\r\nbyte addresses = '0xE8E8F0F0E1LL'; \r\n\r\n\r\n\r\ntypedef struct package Package;\r\nPackage data;\r\n\r\nvoid setup() \r\n{\r\n  Serial.begin(115200);\r\n  delay(1000);\r\n\r\n  myRadio.begin(); \r\n // myRadio.setChannel(115); \r\n  myRadio.setPALevel(RF24_PA_MAX);\r\n//  myRadio.setDataRate( RF24_250KBPS ) ; \r\n  myRadio.openReadingPipe(1, addresses);\r\n  myRadio.startListening();\r\n}\r\n\r\n\r\nvoid loop()  \r\n{\r\n\r\nwhile (myRadio.available())\r\n    {\r\n      myRadio.read( &data, sizeof(data) );\r\n    }\r\n    Serial.print(\"\\nPackage:\");\r\n    Serial.print(data.id);\r\n    Serial.print(\"\\n\");\r\n    Serial.println(data.temperature);\r\n    Serial.println(data.text);\r\n  }\r\n", "line": 41, "slice": ["RF24 myRadio (9, 10); ", "struct package", "{", "  int id=0;", "  float temperature = 0.0;", "  char  text[100] =\"\";", "};", "", "typedef struct package Package;", "Package data;", "", "void setup() ", "{", "  myRadio.begin(); ", "  myRadio.openReadingPipe(1, addresses);", "  myRadio.startListening();", "}", "", "void loop()  ", "{", "", "while (myRadio.available())", "    {", "      myRadio.read( &data, sizeof(data) );", "    }", "    Serial.print(\"\\nPackage:\");", "    Serial.print(data.id);", "    Serial.print(\"\\n\");", "    Serial.println(data.temperature);", "    Serial.println(data.text);", "  }"]}
{"code": "#include \"Seeed_vl53l0x.h\"\nSeeed_vl53l0x VL53L0X;\n\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n  #define SERIAL SerialUSB\n#else\n  #define SERIAL Serial\n#endif\n\n\n\nvoid setup()\n{ \n\tVL53L0X_Error Status = VL53L0X_ERROR_NONE;\n\tSERIAL.begin(115200);\n\tStatus=VL53L0X.VL53L0X_common_init();\n\tif(VL53L0X_ERROR_NONE!=Status)\n\t{\n\t\tSERIAL.println(\"start vl53l0x mesurement failed!\");\n\t\tVL53L0X.print_pal_error(Status);\n\t\twhile(1);\n\t}\n\tVL53L0X.VL53L0X_continuous_ranging_init();\n\tif(VL53L0X_ERROR_NONE!=Status)\n\t{\n\t\tSERIAL.println(\"start vl53l0x mesurement failed!\");\n\t\tVL53L0X.print_pal_error(Status);\n\t\twhile(1);\n\t}\n}\n\n\nvoid loop()\n{\n    VL53L0X_RangingMeasurementData_t RangingMeasurementData;\n    VL53L0X.PerformContinuousRangingMeasurement(&RangingMeasurementData);\n\tif(RangingMeasurementData.RangeMilliMeter>=2000)\n\t{\n\t\tSERIAL.println(\"out of ranger\");\n\t}\n\telse\n\t{\n\t\tSERIAL.print(\"distance::\");\n    \tSERIAL.println(RangingMeasurementData.RangeMilliMeter);\n\t}\n    delay(100);\n}\n\n\n", "line": 43, "slice": ["#include \"Seeed_vl53l0x.h\"", "Seeed_vl53l0x VL53L0X;", "", "#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE", "  #define SERIAL SerialUSB", "#else", "  #define SERIAL Serial", "#endif", "", "void loop()", "{", "    VL53L0X_RangingMeasurementData_t RangingMeasurementData;", "    VL53L0X.PerformContinuousRangingMeasurement(&RangingMeasurementData);", "\tif(RangingMeasurementData.RangeMilliMeter>=2000)", "\t{", "\t\tSERIAL.println(\"out of ranger\");", "\t}", "\telse", "\t{", "\t\tSERIAL.print(\"distance::\");", "    \tSERIAL.println(RangingMeasurementData.RangeMilliMeter);", "\t}", "    delay(100);", "}"]}
{"code": "// Requires USB MIDI class driver for Arduino USB Host Shield 2.0 Library\n// https://github.com/YuuichiAkagawa/USBH_MIDI\n\n#include <MIDI.h>\n#include <usbh_midi.h>\n#include <usbhub.h>\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include <spi4teensy3.h>\n#include <SPI.h>\n#endif\n\nUSB UsbHost;\nUSBH_MIDI UsbMidi(&UsbHost);\n\nvoid setup() {\n  // stop if no usb host shield found\n  if (UsbHost.Init() == -1) {\n    while (1);\n  }\n  Serial.begin(9600);\n  Serial.println(\"USB Host Connected\");\n}\n\nvoid loop() {\n  uint8_t data[2];\n  UsbHost.Task();\n  if (UsbHost.getUsbTaskState() == USB_STATE_RUNNING) {\n    Serial.println(\"USB Host Running\");\n    for (byte i = 0; i < 10; ++i) {\n      data[0] = midi::ProgramChange;\n      data[1] = i;\n      Serial.print(\"Sending ProgramChange \");\n      Serial.println(i);\n      UsbMidi.SendData(data, 0);\n      delay(2000);\n    }\n  }\n}\n", "line": 34, "slice": ["#include <usbh_midi.h>", "#include <usbhub.h>", "USB UsbHost;", "USBH_MIDI UsbMidi(&UsbHost);", "void loop() {", "  uint8_t data[2];", "  UsbHost.Task();", "  if (UsbHost.getUsbTaskState() == USB_STATE_RUNNING) {", "    for (byte i = 0; i < 10; ++i) {", "      data[0] = midi::ProgramChange;", "      data[1] = i;", "      UsbMidi.SendData(data, 0);", "    }", "  }", "}"]}
{"code": "// Analog read\n// Manferdelli\n\nconst int dataPin= A0;\nconst int measurementDelay= 500;\ntypedef uint8_t byte;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int wetness = analogRead(dataPin);\n  Serial.print(\"Wetness: \");\n  Serial.print(wetness);\n  Serial.println(\"\");\n  delay(measurementDelay);\n}\n\n", "line": 14, "slice": ["const int dataPin= A0;", "const int measurementDelay= 500;", "", "void loop() {", "  int wetness = analogRead(dataPin);", "  Serial.print(wetness);", "  delay(measurementDelay);", "}"]}
{"code": "\n/*\n   NativeSdk by Simon Peter\n   Access functionality from the Espressif ESP8266 SDK\n   This example code is in the public domain\n\n   This is for advanced users.\n   Note that this makes your code dependent on the ESP8266, which is generally\n   a bad idea. So you should try to use esp8266/Arduino functionality\n   where possible instead, in order to abstract away the hardware dependency.\n*/\n\n// Expose Espressif SDK functionality - wrapped in ifdef so that it still\n// compiles on other platforms\n#ifdef ESP8266\nextern \"C\" {\n#include \"user_interface.h\"\n}\n#endif\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  // Call Espressif SDK functionality - wrapped in ifdef so that it still\n  // compiles on other platforms\n  #ifdef ESP8266\n  Serial.print(\"wifi_station_get_hostname: \");\n  Serial.println(wifi_station_get_hostname());\n  #endif\n  delay(1000);\n}\n", "line": 29, "slice": ["#ifdef ESP8266", "extern \"C\" {", "#include \"user_interface.h\"", "}", "#endif", "", "void setup() {", "  Serial.begin(115200);", "}", "", "void loop() {", "  #ifdef ESP8266", "  Serial.print(\"wifi_station_get_hostname: \");", "  Serial.println(wifi_station_get_hostname());", "  #endif", "}"]}
{"code": "#include <Arduino.h>\n\n#include \"game.h\"\n#include <Arduboy2.h>\n#include <ArduboyPlaytune.h>\n\nArduboy2 arduboy;\nSprites sprites;\n\nArduboyPlaytune sound(arduboy.audio.enabled);\n\nvoid setup()\n{\n//    Serial.begin(9600);\n    arduboy.begin();\n    arduboy.setFrameRate(30);\n    arduboy.setTextSize(1);\n    arduboy.clear();\n\n    sound.initChannel(PIN_SPEAKER_1);\n    sound.initChannel(PIN_SPEAKER_2);\n}\n\nvoid loop()\n{\n    if (!arduboy.nextFrame()) {\n        return;\n    }\n\n    arduboy.pollButtons();\n\n    tick();\n\n\n#ifdef DEBUG\n    {\n        char line[32];\n        sprintf(line, \"%d%%\", arduboy.cpuLoad());\n\n        arduboy.setCursor(104, 2);\n        arduboy.print(line);\n    }\n#endif\n\n\n//    Serial.write(arduboy.getBuffer(), 128 * 64 / 8);\n    arduboy.display();\n\n\n} // loop\n", "line": 41, "slice": ["#include <Arduino.h>", "#include \"game.h\"", "#include <Arduboy2.h>", "Arduboy2 arduboy;", "void setup()", "{", "    arduboy.begin();", "    arduboy.setFrameRate(30);", "    arduboy.setTextSize(1);", "    arduboy.clear();", "}", "void loop()", "{", "    if (!arduboy.nextFrame()) {", "        return;", "    }", "    arduboy.pollButtons();", "    tick();", "    arduboy.display();", "}"]}
{"code": "/*\r\n  Blink regular vs volatile Benchmark \r\n  Changes the state of an LED and calls a delay function repeatedly.\r\n */\r\n \r\n// Use the following line to report back to the serial monitor.\r\n//#define MEASURE\r\n\r\n#define MASK(x) ((unsigned char)(1<<(x)))\r\n\r\n#ifdef MEASURE\r\nuint32_t StartTime, CurrentTime;\r\n#endif\r\n\r\nvoid setup() {                \r\n  DDRB |= MASK(5);   // The LED pin is output. Mask: 00100000 \r\n  Serial.begin(9600);  \r\n}\r\n\r\nvoid wait(){\r\n  uint32_t x=100000;\r\n  while(x)\r\n    x--;\r\n}\r\n  \r\nvoid loop() {\r\n  PORTB ^= MASK(5);  // Toggle LED \r\n  \r\n  #ifdef MEASURE\r\n    StartTime = millis();\r\n  #endif\r\n  \r\n  wait();\r\n  wait();\r\n  wait();\r\n  wait();\r\n  wait();\r\n\r\n  #ifdef MEASURE\r\n    CurrentTime = millis();\r\n    Serial.print(\"Took \");\r\n    Serial.print((float)(CurrentTime - StartTime)*0.001,3);\r\n    Serial.print(\" seconds\\n\");\r\n  #endif\r\n}\r\n", "line": 41, "slice": ["#define MASK(x) ((unsigned char)(1<<(x)))", "", "void setup() {                ", "  DDRB |= MASK(5);   // The LED pin is output. Mask: 00100000 ", "}", "", "void loop() {", "  PORTB ^= MASK(5);  // Toggle LED ", "", "  wait();", "  wait();", "  wait();", "  wait();", "  wait();", "}"]}
{"code": "\n\nvoid printlnDebug(String msg) {\n  #ifdef DEBUG\n  Serial.println(msg);\n  #endif\n}\n\nvoid printlnDebug(int msg) {\n  #ifdef DEBUG\n  Serial.println(msg);\n  #endif\n}\n\nvoid printDebug(String msg) {\n  #ifdef DEBUG\n  Serial.print(msg);\n  #endif\n}\n\n", "line": 17, "slice": ["The code provided does not have a line 17."]}
{"code": "/*\n   Copyright (c) 2019 Stefan Kremser\n   This software is licensed under the MIT License. See the license file for details.\n   Source: github.com/spacehuhn/WiFiDuck\n */\n\n#include \"config.h\"\n#include \"debug.h\"\n\n#include \"i2c.h\"\n#include \"duckscript.h\"\n#include \"webserver.h\"\n#include \"spiffs.h\"\n#include \"settings.h\"\n#include \"cli.h\"\n\nvoid setup() {\n#ifdef ENABLE_DEBUG\n    Serial.begin(DEBUG_BAUD);\n    Serial.setTimeout(200);\n#endif // ifdef DEBUG\n\n    i2c::begin();\n    i2c::setOnOK(duckscript::nextLine);\n    // i2c::setOnProcessing();\n    i2c::setOnError(duckscript::stop);\n    i2c::setOnRepeat(duckscript::repeat);\n\n    spiffs::begin();\n\n    settings::begin();\n\n    cli::begin();\n\n    webserver::begin();\n\n    debugln(\"\\nESP Duck Started\");\n}\n\nvoid loop() {\n    i2c::update();\n\n    if (Serial.available()) {\n        String input = Serial.readStringUntil('\\n');\n        cli::parse(input.c_str(), [](const char* str) {\n            Serial.print(str);\n        });\n    }\n}", "line": 46, "slice": ["#include \"cli.h\"", "", "void setup() {", "    cli::begin();", "}", "", "void loop() {", "    if (Serial.available()) {", "        String input = Serial.readStringUntil('\\n');", "        cli::parse(input.c_str(), [](const char* str) {", "            Serial.print(str);", "        });", "    }", "}"]}
{"code": "/*\r\n\tTODO Task 2. Night Light with Timer: \r\n\t\t\tMake a night light that has a delay so that it will only turn off after 3 seconds\r\n\t\t\tImplemented\r\n\r\n\tTODO Extension Task \r\n\t\tThe current program pauses the execution flow due to the 'delay' method. This can cause problems if multiple devices are connected to the Arduino\r\n\t\tFind a method which will allow the execution flow to continue while keeping the same functionality. I.e. the LED will stay lit for 3 seconds.\r\n\t\tNot Implemented\r\n*/\r\n#define DEBUG\r\n\r\nconst int photoPin = 0;\r\nconst int redLed = 7;\r\n\r\nconst int darkLevel = 500; //The value the photoresistor has to at least be before turning the LED on\r\nvoid setup()\r\n{\r\n\tSerial.begin(9600);\r\n\tpinMode(redLed, OUTPUT);\r\n}\r\n\r\n// Add the main program code into the continuous loop() function\r\nvoid loop()\r\n{\r\n\tint lightLevel = analogRead(photoPin);\r\n#ifdef DEBUG\r\n\tSerial.print(\"Light Level: \");\r\n\tSerial.println(lightLevel);\r\n\r\n#endif // DEBUG\r\n\r\n\tif (lightLevel > darkLevel)\r\n\t{\r\n\t\tdigitalWrite(redLed, HIGH);\r\n\t\tdelay(3000);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdigitalWrite(redLed, LOW);\r\n\t}\r\n\tdelay(1000);\r\n}\r\n", "line": 28, "slice": ["const int photoPin = 0;", "const int redLed = 7;", "const int darkLevel = 500; //The value the photoresistor has to at least be before turning the LED on", "void setup()", "{", "\tpinMode(redLed, OUTPUT);", "}", "void loop()", "{", "\tint lightLevel = analogRead(photoPin);", "\tif (lightLevel > darkLevel)", "\t{", "\t\tdigitalWrite(redLed, HIGH);", "\t\tdelay(3000);", "\t}", "\telse", "\t{", "\t\tdigitalWrite(redLed, LOW);", "\t}", "}"]}
{"code": "#ifdef ESP8266\n#include <ESP8266WiFi.h>\n#elif defined ESP32\n#include <WiFi.h>\n#include \"SPIFFS.h\"\n#endif\n\n#include <ESP8266FtpServer.h>\n\nconst char* ssid = \"YOUR_SSID\";\nconst char* password = \"YOUR_PASS\";\n\n\nFtpServer ftpSrv;   //set #define FTP_DEBUG in ESP8266FtpServer.h to see ftp verbose on serial\n\n\nvoid setup(void){\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n  Serial.println(\"\");\n\n  // Wait for connection\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"Connected to \");\n  Serial.println(ssid);\n  Serial.print(\"IP address: \");\n  Serial.println(WiFi.localIP());\n\n\n  /////FTP Setup, ensure SPIFFS is started before ftp;  /////////\n  \n  /////FTP Setup, ensure SPIFFS is started before ftp;  /////////\n#ifdef ESP32       //esp32 we send true to format spiffs if cannot mount\n  if (SPIFFS.begin(true)) {\n#elif defined ESP8266\n  if (SPIFFS.begin()) {\n#endif\n      Serial.println(\"SPIFFS opened!\");\n      ftpSrv.begin(\"esp8266\",\"esp8266\");    //username, password for ftp.  set ports in ESP8266FtpServer.h  (default 21, 50009 for PASV)\n  }    \n}\nvoid loop(void){\n  ftpSrv.handleFTP();        //make sure in loop you call handleFTP()!!  \n // server.handleClient();   //example if running a webserver you still need to call .handleClient();\n \n}\n", "line": 25, "slice": ["const char* ssid = \"YOUR_SSID\";", "const char* password = \"YOUR_PASS\";", "", "FtpServer ftpSrv;", "", "void setup(void){", "  WiFi.begin(ssid, password);", "", "  while (WiFi.status() != WL_CONNECTED) {", "    delay(500);", "  }", "", "#ifdef ESP32", "  if (SPIFFS.begin(true)) {", "#elif defined ESP8266", "  if (SPIFFS.begin()) {", "#endif", "      ftpSrv.begin(\"esp8266\",\"esp8266\");", "  }    ", "}", "", "void loop(void){", "  ftpSrv.handleFTP();  ", "}"]}
{"code": "void setupWifi() {\n  Serial.begin(115200);\n  delay(2000);\n\n  // WiFi stuff (no timeout setting for WiFi)\n#ifdef ESP_PLATFORM\n  WiFi.disconnect(true, true); // disable wifi, erase ap info\n  delay(1000);\n  WiFi.mode(WIFI_STA);\n#endif\n  WiFi.begin(SECRET_SSID, SECRET_PASS);\n  WiFi.config(ip, gateway, subnet);\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\"Attempting to connect to WPA SSID: \");\n    Serial.println(SECRET_SSID);\n    // Connect to WPA/WPA2 network:\n    WiFi.begin(SECRET_SSID, SECRET_PASS);\n\n    // wait 10 second for connection:\n    delay(10000);\n\n    // output some diagnostic info\n    Serial.println(\"Status = \" + WiFi.status());\n  }\n  Serial.print(\"WiFi connected, IP = \"); Serial.println(WiFi.localIP());\n}\n\n//-----------------------\nvoid loopOSC() {\n\n  static uint32_t prev_value_ms = millis();\n  if (millis() > prev_value_ms + millisOSC) // short active wait method before to send again\n  {\n    if (!bErrorData) {\n      OscWiFi.send(host, send_port, F(\"/spectrometer/green\"), coefVerdor, coefVerdorCali, greenValue, greenValueCali, blueValue, blueValueCali, redValue, redValueCali, violetValue, violetValueCali, yellowValue, yellowValueCali, orangeValue, orangeValueCali);//publish_port\n      prev_value_ms = millis();\n      if (true) {\n        Serial.println(\"send_port 55555\");\n        Serial.print(\"coefVerdor = \"); Serial.println(coefVerdor);\n        Serial.print(\"coefVerdorCali = \"); Serial.println(coefVerdorCali);\n      }\n    }\n  }\n}\n", "line": 14, "slice": ["void setupWifi() {", "  WiFi.begin(SECRET_SSID, SECRET_PASS);", "  WiFi.config(ip, gateway, subnet);", "  while (WiFi.status() != WL_CONNECTED) {", "    WiFi.begin(SECRET_SSID, SECRET_PASS);", "    delay(10000);", "  }", "  Serial.print(\"WiFi connected, IP = \"); Serial.println(WiFi.localIP());", "}"]}
{"code": "#include <SPI.h>  \n#include \"RF24.h\" \n\nRF24 myRadio (9, 10); \nbyte addresses[][6] = {\"0\"};\n\nstruct package {\n  int id=0;\n  float temperature = 0.0;\n  char  text[300] =\"empty\";\n}; \n\ntypedef struct package Package;\nPackage data;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n\n  myRadio.begin(); \n  myRadio.setChannel(55); \n  myRadio.setPALevel(RF24_PA_MAX);\n  myRadio.setDataRate( RF24_1MBPS );\n  \n  myRadio.openReadingPipe(1, addresses[0]);\n  myRadio.startListening();\n}\n\n\nvoid loop()  {\n  if ( myRadio.available()) {\n    while (myRadio.available()){\n      myRadio.read( &data, sizeof(data) );\n    }\n    Serial.print(\"\\nPackage:\");\n    Serial.print(data.id);\n    Serial.print(\"\\n\");\n    Serial.println(data.temperature);\n    Serial.println(data.text);\n  }\n}\n", "line": 35, "slice": ["RF24 myRadio (9, 10); ", "byte addresses[][6] = {\"0\"};", "", "struct package {", "  int id=0;", "  float temperature = 0.0;", "  char  text[300] =\"empty\";", "}; ", "", "typedef struct package Package;", "Package data;", "", "myRadio.begin(); ", "myRadio.setChannel(55); ", "myRadio.setPALevel(RF24_PA_MAX);", "myRadio.setDataRate( RF24_1MBPS );", "", "myRadio.openReadingPipe(1, addresses[0]);", "myRadio.startListening();", "", "if ( myRadio.available()) {", "  while (myRadio.available()){", "    myRadio.read( &data, sizeof(data) );", "  }", "  Serial.print(\"\\nPackage:\");", "  Serial.print(data.id);", "  Serial.print(\"\\n\");", "  Serial.println(data.temperature);", "  Serial.println(data.text);", "}"]}
{"code": "//#include \"Common.h\"\n\nvoid initMidi(){\n  MIDI.begin(4);          // Launch MIDI and listen to channel 4\n  \n  int i;\n  for (i=0;i<AXIS_NUM;i++){\n    midiAxis[i]=0;\n    lastMidiAxis[i]=0;\n  }\n}\n\nvoid midiSend(int cc, int value,int chnl){\n#ifdef SERIAL_DEBUG\n#if 0//def DEBUG\n      Serial.print(\"midi: cc=\");\n      Serial.print(cc);\n      Serial.print(\" value=\");\n      Serial.print(value);\n      Serial.print(\" Channel=\");\n      Serial.println(chnl);\n#endif //DEBUG\n#else\n#ifdef TEENSY\n#ifndef BUTTONS_SEND_MIDI_NOTES\n      usbMIDI.sendControlChange(cc, value, chnl);\n#else\n      usbMIDI.sendNoteOff(cc, value, chnl);\n#endif //BUTTONS_SEND_MIDI_NOTES\n#else\n#ifndef BUTTONS_SEND_MIDI_NOTES\n      MIDI.sendControlChange(cc, value, chnl);\n#else\n      MIDI.sendNoteOff(cc, value, chnl);\n#endif //BUTTONS_SEND_MIDI_NOTES\n#endif //TEENSY\n#endif //SERIAL_DEBUG\n}\n", "line": 16, "slice": ["void midiSend(int cc, int value,int chnl){", "#ifndef BUTTONS_SEND_MIDI_NOTES", "      MIDI.sendControlChange(cc, value, chnl);", "#else", "      MIDI.sendNoteOff(cc, value, chnl);", "#endif //BUTTONS_SEND_MIDI_NOTES", "}"]}
{"code": "// Search pins usable for endstop-interrupts\n// Compile with the same build settings you'd use for Marlin.\n\n#if defined(ARDUINO_AVR_MEGA2560) || defined(ARDUINO_AVR_MEGA)\n    #undef  digitalPinToPCICR\n    #define digitalPinToPCICR(p)    ( ((p) >= 10 && (p) <= 15) || \\\n                                      ((p) >= 50 && (p) <= 53) || \\\n                                      ((p) >= 62 && (p) <= 69) ? &PCICR : nullptr)\n#endif\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"PINs causing interrupts are:\");\n  for (int i = 2; i < NUM_DIGITAL_PINS; i++) {\n    if (digitalPinToPCICR(i) || (int)digitalPinToInterrupt(i) != -1) {\n      for (int j = 0; j < NUM_ANALOG_INPUTS; j++) {\n        if (analogInputToDigitalPin(j) == i) {\n          Serial.print('A');\n          Serial.print(j);\n          Serial.print(\" = \");\n        }\n      }\n      Serial.print('D');\n      Serial.println(i);\n    }\n  }\n  Serial.println(\"Arduino pin numbering!\");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n}\n", "line": 18, "slice": ["#if defined(ARDUINO_AVR_MEGA2560) || defined(ARDUINO_AVR_MEGA)", "    #undef  digitalPinToPCICR", "    #define digitalPinToPCICR(p)    ( ((p) >= 10 && (p) <= 15) || \\", "                                      ((p) >= 50 && (p) <= 53) || \\", "                                      ((p) >= 62 && (p) <= 69) ? &PCICR : nullptr)", "#endif", "", "void setup() {", "  for (int i = 2; i < NUM_DIGITAL_PINS; i++) {", "    if (digitalPinToPCICR(i) || (int)digitalPinToInterrupt(i) != -1) {", "      for (int j = 0; j < NUM_ANALOG_INPUTS; j++) {", "        if (analogInputToDigitalPin(j) == i) {", "          Serial.print('A');", "          Serial.print(j);", "          Serial.print(\" = \");", "        }", "      }", "      Serial.print('D');", "      Serial.println(i);", "    }", "  }", "}"]}
{"code": "void showCircleClock(const DateTime& dt) {\n  memset(leds, 0,  NUM_LEDS * sizeof(struct CRGB));\n\n  uint8_t H = dt.hour();\n  uint8_t M = dt.minute();\n  uint8_t S = dt.second();\n\n  // we only want to show 12 of 24 hours ..\n  H += H < 12 ? 0 : -12;\n\n  float HourLED_1 = NUM_LEDS * (H + ((M + (S / 60.0)) / 60.0)) / 12.0;\n\n  // make a nice alignment of minutes and seconds\n  M += M < 58 ? 2 : -58;\n  S += S < 58 ? 2 : -58;\n\n  uint8_t MinuteLED = NUM_LEDS * M / 60;\n  uint8_t SecondLED = NUM_LEDS * S / 60;\n  \n  HourLED_1 += HourLED_1 >= 1 ? -1 : (NUM_LEDS-1); // shift 1 to the left\n  MinuteLED = MinuteLED > 0 ? MinuteLED - 1 : (NUM_LEDS-1); // shift 1 to the left\n  SecondLED = SecondLED > 0 ? SecondLED - 1 : (NUM_LEDS-1); // shift 1 to the left\n\n  uint8_t HourLED_2 = (int8_t)(HourLED_1 < (NUM_LEDS-1) ? HourLED_1 + 1 : HourLED_1 - (NUM_LEDS-1));\n\n#ifdef DEBUG\n  Serial.print(dt.hour()); Serial.print(\":\"); Serial.print(dt.minute()); Serial.print(\":\"); Serial.print(dt.second());  \n  Serial.print(\" => \"); Serial.print(\"(\");\n  Serial.print(HourLED_1); Serial.print(\", \"); Serial.print(HourLED_2); Serial.print(\")\");\n  Serial.print(\" : \"); Serial.print(MinuteLED); Serial.print(\" : \"); Serial.println(SecondLED);\n#endif\n\n  leds[(NUM_LEDS-1) - (uint8_t)(HourLED_1)].r = (uint8_t)(255 * (1 - (HourLED_1 - (uint8_t)HourLED_1)));\n  leds[(NUM_LEDS-1) - HourLED_2].r = (uint8_t)(255 * (HourLED_1 - (uint8_t)HourLED_1));\n  leds[(NUM_LEDS-1) - MinuteLED].g = 255;\n  leds[(NUM_LEDS-1) - SecondLED].b = S % 2 == 0 ? 255 : 128;\n  \n  LEDS.show();\n}\n\n", "line": 27, "slice": ["void showCircleClock(const DateTime& dt) {", "  uint8_t H = dt.hour();", "  uint8_t M = dt.minute();", "  uint8_t S = dt.second();", "", "  // we only want to show 12 of 24 hours ..", "  H += H < 12 ? 0 : -12;", "", "  float HourLED_1 = NUM_LEDS * (H + ((M + (S / 60.0)) / 60.0)) / 12.0;", "", "  HourLED_1 += HourLED_1 >= 1 ? -1 : (NUM_LEDS-1); // shift 1 to the left", "", "  uint8_t HourLED_2 = (int8_t)(HourLED_1 < (NUM_LEDS-1) ? HourLED_1 + 1 : HourLED_1 - (NUM_LEDS-1));", "", "  leds[(NUM_LEDS-1) - (uint8_t)(HourLED_1)].r = (uint8_t)(255 * (1 - (HourLED_1 - (uint8_t)HourLED_1)));", "  leds[(NUM_LEDS-1) - HourLED_2].r = (uint8_t)(255 * (HourLED_1 - (uint8_t)HourLED_1));", "}"]}
{"code": "#include <ADCTouchSensor.h>\n\n#ifdef ADCTOUCH_INTERNAL_GROUNDING\n# define GROUNDED_PIN -1\n#endif\n\n#if defined(ARDUINO_ARCH_AVR)\n# define PIN1 A0\n# define PIN2 A1\n#else\n# define PIN1 PA0\n# define PIN2 PA1\n# ifndef ADCTOUCH_INTERNAL_GROUNDING\n#  define GROUNDED_PIN PA3\n# endif\n#endif\n\nADCTouchSensor button0 = ADCTouchSensor(PIN1, GROUNDED_PIN); \nADCTouchSensor button1 = ADCTouchSensor(PIN2, GROUNDED_PIN);\n\nvoid setup() \n{\n    Serial.begin(9600);\n    \n    button0.begin();\n    button1.begin();        \n}\n\nvoid loop() \n{\n    int value0 = button0.read();   \n    int value1 = button1.read();   \n\n    Serial.print(value0 > 40);    //send (boolean) pressed or not pressed\n    Serial.print(\"\\t\");           //use if(value > threshold) to get the state of a button\n\n    Serial.print(value1 > 40);\n    Serial.print(\"\\t\\t\");\n\n    Serial.print(value0);             //send actual reading\n    Serial.print(\"\\t\");\n\t\n    Serial.println(value1);\n    delay(100);\n}\r\n", "line": 34, "slice": ["#include <ADCTouchSensor.h>", "", "#ifdef ADCTOUCH_INTERNAL_GROUNDING", "# define GROUNDED_PIN -1", "#endif", "", "#if defined(ARDUINO_ARCH_AVR)", "# define PIN1 A0", "# define PIN2 A1", "#else", "# define PIN1 PA0", "# define PIN2 PA1", "# ifndef ADCTOUCH_INTERNAL_GROUNDING", "#  define GROUNDED_PIN PA3", "# endif", "#endif", "", "ADCTouchSensor button0 = ADCTouchSensor(PIN1, GROUNDED_PIN); ", "ADCTouchSensor button1 = ADCTouchSensor(PIN2, GROUNDED_PIN);", "", "void setup() ", "{", "    button0.begin();", "    button1.begin();        ", "}", "", "void loop() ", "{", "    int value0 = button0.read();   ", "", "    Serial.print(value0);             ", "}"]}
{"code": " /*!\n  * file SPIReadTemperature.ino\n  * \n  * Connect BMP388 to SPI interface of Arduino and connect CSB pin to pin3 of Arduino,\n  * download the program.\n  *\n  * @n Open serial monitor, the temperature could be checked. \n  *\n  * Copyright   [DFRobot](http://www.dfrobot.com), 2016\n  * Copyright   GNU Lesser General Public License\n  *\n  * version  V0.1\n  * date  2018-5-29\n  */\n#include \"DFRobot_BMP388.h\"\n#include \"DFRobot_BMP388_SPI.h\"\n#include \"SPI.h\"\n#include \"Wire.h\"\n#include \"bmp3_defs.h\"\n\n/*select CS pin*/\n#ifdef __AVR__\nint cs = 3;\n#elif (defined ESP_PLATFORM)||(defined __ets__)\nint cs = D3;\n#else\n  #error unknow board\n#endif\n/*Create a bmp388 object of SPI interface and the SPI chip selection pin is 3*/\nDFRobot_BMP388_SPI bmp388(cs);\n\nvoid setup(){\n  /*Initialize the serial port*/\n  Serial.begin(9600);\n  /*Initialize bmp388*/\n  while(bmp388.begin()){\n    Serial.println(\"Initialize error!\");\n    delay(1000);\n  }\n}\n\nvoid loop(){\n  /*Read the temperature, print data via serial port*/\n  float Temperature = bmp388.readTemperature();\n  Serial.print(\"Temperature : \");\n  Serial.print(Temperature);\n  Serial.println(\" C\");\n  delay(100);\n}", "line": 45, "slice": ["#include \"DFRobot_BMP388_SPI.h\"", "int cs = 3;", "DFRobot_BMP388_SPI bmp388(cs);", "void setup(){", "  while(bmp388.begin()){", "    delay(1000);", "  }", "}", "void loop(){", "  float Temperature = bmp388.readTemperature();", "  Serial.print(Temperature);", "  delay(100);", "}"]}
{"code": "/***\n\tUncomment the #define below to use a standard bool array rather than a BitBool.\n***/\n\n//#define USE_STANDARD_BOOL\n#define MAX_ITEMS 100\n \n#include <BitBool.h>\n \n#ifdef USE_STANDARD_BOOL\n  bool b_Array[ MAX_ITEMS ] = { true, true, true };\n#else\n  BitBool< MAX_ITEMS > b_Array = { B00000111 };\n#endif\n \nvoid setup() { Serial.begin(9600); }\n \nvoid loop(){\n    bool b_TempCopy = b_Array[ MAX_ITEMS - 1 ];\n     \n    //Roll items up.\n    for( int i_Index = MAX_ITEMS - 1 ; i_Index ; --i_Index )\n      b_Array[ i_Index ] = b_Array[ i_Index - 1 ];\n    b_Array[ 0 ] = b_TempCopy;\n     \n    //Show contents.\n    Serial.print('[');\n    for( int i_Index = 0 ; i_Index < MAX_ITEMS ; ++i_Index ) \n      Serial.print( b_Array[ i_Index ] ? '#' : '-' );\n    Serial.print(\"]\\r\\n\");\n  }", "line": 27, "slice": ["#define MAX_ITEMS 100", "BitBool< MAX_ITEMS > b_Array = { B00000111 };", "void loop(){", "    bool b_TempCopy = b_Array[ MAX_ITEMS - 1 ];", "    for( int i_Index = MAX_ITEMS - 1 ; i_Index ; --i_Index )", "      b_Array[ i_Index ] = b_Array[ i_Index - 1 ];", "    b_Array[ 0 ] = b_TempCopy;", "    for( int i_Index = 0 ; i_Index < MAX_ITEMS ; ++i_Index ) ", "      Serial.print( b_Array[ i_Index ] ? '#' : '-' );", "  }"]}
{"code": "#include <MIDI.h>\n\n#if defined(USBCON)\n#include <midi_UsbTransport.h>\n\nstatic const unsigned sUsbTransportBufferSize = 16;\ntypedef midi::UsbTransport<sUsbTransportBufferSize> UsbTransport;\n\nUsbTransport sUsbTransport;\n\nMIDI_CREATE_INSTANCE(UsbTransport, sUsbTransport, MIDI);\n\n#else // No USB available, fallback to Serial\nMIDI_CREATE_DEFAULT_INSTANCE();\n#endif\n\n// --\n\nvoid handleNoteOn(byte inChannel, byte inNumber, byte inVelocity)\n{\n    Serial.print(\"NoteOn  \");\n    Serial.print(inNumber);\n    Serial.print(\"\\tvelocity: \");\n    Serial.println(inVelocity);\n}\nvoid handleNoteOff(byte inChannel, byte inNumber, byte inVelocity)\n{\n    Serial.print(\"NoteOff \");\n    Serial.print(inNumber);\n    Serial.print(\"\\tvelocity: \");\n    Serial.println(inVelocity);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial);\n    MIDI.begin();\n    MIDI.setHandleNoteOn(handleNoteOn);\n    MIDI.setHandleNoteOff(handleNoteOff);\n    Serial.println(\"Arduino ready.\");\n}\n\nvoid loop() {\n    MIDI.read();\n}\n", "line": 21, "slice": ["#include <MIDI.h>", "", "void handleNoteOff(byte inChannel, byte inNumber, byte inVelocity)", "{", "    Serial.print(\"NoteOff \");", "    Serial.print(inNumber);", "    Serial.print(\"\\tvelocity: \");", "    Serial.println(inVelocity);", "}", "", "void setup() {", "    Serial.begin(115200);", "    while (!Serial);", "    MIDI.begin();", "    MIDI.setHandleNoteOff(handleNoteOff);", "    Serial.println(\"Arduino ready.\");", "}", "", "void loop() {", "    MIDI.read();", "}"]}
{"code": "/*\n Modified Blue Robotics TSYS01 Library Example to run on Feather M0\n\nUses the 24bit TSYS01 Temperature Sensor on I2C to do a simple read test\n\n Created by:  Jonathan Davies\n Date:        16/07/18\n Version:     0.1\n*/\n\n\n#include <Wire.h>\n#include \"TSYS01.h\"\n\n#ifdef ARDUINO_SAMD_ZERO\n   #define Serial SerialUSB   // re-defines USB serial from M0 chip so it appears as regular serial\n#endif\n\nTSYS01 sensor;\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Starting\");\n  Wire.begin();\n  sensor.init();\n}\n\nvoid loop() {\n  sensor.read();\n  Serial.print(\"Temperature: \");\n  Serial.print(sensor.temperature()); \n  Serial.println(\" deg C\");\n  delay(1000);\n}\n", "line": 30, "slice": ["#include <Wire.h>", "#include \"TSYS01.h\"", "", "#ifdef ARDUINO_SAMD_ZERO", "   #define Serial SerialUSB   ", "#endif", "", "TSYS01 sensor;", "", "void setup() {", "  Serial.begin(9600);", "  Wire.begin();", "  sensor.init();", "}", "", "void loop() {", "  sensor.read();", "  Serial.print(\"Temperature: \");", "  Serial.print(sensor.temperature()); ", "}"]}
{"code": "#include <Arduboy2.h>\n\n#ifdef CREDITS\n\nvoid credits_Init() {\n\n    gameState = GameState::Credits;\n    tvSequenceVars.counter = 0;\n\n}   \n\nvoid credits() {\n\n    Sprites::drawOverwrite(5, 12, Images::Title_02, 0);\n    flickering(12);\n    \n    if (arduboy.isFrameCount(4)) tvSequenceVars.counter++;\n    if (tvSequenceVars.counter >= 200) tvSequenceVars.counter = 0;\n\n    Sprites::drawOverwrite(13, 43, Images::LeftFade2, 0);\n    Sprites::drawOverwrite(107, 43, Images::RightFade, 0);\n\n    arduboy.drawFastHLine(18, 43, 89);\n    arduboy.drawFastHLine(18, 51, 89);\n    \n    switch (tvSequenceVars.counter % 40) {\n\n        case 0 ... 32:\n            font3x5.setCursor(20, 44);\n            print(font3x5, 137 + tvSequenceVars.counter / 40);\n            break;\n\n        default:\n            break;\n    }\n\n    if (arduboy.justPressed(A_BUTTON)) { \n\n        gameState = GameState::Title_Init;\n\n    }\n\n}\n#endif", "line": 30, "slice": ["void credits() {", "", "    if (arduboy.isFrameCount(4)) tvSequenceVars.counter++;", "    if (tvSequenceVars.counter >= 200) tvSequenceVars.counter = 0;", "", "    switch (tvSequenceVars.counter % 40) {", "", "        case 0 ... 32:", "            font3x5.setCursor(20, 44);", "            print(font3x5, 137 + tvSequenceVars.counter / 40);", "            break;", "", "        default:", "            break;", "    }", "", "    if (arduboy.justPressed(A_BUTTON)) { ", "", "        gameState = GameState::Title_Init;", "", "    }", "", "}"]}
{"code": "#include <Arduino.h>\n\n#define DEBUG_SERIAL\n\n\n// tasks handles\nTaskHandle_t task0_handle = NULL;\nTaskHandle_t task1_handle;\n\n\n// variables accessible in the two task loops\nbool task0_running = true;\n\n\ntemplate <typename T>\nPrint& operator<<(Print& printer, T value)\n{\n    printer.print(value);\n    return printer;\n}\n\n\n\nvoid setup() {\n  btStop();\n  pinMode(2,OUTPUT);// led\n  digitalWrite(2, HIGH);\n\n  // one loop task on each core.\n  xTaskCreatePinnedToCore(run_task0, \"Task0\", 8192, NULL, 1, &task0_handle, 0);\n  xTaskCreatePinnedToCore(run_task1, \"Task1\", 8192, NULL, 1, &task1_handle, 1);\n  vTaskDelete( NULL );\n}\n\nvoid loop() {\n#ifdef DEBUG_SERIAL\n  Serial.println(\"inLoop\");\n#endif\n}\n", "line": 18, "slice": ["#include <Arduino.h>", "", "TaskHandle_t task0_handle = NULL;", "", "bool task0_running = true;", "", "void setup() {", "  xTaskCreatePinnedToCore(run_task0, \"Task0\", 8192, NULL, 1, &task0_handle, 0);", "}"]}
{"code": "#ifdef DL\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  iAm = \"ducklink\";\n  setupDuck();\n\n  setupDisplay();\n  setupLoRa();\n  setupPortal();\n\n  Serial.println(\"Ducklink Online\");\n  u8x8.drawString(0, 1, \"Ducklink Online\");\n}\n\nvoid loop()\n{\n  // \u26a0\ufe0f Parses Civilian Requests into Data Structure\n  readData();\n  if (offline.fromCiv == 1 && offline.fname != NULL && offline.fname != \"\")\n  {\n    Serial.println(\"Start send from DuckLink\");\n    sendPayload(offline);\n    //showReceivedData();\n    offline = empty;\n    setupDuck();\n  }\n  else\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  // Sends Duck Stat every 30 minutes\n  sendDuckStat(offline);\n}\n#endif\n", "line": 33, "slice": ["void setup()", "{", "  Serial.begin(115200);", "", "  iAm = \"ducklink\";", "  setupDuck();", "}", "", "void loop()", "{", "  readData();", "  if (offline.fromCiv == 1 && offline.fname != NULL && offline.fname != \"\")", "  {", "    sendPayload(offline);", "    offline = empty;", "    setupDuck();", "  }", "  sendDuckStat(offline);", "}"]}
{"code": "/*\n * Arduino Pro Micro receiving data via\n * XLC-RF-5V reciever.\n * Program must run i a loop, so no delays or putting the uC into\n * any power saving mode is possible.\n*/\n\n#include <RH_ASK.h> // https://www.airspayce.com/mikem/arduino/RadioHead/\n#ifdef RH_HAVE_HARDWARE_SPI\n#include <SPI.h> // Not actually used but needed to compile\n#endif\n\n#define RADIO 2 // Arduinio Pro Micro digital pin for XLC-RF-5V data\n#define SPEED 1200 // ASK speed\n\n// one way, pins 3 and 4 are unused\nRH_ASK driver(SPEED,RADIO,3,4);\n\nvoid setup()\n{\n    Serial.begin(9600);\n    driver.init();\n}\n\nvoid loop()\n{\n  // buffer for message, max lengt same as on the transmitter's side\n  uint8_t msg[32];\n  uint8_t len;\n  if (driver.recv(msg, &len))\n  {\n    short i;\n    for (i=0; i<len; i++)\n      Serial.print( char(msg[i]) );\n    Serial.println();     \n  }\n}\n", "line": 34, "slice": ["#define RADIO 2 // Arduinio Pro Micro digital pin for XLC-RF-5V data", "#define SPEED 1200 // ASK speed", "", "RH_ASK driver(SPEED,RADIO,3,4);", "", "void setup()", "{", "    Serial.begin(9600);", "    driver.init();", "}", "", "void loop()", "{", "  uint8_t msg[32];", "  uint8_t len;", "  if (driver.recv(msg, &len))", "  {", "    short i;", "    for (i=0; i<len; i++)", "      Serial.print( char(msg[i]) );", "    Serial.println();     ", "  }", "}"]}
{"code": "/*\n * Name: irdetect.ino\n * Description: IR (Flame) detector\n * Note: The use of an analog read of an analog pin will require a deylay of\n *       at least 1 milli-second between analog reads.\n * */\n#define BAUD 9600\n\nconst uint8_t DIG_IR_DETECT = 4;\nconst uint8_t LOG_IR_DETECT = A0;\n\nuint32_t ledClk = millis();\nconst uint32_t ledPer = 1000;\n\nvoid setup()\n{\n#ifdef BAUD\n  Serial.begin(BAUD);\n#endif\n\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\nvoid loop()\n{\n  uint16_t digIr = digitalRead(DIG_IR_DETECT);\n  uint16_t logIr = analogRead(LOG_IR_DETECT);\n\n#ifdef BAUD\n  Serial.print(digIr);\n  Serial.print(\" : \");\n  Serial.println(logIr);\n#endif\n\n  flashLed(millis(), &ledClk, ledPer, LED_BUILTIN);\n  delay(1);\n}\n\nvoid flashLed(uint32_t ms, uint32_t *clk, uint32_t per, uint8_t pin)\n{\n  if (ms - *clk >= per)\n  {\n    digitalWrite(pin, !digitalRead(pin));\n    *clk = ms;\n  }\n}\n", "line": 30, "slice": ["#define BAUD 9600", "const uint8_t DIG_IR_DETECT = 4;", "const uint8_t LOG_IR_DETECT = A0;", "uint32_t ledClk = millis();", "const uint32_t ledPer = 1000;", "void setup()", "{", "#ifdef BAUD", "  Serial.begin(BAUD);", "#endif", "  pinMode(LED_BUILTIN, OUTPUT);", "}", "void loop()", "{", "  uint16_t digIr = digitalRead(DIG_IR_DETECT);", "  uint16_t logIr = analogRead(LOG_IR_DETECT);", "#ifdef BAUD", "  Serial.print(digIr);", "  Serial.print(\" : \");", "  Serial.println(logIr);", "#endif", "  flashLed(millis(), &ledClk, ledPer, LED_BUILTIN);", "  delay(1);", "}", "void flashLed(uint32_t ms, uint32_t *clk, uint32_t per, uint8_t pin)", "{", "  if (ms - *clk >= per)", "  {", "    digitalWrite(pin, !digitalRead(pin));", "    *clk = ms;", "  }", "}"]}
{"code": "/********************************************************************************\nThis code is automatically generated by the VerticalThings compiler. DO NOT EDIT!\n********************************************************************************/\n/*Managed memory variables*/\nuint32_t __vtmem[0];\n/*End of managed memory variables*/\n/*Module vars for print_action2*/\nint print_action2_voteResult;\n/*End of module vars for print_action2*/\ntypedef enum { __print_action2_print}  __pipeline;\n __pipeline __state = __print_action2_print;\nvoid _print_action2_print(int print_action2_print_v)\n{\n    {\n        if((print_action2_voteResult==3))\n        {\n            print_action2_voteResult=5;\n        }\n    }\n}\nvoid loop()\n{\n    switch(__state)\n    {\n        case __print_action2_print:\n        __state = __print_action2_print;\n        _print_action2_print();\n        break;\n        default :\n        __state = __print_action2_print;\n    }\n}\nvoid setup()\n{\n}", "line": 12, "slice": ["int print_action2_voteResult;"]}
{"code": "// 1-channel LoRa Gateway for ESP8266\n// Copyright (c) 2016-2020 Maarten Westenberg\n//\n// All rights reserved. This program and the accompanying materials\n// are made available under the terms of the MIT License\n// which accompanies this distribution, and is available at\n// https://opensource.org/licenses/mit-license.php\n//\n// NO WARRANTY OF ANY KIND IS PROVIDED\n//\n// Author: Maarten Westenberg (mw12554@hotmail.com)\n//\n// This file contains code for using the single channel gateway also as a repeater node. \n// Please note that for node to node communication your should change the polarity\n// of messages.\n//\n// ============================================================================\n\t\t\n#if _REPEATER==1\n\n// Define input channel and output channel\n#define _ICHAN 0\n#define _OCHAN 1\n\n#ifdef _TTNSERVER\n#error \"Please undefined _THINGSERVER, for REPEATER shutdown WiFi\"\n#endif\n\n// Send a LoRa message out from the gateway transmitter\n// XXX Maybe we should block the received ontul the message is transmitter\n\nint sendLora(char *msg, int len) {\n\t// Check when len is not exceeding maximum length\n\tSerial.print(\"sendLora:: \");\n\t\n\tfor (int i=0; i< len; i++) {\n\t\tSerial.print(msg[1],HEX);\n\t\tSerial.print('.');\n\t}\n\t\n\tif (debug>=2) Serial.flush();\n\treturn(1);\n}\n\n#endif //_REPEATER==1", "line": 34, "slice": ["#if _REPEATER==1", "#define _ICHAN 0", "#define _OCHAN 1", "int sendLora(char *msg, int len) {", "\tfor (int i=0; i< len; i++) {", "\t\tSerial.print(msg[1],HEX);", "\t\tSerial.print('.');", "\t}", "\tif (debug>=2) Serial.flush();", "\treturn(1);", "}", "#endif //_REPEATER==1"]}
{"code": "#include <WiFi.h>\n\n//#define USE_WIFI\n\n#define WIFI_SSID \"Keren1978\"\n#define WIFI_PASSWORD \"Keren1978\"\n//#define WIFI_SSID \"sababa\"\n//#define WIFI_PASSWORD \"sababababasis\"\n\nvoid setup() {\n  Serial.begin(115200);\n#ifdef USE_WIFI\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);\n  }\n#endif\n}\n\nint pin = 2;\n\nvoid loop() {\n  if (Serial.available()) {\n    pin = Serial.parseInt();\n    pinMode(pin, INPUT);\n  }\n  Serial.println(digitalRead(pin)); \n  delay(10);\n}\n", "line": 14, "slice": ["#include <WiFi.h>", "", "int pin = 2;", "", "void loop() {", "  if (Serial.available()) {", "    pin = Serial.parseInt();", "    pinMode(pin, INPUT);", "  }", "  Serial.println(digitalRead(pin)); ", "  delay(10);", "}"]}
{"code": "//Write wickerMan zero data to EEPROM\n\n#include <EEPROM.h>\n\nuint8_t sysID=1;\n\nvoid setup () \n{\n\n#ifndef ESP8266\n  while (!Serial); // for Leonardo/Micro/Zero\n#endif\n\nSerial.begin(115200);\n\nEEPROM.begin(512);\n\n\nSerial.println();\nSerial.println(\"Write zeroed data to  to EEPROM:\");\nEEPROM.write (0, sysID); \n\n\n\nfor (int i=1; i<61; i++){\n\nEEPROM.write (i,0);\n\n}\nEEPROM.commit();\nSerial.println(\"Zero Written to EEPROM Positions 1 to 60\");\nSerial.println(\"Reading test data from EEPROM\");\n\t\n\t\nSerial.print(\"sysID: \");\nSerial.println (EEPROM.read(0));\n\t\nfor (int i=1; i<61; i++){\nSerial.print(\"Pos \");\n\tSerial.print(i);\n\tSerial.print(\": \"); \nSerial.println (EEPROM.read(i));\n\n}\n}\nvoid loop () {\n\n}\n", "line": 35, "slice": ["#include <EEPROM.h>", "", "uint8_t sysID=1;", "", "void setup () ", "{", "", "EEPROM.begin(512);", "", "EEPROM.write (0, sysID); ", "", "for (int i=1; i<61; i++){", "", "EEPROM.write (i,0);", "", "}", "EEPROM.commit();", "", "for (int i=1; i<61; i++){", "Serial.println (EEPROM.read(i));", "", "}", "}"]}
{"code": "#include <IRLibRecvPCI.h>\n\nIRrecvPCI myReceiver(5);  // Arduino ZERO pin 5\n\n#define DEBUG 1\n\nvoid setup() {\n  #ifdef DEBUG\n    SerialUSB.begin(9600);\n    while (!SerialUSB) {}\n\n    SerialUSB.println(\"Ready to receive IR signals\");\n    SerialUSB.println(\"Point the remote controller to the IR receiver and press!\");\n  #endif\n\n  myReceiver.enableIRIn();\n}\n\nvoid loop() {\n  if (myReceiver.getResults()) {\n    #ifdef DEBUG\n      if (recvGlobal.recvLength > 100) {\n        SerialUSB.print(\"Received IR signal length: \");\n        SerialUSB.println(recvGlobal.recvLength, DEC);\n      }\n    #endif\n\n    myReceiver.enableIRIn();\n  }\n}\n", "line": 23, "slice": ["#include <IRLibRecvPCI.h>", "", "IRrecvPCI myReceiver(5);  // Arduino ZERO pin 5", "", "void setup() {", "  myReceiver.enableIRIn();", "}", "", "void loop() {", "  if (myReceiver.getResults()) {", "    myReceiver.enableIRIn();", "  }", "}"]}
{"code": "#ifdef ESP8266\nextern \"C\" {\n#include \"user_interface.h\"\n}\n#endif\n\n#include <ESP8266WiFi.h>\n#include <WiFiClientSecure.h>\n\n#include <komaino-config.h>\n\nADC_MODE(ADC_VCC);\n\nWiFiClientSecure client;\n\nconst char* host = \"www.d-line.net\";\nString url = \"/api/test\";\n\nvoid setup() {\n  komaino.wifiSta(ssid, pass);\n  komaino.print(komaino.wifiIP());\n  String data = \"text=Hello ESP8266!&bat=\" + ESP.getVcc();\n  komaino.print(httpsPost(url, data));\n}\n\nvoid loop() {\n\n}\n\nString httpsPost(String url, String data) {\n  if (client.connect(host, 443)) {\n    client.println(\"POST \" + url + \" HTTP/1.1\");\n    client.println(\"Host: \" + (String)host);\n    client.println(\"User-Agent: ESP8266/1.0\");\n    client.println(\"Connection: close\");\n    client.println(\"Content-Type: application/x-www-form-urlencoded;\");\n    client.print(\"Content-Length: \");\n    client.println(data.length());\n    client.println();\n    client.println(data);\n    delay(10);\n    String response = client.readString();\n    int bodypos =  response.indexOf(\"\\r\\n\\r\\n\") + 4;\n    return response.substring(bodypos);\n  }\n  else {\n    return \"ERROR\";\n  }\n}\n", "line": 21, "slice": ["#include <ESP8266WiFi.h>", "#include <WiFiClientSecure.h>", "", "WiFiClientSecure client;", "", "const char* host = \"www.d-line.net\";", "String url = \"/api/test\";", "", "void setup() {", "  String data = \"text=Hello ESP8266!&bat=\" + ESP.getVcc();", "  komaino.print(httpsPost(url, data));", "}", "", "String httpsPost(String url, String data) {", "  if (client.connect(host, 443)) {", "    client.println(\"POST \" + url + \" HTTP/1.1\");", "    client.println(\"Host: \" + (String)host);", "    client.println(\"User-Agent: ESP8266/1.0\");", "    client.println(\"Connection: close\");", "    client.println(\"Content-Type: application/x-www-form-urlencoded;\");", "    client.print(\"Content-Length: \");", "    client.println(data.length());", "    client.println();", "    client.println(data);", "    delay(10);", "    String response = client.readString();", "    int bodypos =  response.indexOf(\"\\r\\n\\r\\n\") + 4;", "    return response.substring(bodypos);", "  }", "  else {", "    return \"ERROR\";", "  }", "}"]}
{"code": "#include \"RingEEPROM.h\"\n#define FIRST_ADDR 0\n#define BUFFER_SIZE 4\n#define PARAM_PACKET_SIZE 6\n\ntypedef struct sensor_t\n{\n  float temp;\n  float volt;\n};\nsensor_t sensorWrite,sensorRead;\n\nbyte writeBuffer[PARAM_PACKET_SIZE];\nbyte readBuffer[PARAM_PACKET_SIZE];\n\nRingEEPROM myeepRom(FIRST_ADDR, BUFFER_SIZE, sizeof(sensor_t));\n\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"Setup Done\");\n}\n\nvoid loop()\n{\n  Serial.println(F(\"---------------------------------------\"));\n  myeepRom.printStatusBuf();//Ovserve the inititial state of status buffer\n\n  measureSensor();//populat sensor data in Sensor structure\n  //uint8_t \n  myeepRom.savePacket((byte*)&sensorWrite); //Saving data array into eeprom\n  Serial.print(F(\"Param Saved Addr : \")); Serial.println(myeepRom.getParamPtr());\n  myeepRom.printStatusBuf();//Ovserve the status buffer after writing a data packet\n\n  myeepRom.readPacket((byte*)&sensorRead);//Read the last saved data packet\n  //Print Saved array. match the generated random array and read data array.\n  Serial.print(F(\"Saved  Temp & Volt : \"));\n  Serial.print(sensorRead.temp);Serial.print(\" & \");Serial.println(sensorRead.volt);\n\n  delay(5000);\n}\n\nvoid measureSensor()\n{\n  Serial.print(F(\"Measured Temp & Volt : \"));\n  sensorWrite.temp = random(30,40);\n  sensorWrite.volt = random(8,14);\n  Serial.print(sensorWrite.temp);Serial.print(\" & \");Serial.println(sensorWrite.volt);\n}\n\n", "line": 32, "slice": ["#include \"RingEEPROM.h\"", "#define FIRST_ADDR 0", "#define BUFFER_SIZE 4", "#define PARAM_PACKET_SIZE 6", "", "typedef struct sensor_t", "{", "  float temp;", "  float volt;", "};", "sensor_t sensorWrite,sensorRead;", "", "byte writeBuffer[PARAM_PACKET_SIZE];", "byte readBuffer[PARAM_PACKET_SIZE];", "", "RingEEPROM myeepRom(FIRST_ADDR, BUFFER_SIZE, sizeof(sensor_t));", "", "void loop()", "{", "  myeepRom.savePacket((byte*)&sensorWrite); //Saving data array into eeprom", "  myeepRom.readPacket((byte*)&sensorRead);//Read the last saved data packet", "  Serial.print(sensorRead.temp);Serial.print(\" & \");Serial.println(sensorRead.volt);", "}", "", "void measureSensor()", "{", "  sensorWrite.temp = random(30,40);", "  sensorWrite.volt = random(8,14);", "}"]}
{"code": "#include <stdarg.h>\nvoid p(const char *fmt, ... ){\n  char buf[128]; // resulting string limited to 128 chars\n  va_list args;\n  va_start (args, fmt );\n  vsnprintf(buf, sizeof(buf), fmt, args);\n  va_end (args);\n  Serial.print(buf);\n}\n\nvoid fp(HardwareSerial& serial, const char *fmt, ... ){\n  char buf[128]; // resulting string limited to 128 chars\n  va_list args;\n  va_start (args, fmt );\n  vsnprintf(buf, sizeof(buf), fmt, args);\n  va_end (args);\n  serial.print(buf);\n}\n\n/** Sample use: p(F(\"Best to store long strings to flash to save %s\"),\"memory\"); */\nvoid p(const __FlashStringHelper *fmt, ... ){\n  char buf[128]; // resulting string limited to 128 chars\n  va_list args;\n  va_start (args, fmt);\n#ifdef __AVR__\n  vsnprintf_P(buf, sizeof(buf), (const char *)fmt, args); // progmem for AVR\n#else\n  vsnprintf(buf, sizeof(buf), (const char *)fmt, args); // for the rest of the world\n#endif\n  va_end(args);\n  Serial.print(buf);\n}\n\nvoid fp(HardwareSerial& serial, const __FlashStringHelper *fmt, ... ){\n  char buf[128]; // resulting string limited to 128 chars\n  va_list args;\n  va_start (args, fmt);\n#ifdef __AVR__\n  vsnprintf_P(buf, sizeof(buf), (const char *)fmt, args); // progmem for AVR\n#else\n  vsnprintf(buf, sizeof(buf), (const char *)fmt, args); // for the rest of the world\n#endif\n  va_end(args);\n  serial.print(buf);\n}\n\n", "line": 8, "slice": ["#include <stdarg.h>", "void p(const char *fmt, ... ){", "  char buf[128]; // resulting string limited to 128 chars", "  va_list args;", "  va_start (args, fmt );", "  vsnprintf(buf, sizeof(buf), fmt, args);", "  va_end (args);", "  Serial.print(buf);", "}", "", "void p(const __FlashStringHelper *fmt, ... ){", "  char buf[128]; // resulting string limited to 128 chars", "  va_list args;", "  va_start (args, fmt);", "#ifdef __AVR__", "  vsnprintf_P(buf, sizeof(buf), (const char *)fmt, args); // progmem for AVR", "#else", "  vsnprintf(buf, sizeof(buf), (const char *)fmt, args); // for the rest of the world", "#endif", "  va_end(args);", "  Serial.print(buf);", "}"]}
{"code": "#include \"mh_z14a.h\"\r\n\r\n#ifdef ESP32\r\nHardwareSerial port(2); // RX2 16, TX2 17 on ESP32\r\n#else\r\n#include <\"SoftwareSerial.h>\r\nSoftwareSerial port(2, 3); //RX & TX\r\n#endif\r\n\r\n\r\n\r\nMH_Z14A sensor;\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  sensor.begin(&port);\r\n}\r\n\r\nvoid loop() {\r\n  uint32_t ppm;\r\n  uint8_t err = sensor.read(&ppm);\r\n\r\n  if(err) {\r\n    Serial.print(\"Error code: \");\r\n    Serial.println(err);\r\n  }\r\n  \r\n    Serial.print(\"CO2 ppm: \");\r\n    Serial.println(ppm);\r\n  \r\n  delay(5000);\r\n}\r\n", "line": 24, "slice": ["#include \"mh_z14a.h\"", "MH_Z14A sensor;", "void setup() {", "  sensor.begin(&port);", "}", "void loop() {", "  uint32_t ppm;", "  uint8_t err = sensor.read(&ppm);", "  Serial.println(ppm);", "}"]}
{"code": "// Polls a number of \"pollee\" nodes as fast as possible to get data from them.\n// 2011-11-23 <jcw@equi4.com> http://opensource.org/licenses/mit-license.php\n//\n// Warning: this test will flood the radio band so nothing else gets through!\n//\n// Maximum rates will only be achieved if all nodes 1 .. NUM_NODES are powered\n// up, properly configured, and pre-loaded with the pollee.ino sketch.\n\n#include <JeeLib.h>\n\nconst byte NUM_NODES = 3; // poll using node ID from 1 to NUM_NODES \n\ntypedef struct {\n  byte node;\n  long time;\n} Payload;\n\nbyte nextId;\nMilliTimer timer;\n\nvoid setup () {\n  Serial.begin(57600);\n  Serial.println(\"\\n[poller]\");\n  rf12_initialize(1, RF12_868MHZ, 77);\n}\n\nvoid loop () {\n  // switch to next node\n  if (++nextId > NUM_NODES)\n    nextId = 1;\n  // wait until we can send a packet\n  while (!rf12_canSend())\n    rf12_recvDone();\n  // send an empty packet to one specific pollee\n  rf12_sendStart(RF12_HDR_ACK | RF12_HDR_DST | nextId, 0, 0);\n  // wait up to 10 milliseconds for a reply\n  timer.set(10);\n  while (!timer.poll())\n    if (rf12_recvDone() && rf12_crc == 0 && rf12_len == sizeof (Payload)) {\n      // got a good ACK packet, print out its contents\n      const Payload* p = (const Payload*) rf12_data;\n      Serial.print((word) p->node);\n      Serial.print(\": \");\n      Serial.println(p->time);\n      break;\n    }\n}\n", "line": 42, "slice": ["const byte NUM_NODES = 3; // poll using node ID from 1 to NUM_NODES ", "", "byte nextId;", "MilliTimer timer;", "", "void loop () {", "  // switch to next node", "  if (++nextId > NUM_NODES)", "    nextId = 1;", "  // wait until we can send a packet", "  while (!rf12_canSend())", "    rf12_recvDone();", "  // send an empty packet to one specific pollee", "  rf12_sendStart(RF12_HDR_ACK | RF12_HDR_DST | nextId, 0, 0);", "  // wait up to 10 milliseconds for a reply", "  timer.set(10);", "  while (!timer.poll())", "    if (rf12_recvDone() && rf12_crc == 0 && rf12_len == sizeof (Payload)) {", "      // got a good ACK packet, print out its contents", "      const Payload* p = (const Payload*) rf12_data;", "      Serial.print((word) p->node);", "      Serial.print(\": \");", "      Serial.println(p->time);", "      break;", "    }", "}"]}
{"code": "void mpucheck() {\n  // read raw accel/gyro measurements from device\n  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n  // these methods (and a few others) are also available\n  //mpu.getAcceleration(&ax, &ay, &az);\n  //mpu.getRotation(&gx, &gy, &gz);\n\n#ifdef OUTPUT_READABLE_mpu\n  // display tab-separated accel/gyro x/y/z values\n  Serial.print(F(\"a/g:\\t\"));\n  Serial.print(ax); \n  Serial.print(F(\"\\t\"));\n  Serial.print(ay); \n  Serial.print(F(\"\\t\"));\n  Serial.print(az); \n  Serial.print(F(\"\\t\"));\n  Serial.print(gx); \n  Serial.print(F(\"\\t\"));\n  Serial.print(gy); \n  Serial.print(F(\"\\t\"));\n  Serial.print(gz); \n  Serial.print(F(\"\\t\"));\n  double dT = ( (double) mpu.getTemperature() + 12412.0) / 340.0;\n  Serial.print(dT, 3);\n  Serial.print(F(\"C \\t\"));\n  Serial.println();\n#endif\n\n#ifdef OUTPUT_BINARY_mpu\n  Serial.write((uint8_t)(ax >> 8)); \n  Serial.write((uint8_t)(ax & 0xFF));\n  Serial.write((uint8_t)(ay >> 8)); \n  Serial.write((uint8_t)(ay & 0xFF));\n  Serial.write((uint8_t)(az >> 8)); \n  Serial.write((uint8_t)(az & 0xFF));\n  Serial.write((uint8_t)(gx >> 8)); \n  Serial.write((uint8_t)(gx & 0xFF));\n  Serial.write((uint8_t)(gy >> 8)); \n  Serial.write((uint8_t)(gy & 0xFF));\n  Serial.write((uint8_t)(gz >> 8)); \n  Serial.write((uint8_t)(gz & 0xFF));\n#endif\n}\n", "line": 10, "slice": ["void mpucheck() {", "  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);", "  double dT = ( (double) mpu.getTemperature() + 12412.0) / 340.0;", "}"]}
{"code": "//#define DEBUG_FLAG;\n\nint led = 13;\n\nvoid setup() {\n  // init the digital pin as an output\n  pinMode(led, OUTPUT);\n#ifdef DEBUG_FLAG\n  // init serial\n  Serial.begin(9600);\n  while (!Serial); // wait until Serial is ready\n  Serial.println(\"Welcome, Huy\");\n#endif\n}\n\nvoid blink() {\n  digitalWrite(led, HIGH);\n  delay(1000);\n  digitalWrite(led, LOW);\n  delay(1000);\n}\n\nvoid loop() {\n  // get moisture value\n  int val = analogRead(A1);\n#ifdef DEBUG_FLAG;\n  Serial.print(\"moisture value: \");\n  Serial.println(val);\n#endif\n  // if below 800, need water\n  if (val < 800) {\n#ifdef DEBUG_FLAG\n    // output feed me\n    Serial.println(\"I'M HUNGRY! FEED MEEEE!!! >\\\"<\");\n#endif\n    // blink the led\n    blink();\n  } else {\n#ifdef DEBUG_FLAG\n    // output I'm good\n    Serial.println(\"I'M GOOD!!! ( ^ __ ^ )\");\n#endif\n    delay(1000);\n  }\n}\n\n", "line": 27, "slice": ["int led = 13;", "", "void setup() {", "  pinMode(led, OUTPUT);", "}", "", "void blink() {", "  digitalWrite(led, HIGH);", "  delay(1000);", "  digitalWrite(led, LOW);", "  delay(1000);", "}", "", "void loop() {", "  int val = analogRead(A1);", "  if (val < 800) {", "    blink();", "  } else {", "    delay(1000);", "  }", "}"]}
{"code": "#include <OLED_I2C.h>\r\nOLED  screen(SDA, SCL, 8);\r\nextern uint8_t SmallFont[];\r\ntypedef enum GameScreen { MENU = 0, GAME } GameScreen;\r\n\r\nGameScreen curScreen = MENU;\r\nvoid setup() {\r\n  screen.begin();\r\n  screen.setFont(SmallFont);  \r\n  //Sets pinmodes for 4 buttons that I have\r\n  pinMode(2, OUTPUT);\r\n  pinMode(3, OUTPUT);\r\n  pinMode(4, OUTPUT);\r\n  pinMode(5, OUTPUT);      \r\n}\r\n\r\nvoid loop() {\r\n  screen.clrScr();\r\n  switch(curScreen){\r\n    case MENU:\r\n      screen.print(\"Press ANY button\", 16, 32);\r\n      screen.print(\"to PLAY\", 40, 47);\r\n      screen.print(\"Title\", 48, 15);\r\n      if(digitalRead(2) == 1 || digitalRead(3) == 1 || digitalRead(4) == 1 || digitalRead(5) == 1){\r\n        curScreen = GAME;\r\n      }\r\n      break;\r\n    case GAME:\r\n      //Game code here\r\n      screen.print(\"Game screen\", 16, 32);\r\n      break;\r\n  }\r\n  screen.update();\r\n}\r\n", "line": 21, "slice": ["#include <OLED_I2C.h>", "OLED  screen(SDA, SCL, 8);", "extern uint8_t SmallFont[];", "typedef enum GameScreen { MENU = 0, GAME } GameScreen;", "", "GameScreen curScreen = MENU;", "void setup() {", "  screen.begin();", "  screen.setFont(SmallFont);  ", "}", "", "void loop() {", "  screen.clrScr();", "  switch(curScreen){", "    case MENU:", "      if(digitalRead(2) == 1 || digitalRead(3) == 1 || digitalRead(4) == 1 || digitalRead(5) == 1){", "        curScreen = GAME;", "      }", "      break;", "    case GAME:", "      screen.print(\"Game screen\", 16, 32);", "      break;", "  }", "  screen.update();", "}"]}
{"code": "#include \"MLX90615.h\"\n\n#define MLX MLX90615_DefaultAddr\n\n/*\n    Uncomment the following line to use included I2C library\n\n    Avoid (keep commented) if your I2C bus is being shared with\n    other devices: they may be using Wire as its basis,\n    incompatible with the included I2C library\n*/\n// #define INCLUDED_I2C\n\n#ifdef INCLUDED_I2C\n    #define SDA_PIN SDA   //define the SDA pin\n    #define SCL_PIN SCL   //define the SCL pin\n    SoftI2cMaster i2c(SDA_PIN, SCL_PIN);\n    MLX90615 mlx90615(MLX, &i2c);\n#else // Using Wire\n    MLX90615 mlx90615(MLX, &Wire);\n#endif // INCLUDED_I2C not defined\n\nvoid setup() {\n    Serial.begin(9600);\n    while (!Serial); // Only for native USB serial\n    delay(2000); // Additional delay to allow open the terminal to see setup() messages\n    Serial.println(\"Setup...\");\n\n    #ifndef INCLUDED_I2C // If using Wire:\n    Wire.begin();\n    #endif // INCLUDED_I2C not defined\n\n    // // write data into EEPROM when you need to adjust emissivity.\n    // Serial.println(mlx90615.writeReg(MLX90615_EEPROM_EMISSIVITY,0x0000)); // Erase! (and see result)\n    // delay(10); // EEPROM Write/Erase time\n    // Serial.println(mlx90615.writeReg(MLX90615_EEPROM_EMISSIVITY,Default_Emissivity)); // Desired\n    // delay(10); // EEPROM Write/Erase time\n    // mlx90615.readEEPROM(); //read EEPROM data to check whether it's a default one.\n}\n\nvoid loop() {\n    Serial.print(\"Object temperature: \");\n    Serial.println(mlx90615.getTemperature(MLX90615_OBJECT_TEMPERATURE));\n    Serial.print(\"Ambient temperature: \");\n    Serial.println(mlx90615.getTemperature(MLX90615_AMBIENT_TEMPERATURE));\n    delay(1000);\n}\n", "line": 42, "slice": ["#include \"MLX90615.h\"", "#define MLX MLX90615_DefaultAddr", "MLX90615 mlx90615(MLX, &Wire);", "void setup() {", "    Wire.begin();", "}", "void loop() {", "    Serial.println(mlx90615.getTemperature(MLX90615_AMBIENT_TEMPERATURE));", "}"]}
{"code": "/****************************************************************************************************************************\n  multiFileProject.ino\n  For ESP32 boards\n  Written by Khoi Hoang\n  \n  Built by Khoi Hoang https://github.com/khoih-prog/ESP32_ISR_Servo\n  Licensed under MIT license\n*****************************************************************************************************************************/\n\n// To demo how to include files in multi-file Projects\n\n#ifndef ESP32\n  #error This code is designed to run on ESP32 platform, not Arduino nor ESP32! Please check your Tools->Board setting.\n#endif\n\n#define ESP32_ISR_SERVO_VERSION_MIN_TARGET      \"ESP32_ISR_Servo v1.2.0\"\n#define ESP32_ISR_SERVO_VERSION_MIN             1002000\n\n#include \"multiFileProject.h\"\n\n// To be included only in main(), .ino with setup() to avoid `Multiple Definitions` Linker Error\n#include \"ESP32_ISR_Servo.h\"\n\nvoid setup() \n{\n  Serial.begin(115200);\n  while (!Serial);\n  \n  Serial.println(\"\\nStart multiFileProject\");\n  Serial.println(ESP32_ISR_SERVO_VERSION);\n\n#if defined(ESP32_ISR_SERVO_VERSION_MIN)\n  if (ESP32_ISR_SERVO_VERSION_INT < ESP32_ISR_SERVO_VERSION_MIN)\n  {\n    Serial.print(\"Warning. Must use this example on Version equal or later than : \");\n    Serial.println(ESP32_ISR_SERVO_VERSION_MIN_TARGET);\n  }\n#endif\n}\n\nvoid loop() \n{\n  // put your main code here, to run repeatedly:\n}\n", "line": 35, "slice": ["#define ESP32_ISR_SERVO_VERSION_MIN_TARGET      \"ESP32_ISR_Servo v1.2.0\"", "#define ESP32_ISR_SERVO_VERSION_MIN             1002000", "", "#include \"ESP32_ISR_Servo.h\"", "", "void setup() ", "{", "  Serial.begin(115200);", "  while (!Serial);", "  ", "  Serial.println(ESP32_ISR_SERVO_VERSION);", "", "#if defined(ESP32_ISR_SERVO_VERSION_MIN)", "  if (ESP32_ISR_SERVO_VERSION_INT < ESP32_ISR_SERVO_VERSION_MIN)", "  {", "    Serial.print(\"Warning. Must use this example on Version equal or later than : \");", "    Serial.println(ESP32_ISR_SERVO_VERSION_MIN_TARGET);", "  }", "#endif", "}"]}
{"code": "\nvoid debug(String msg) {\n#ifdef USE_SD_LOGGER\n  bool SD_logged = true;\n  if (SD_ready) {\n    File log_file = SD.open(F(\"log/debug.txt\"), FILE_WRITE);\n    if (log_file) {\n      unsigned long now = millis();\n      log_file.print(String(now));\n      log_file.print(\": \");\n      log_file.println(msg);\n      log_file.flush();\n      log_file.close();\n    } else {\n      Serial.println(F(\"SD logger failed!\"));\n    }\n  } else {\n    //    Serial.println(F(\"SD not ready!\"));\n    SD_logged = false;\n  }\n#else\n  const bool SD_logged = true;\n#endif\n\n#ifdef USE_LOGGER\n  if (SD_logged) {\n    Serial.println(msg);\n  } else {\n    Serial.print(msg);\n    Serial.println(\"*\");\n  }\n#endif\n}\n\n\n", "line": 9, "slice": ["void debug(String msg) {", "#ifdef USE_SD_LOGGER", "  bool SD_logged = true;", "  if (SD_ready) {", "    File log_file = SD.open(F(\"log/debug.txt\"), FILE_WRITE);", "    if (log_file) {", "      log_file.println(msg);", "    } else {", "      Serial.println(F(\"SD logger failed!\"));", "    }", "  } else {", "    SD_logged = false;", "  }", "#else", "  const bool SD_logged = true;", "#endif", "", "#ifdef USE_LOGGER", "  if (SD_logged) {", "    Serial.println(msg);", "  }", "#endif", "}"]}
{"code": "// This example illustrates use of SdFat's\n// minimal unbuffered AVR Serial support.\n//\n// This is useful for debug and saves RAM\n// Will not work on Due, Leonardo, or Teensy\n\n#include <SPI.h>\n#include <SdFat.h>\n#include <FreeStack.h>\n#ifdef UDR0  // Must be AVR with serial port zero.\n#include <MinimumSerial.h>\n\nMinimumSerial MiniSerial;\n\nvoid setup() {\n  MiniSerial.begin(9600);\n  MiniSerial.println(FreeStack());\n}\nvoid loop() {\n  int c;\n  MiniSerial.println(F(\"Type any Character\"));\n  while ((c = MiniSerial.read()) < 0) {}\n  MiniSerial.print(F(\"Read: \"));\n  MiniSerial.println((char)c);\n  while (MiniSerial.read() >= 0) {}\n}\n#else  // UDR0\n#error no AVR serial port 0\n#endif  // UDR0", "line": 23, "slice": ["#include <MinimumSerial.h>", "", "MinimumSerial MiniSerial;", "", "void setup() {", "  MiniSerial.begin(9600);", "}", "", "void loop() {", "  int c;", "  while ((c = MiniSerial.read()) < 0) {}", "  MiniSerial.println((char)c);", "  while (MiniSerial.read() >= 0) {}", "}"]}
{"code": "/*\n Example sketch for the Playstation Buzz library - developed by Kristian Lauszus\n For more information visit my blog: http://blog.tkjelectronics.dk/ or\n send me an e-mail:  kristianl@tkjelectronics.com\n */\n\n#include <PSBuzz.h>\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include <spi4teensy3.h>\n#endif\n#include <SPI.h>\n\nUSB Usb;\nPSBuzz Buzz(&Usb);\n\nvoid setup() {\n  Serial.begin(115200);\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  if (Usb.Init() == -1) {\n    Serial.print(F(\"\\r\\nOSC did not start\"));\n    while (1); // Halt\n  }\n  Serial.println(F(\"\\r\\nPS Buzz Library Started\"));\n}\n\nvoid loop() {\n  Usb.Task();\n\n  if (Buzz.connected()) {\n    for (uint8_t i = 0; i < 4; i++) {\n      if (Buzz.getButtonClick(RED, i)) {\n        Buzz.setLedToggle(i); // Toggle the LED\n        Serial.println(F(\"RED\"));\n      }\n      if (Buzz.getButtonClick(YELLOW, i))\n        Serial.println(F(\"YELLOW\"));\n      if (Buzz.getButtonClick(GREEN, i))\n        Serial.println(F(\"GREEN\"));\n      if (Buzz.getButtonClick(ORANGE, i))\n        Serial.println(F(\"ORANGE\"));\n      if (Buzz.getButtonClick(BLUE, i))\n        Serial.println(F(\"BLUE\"));\n    }\n  }\n}\n", "line": 24, "slice": ["#include <PSBuzz.h>", "#include <SPI.h>", "USB Usb;", "PSBuzz Buzz(&Usb);", "void loop() {", "  Usb.Task();", "  if (Buzz.connected()) {", "    for (uint8_t i = 0; i < 4; i++) {", "      if (Buzz.getButtonClick(RED, i)) {", "        Buzz.setLedToggle(i); // Toggle the LED", "      }", "    }", "  }", "}"]}
{"code": "// Receiver for the bmp085 demo sketch\n// 2010-05-26 <jc@wippler.nl> http://opensource.org/licenses/mit-license.php\n\n#include <JeeLib.h>\n\ntypedef struct { int16_t temp; int32_t pres; } Payload;\n\nvoid setup () {\n    Serial.begin(57600);\n    Serial.println(\"\\n[bmp085recv]\");\n    rf12_initialize(30, RF12_868MHZ, 5); // 868 Mhz, net group 5, node 30\n}\n\nvoid loop () {\n    if (rf12_recvDone() && rf12_crc == 0 && rf12_len == sizeof (Payload)) {\n        Payload* data = (Payload*) rf12_data;\n        Serial.print(\"BMP 0 0 \");\n        Serial.print(data->temp);\n        Serial.print(' ');\n        Serial.println(data->pres);\n    }\n}\n", "line": 17, "slice": ["#include <JeeLib.h>", "", "typedef struct { int16_t temp; int32_t pres; } Payload;", "", "void loop () {", "    if (rf12_recvDone() && rf12_crc == 0 && rf12_len == sizeof (Payload)) {", "        Payload* data = (Payload*) rf12_data;", "        Serial.print(\"BMP 0 0 \");", "        Serial.print(data->temp);", "        Serial.print(' ');", "        Serial.println(data->pres);", "    }", "}"]}
{"code": "#include <Arduino.h>\n#include <AceCommon.h>\n\nusing namespace ace_common;\n\nTimingStats stats;\n\nvoid collectData() {\n  stats.update(10);\n  stats.update(20);\n  stats.update(30);\n}\n\nvoid printStats() {\n  Serial.print(\"Min: \");\n  Serial.println(stats.getMin());\n\n  Serial.print(\"Max: \");\n  Serial.println(stats.getMax());\n\n  Serial.print(\"Avg: \");\n  Serial.println(stats.getAvg());\n\n  Serial.print(\"Exp Decay Avg: \");\n  Serial.println(stats.getExpDecayAvg());\n\n  Serial.print(\"Count: \");\n  Serial.println(stats.getCount());\n}\n\nvoid setup() {\n  Serial.begin(115200);\n  while (! Serial); // Leonardo/ProMicro\n\n  collectData();\n  printStats();\n\n  #ifdef EPOXY_DUINO\n    exit(0);\n  #endif\n}\n\nvoid loop() {\n}\n", "line": 15, "slice": ["#include <AceCommon.h>", "", "using namespace ace_common;", "", "TimingStats stats;", "", "void collectData() {", "  stats.update(10);", "  stats.update(20);", "  stats.update(30);", "}", "", "void printStats() {", "  Serial.print(\"Min: \");", "  Serial.println(stats.getMin());", "}", "", "void setup() {", "  Serial.begin(115200);", "  while (! Serial); // Leonardo/ProMicro", "", "  collectData();", "  printStats();", "}"]}
{"code": "\n#include \"LTC2941.h\"\n\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n    #define SERIAL SerialUSB\n#else\n    #define SERIAL Serial\n#endif\n\nfloat coulomb = 0, mAh = 0;\n\nvoid setup(void) {\n    Wire.begin();\n\n    SERIAL.begin(115200);\n    while (!SERIAL.available());\n\n    SERIAL.println(\"LTC2941 Raw Data\");\n\n    ltc2941.initialize();\n    ltc2941.setPrescaler(PRESCALAR_M_1);\n}\n\nvoid loop(void) {\n    coulomb = ltc2941.getCoulombsExpend();\n    mAh = ltc2941.getmAhExpend();\n\n    SERIAL.print(coulomb);\n    SERIAL.print(\"C,\");\n    SERIAL.print(mAh);\n    SERIAL.print(\"mAh\");\n\n    SERIAL.println();\n\n    delay(5000);\n}\n", "line": 28, "slice": ["#include \"LTC2941.h\"", "", "float coulomb = 0, mAh = 0;", "", "void setup(void) {", "    ltc2941.initialize();", "    ltc2941.setPrescaler(PRESCALAR_M_1);", "}", "", "void loop(void) {", "    coulomb = ltc2941.getCoulombsExpend();", "    mAh = ltc2941.getmAhExpend();", "", "    SERIAL.print(coulomb);", "    SERIAL.print(\"C,\");", "    SERIAL.print(mAh);", "    SERIAL.print(\"mAh\");", "", "    delay(5000);", "}"]}
{"code": "/*  Example of reading and writing USB Host Shield GPI output\n    This example uses \"Wiring\" style interface. See Blink_LowLevel for example of using low-level UHS interface\n    Author: Brian Walton (brian@riban.co.uk)\n*/\n#include <UHS2_gpio.h>\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include <spi4teensy3.h>\n#endif\n\n#define OUTPUT_PIN 0\n\nUSB Usb; // Create an UHS2 interface object\nUHS2_GPIO Gpio(&Usb); // Create a GPIO object\n\nvoid setup() {\n  Serial.begin( 115200 );\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  Serial.println(\"Start\");\n\n  if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n\n  delay( 200 );\n}\n\nvoid loop() {\n  // Get the current output value, toggle then wait half a second\n  int nValue = Gpio.digitalReadOutput(OUTPUT_PIN);\n  nValue = (nValue ? 0 : 1);\n  Gpio.digitalWrite(OUTPUT_PIN, nValue);\n  Serial.print(nValue ? \"+\" : \".\"); // Debug to show what the output should be doing\n  delay(500);\n}\n\n", "line": 35, "slice": ["#define OUTPUT_PIN 0", "", "USB Usb; // Create an UHS2 interface object", "UHS2_GPIO Gpio(&Usb); // Create a GPIO object", "", "int nValue = Gpio.digitalReadOutput(OUTPUT_PIN);", "nValue = (nValue ? 0 : 1);", "Gpio.digitalWrite(OUTPUT_PIN, nValue);"]}
{"code": "void MQTT_connect() {\n  int8_t ret;\n  if (mqtt.connected()) {return;} // Stop if already connected.\n    #ifdef DEBUG_MQTT\n      if(manageMe){\n      Serial.print(\"Connecting to MQTT... \");}\n    #endif\n\n  while ((ret = mqtt.connect()) != 0) { // connect will return 0 for connected\n   #ifdef DEBUG_MQTT\n    if(manageMe){\n    Serial.println(mqtt.connectErrorString(ret));\n    Serial.println(\"Retrying MQTT connection in 5 seconds...\");}\n    #endif\n    mqtt.disconnect();\n    delay(500);\n  }\n   #ifdef DEBUG_MQTT\n      if(manageMe){\n      Serial.println(\"MQTT Connected!\");}\n    #endif\n\n}\n\n\n", "line": 6, "slice": ["void MQTT_connect() {", "  int8_t ret;", "  if (mqtt.connected()) {return;} // Stop if already connected.", "  while ((ret = mqtt.connect()) != 0) { // connect will return 0 for connected", "    mqtt.disconnect();", "    delay(500);", "  }", "}"]}
{"code": "#include \"./include/Receiver.h\"\n\n#include \"./include/PPM_Receiver.h\"\n#include \"./include/PWM_Receiver.h\"\n\nPWMReceiver pwmReceiver(19, 20, 21, 22);\nPPMReceiver ppmReceiver(10);\n\n#define use_pwm\n\nuint16_t channels[4] = { 0 };\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n#ifdef use_pwm\n    pwmReceiver.update(channels);\n    for (int index = 0; index < 4; index++) {\n        Serial.print(channels[index]);\n        Serial.print(\"\\t\");\n    }\n    Serial.println();\n    delay(5);\n#endif\n\n#ifdef use_ppm\n\n    ppmReceiver.update(channels);\n    for (int index = 0; index < 8; index++) {\n        Serial.print(channels[index]);\n        Serial.print(\"\\t\");\n    }\n    Serial.println();\n    delay(5);\n\n#endif\n}\n", "line": 21, "slice": ["#include \"./include/PWM_Receiver.h\"", "", "PWMReceiver pwmReceiver(19, 20, 21, 22);", "", "#define use_pwm", "", "uint16_t channels[4] = { 0 };", "", "void loop() {", "#ifdef use_pwm", "    pwmReceiver.update(channels);", "    for (int index = 0; index < 4; index++) {", "        Serial.print(channels[index]);", "        Serial.print(\"\\t\");", "    }", "    Serial.println();", "    delay(5);", "#endif", "}"]}
{"code": "// ============ SETTINGS ============\n// -- DEBUG --\n#define DEBUG\n#ifdef DEBUG\n#define DEBUG_PRINT(x) Serial.print(x)\n#define DEBUG_PRINTLN(x) Serial.println(x)\n#else\n#define DEBUG_PRINT(x)\n#define DEBUG_PRINTLN(x)\n#endif\n// -- BME280 --\n#define SEALEVELPRESSURE_HPA (1013.25)\n#define HPA_TO_MMHG          0.7500638\n//-- Serial --\n#define SPEED_SERIAL 115200\n// ============ SETTINGS ============\n", "line": 5, "slice": ["#define DEBUG", "#ifdef DEBUG", "#define DEBUG_PRINT(x) Serial.print(x)", "#define DEBUG_PRINTLN(x) Serial.println(x)", "#else", "#define DEBUG_PRINT(x)", "#define DEBUG_PRINTLN(x)", "#endif"]}
{"code": "#ifdef USE_LIQUID_CRYSTAL\n\n// initialize OLED\n//                   addr, contrast(0-255)\nI2CLiquidCrystal lcd(0x3C, (uint8_t)127);\n\nvoid setupLiquidCrystal()\n{\n#if defined(__SAM3X8E__)\n  // Due has 1k5 pull up at the default TWI I/F, Wire. The value is too small so we'd better use Wire1.\n  lcd.setWire(&Wire1);\n#endif\n  lcd.begin(16, 2);\n  lcd.setCursor(0, 0);\n  lcd.print(F(\"No Fix\"));\n}\n\nvoid LCDprint(char *p)\n{\n  // print hour:minute:second on LCD\n  lcd.setCursor(0, 0);\n  for (int i = 0; ; ) {\n    lcd.print(p[i++]); lcd.print(p[i++]);\n    if (i == 6)\n      break;\n    lcd.print(F(\":\"));\n  }\n}\n\n#else\n\nvoid setupLiquidCrystal()\n{\n  \n}\n\nvoid LCDprint(char *s)\n{\n  \n}\n#endif\n", "line": 15, "slice": ["I2CLiquidCrystal lcd(0x3C, (uint8_t)127);", "void LCDprint(char *p)", "{", "  lcd.setCursor(0, 0);", "  for (int i = 0; ; ) {", "    lcd.print(p[i++]); lcd.print(p[i++]);", "    if (i == 6)", "      break;", "    lcd.print(F(\":\"));", "  }", "}"]}
{"code": "//\n// Receive packets from Temperature Node. Print RF12 group ID, node ID, Vcc, T.\n//\n\n#include <Bridge.h>\n#include <JeeLib.h>\n\ntypedef struct\n{\n    byte rf12_group;\n    byte rf12_nodeid;\n    float Vcc;  // Supply voltage\n    float T;    // Temperature reading\n} dataPackageStruc;\n\ndataPackageStruc dataPackage;\n\n\nvoid setup ()\n{\n    Serial.begin(57600);\n    Serial.println(\"Receive packets from Temperature Node, print RF 12 group ID, node ID, Vcc, T\");\n\n    rf12_initialize(1, RF12_868MHZ, 0); // group id = 0 to receive from all groups\n}\n\nvoid loop ()\n{\n    if (rf12_recvDone() && rf12_crc == 0)\n    {\n        /*\n            // debugging only: examine packet byte by byte\n            for (byte i = 0; i < rf12_len; ++i) {\n              Serial.print(rf12_data[i]);\n              Serial.print(' ');\n            }\n        */\n\n        // assuming payload structure is correct\n        dataPackage.rf12_group = rf12_grp;\n        dataPackage.rf12_nodeid = rf12_hdr & RF12_HDR_MASK; // node id is in the first 5 bits of rf12_hdr --> & RF12_HDR_MASK\n        dataPackage.Vcc = word(rf12_data[1], rf12_data[0]) / 1000.0;\n        dataPackage.T = word(rf12_data[3], rf12_data[2]) / 100.0;\n\n        Serial.print(\"rf12 group = \"); Serial.print(dataPackage.rf12_group);\n        Serial.print(\", rf12 node id = \"); Serial.print(dataPackage.rf12_nodeid);\n        Serial.print(\", Vcc = \"); Serial.print(dataPackage.Vcc);\n        Serial.print(\", T = \"); Serial.println(dataPackage.T);\n    }\n}\n", "line": 34, "slice": ["#include <Bridge.h>", "#include <JeeLib.h>", "", "typedef struct", "{", "    byte rf12_group;", "    byte rf12_nodeid;", "    float Vcc;  // Supply voltage", "    float T;    // Temperature reading", "} dataPackageStruc;", "", "dataPackageStruc dataPackage;", "", "void loop ()", "{", "    if (rf12_recvDone() && rf12_crc == 0)", "    {", "        dataPackage.rf12_group = rf12_grp;", "        dataPackage.rf12_nodeid = rf12_hdr & RF12_HDR_MASK; // node id is in the first 5 bits of rf12_hdr --> & RF12_HDR_MASK", "        dataPackage.Vcc = word(rf12_data[1], rf12_data[0]) / 1000.0;", "        dataPackage.T = word(rf12_data[3], rf12_data[2]) / 100.0;", "", "        Serial.print(\"rf12 group = \"); Serial.print(dataPackage.rf12_group);", "        Serial.print(\", rf12 node id = \"); Serial.print(dataPackage.rf12_nodeid);", "        Serial.print(\", Vcc = \"); Serial.print(dataPackage.Vcc);", "        Serial.print(\", T = \"); Serial.println(dataPackage.T);", "    }", "}"]}
{"code": "#ifdef ENABLE_MLX\n\n#include <Adafruit_MLX90614.h>\n\nAdafruit_MLX90614 mlx = Adafruit_MLX90614();\n\nvoid mlx_start() {\n  mlx.begin();\n  Serial.println(F(\"<MLX_START=TRUE>\"));\n}\n\nvoid mlx_cmd( uint8_t Setting ){\n  switch (Setting) {\n    case 0: // Ambient Temperature\n      Serial.print(F(\"<MLX_AMB=\")); \n      Serial.print(mlx.readAmbientTempC()); \n      Serial.println(F(\">\"));\n      break;\n    case 1: // Object Temperature\n      Serial.print(F(\"<MLX_OBJ=\")); \n      Serial.print(mlx.readObjectTempC()); \n      Serial.println(F(\">\"));\n      break;\n  }\n}\n\n\n#endif\r\n", "line": 15, "slice": ["#include <Adafruit_MLX90614.h>", "", "Adafruit_MLX90614 mlx = Adafruit_MLX90614();", "", "void mlx_cmd( uint8_t Setting ){", "  switch (Setting) {", "    case 1: // Object Temperature", "      Serial.print(F(\"<MLX_OBJ=\")); ", "      Serial.print(mlx.readObjectTempC()); ", "      break;", "  }", "}"]}
{"code": "#include <WiFi.h>\n\n#define USE_WIFI\n\n//#define WIFI_SSID \"Keren1978\"\n//#define WIFI_PASSWORD \"Keren1978\"\n#define WIFI_SSID \"sababa\"\n#define WIFI_PASSWORD \"sababababasis\"\n\n// ESP32 analog GPIO pins: 2, 4, 12, 13, 14, 15, 25, 26, 27, 32, 33, 34, 35, 36(SVP), 39(SVN)\n\n// Input 1: SVP (GPIO 36)\n// Input 2: SVN (GPIO 39)\n// Input 3: GPIO 34\n// Input 4: GPIO 35\n// Input 5: GPIO 32\n// Input 6: GPIO 33\n// Input 7: GPIO 25\n// Input 8: GPIO 26\n\nvoid setup() {\n  Serial.begin(115200);\n#ifdef USE_WIFI\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.print(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(500);\n  }\n#endif\n}\n\nint pin = 2;\n\nvoid loop() {\n  if (Serial.available()) {\n    pin = Serial.parseInt();\n  }\n  Serial.println(analogRead(pin)); \n}\n", "line": 25, "slice": ["#include <WiFi.h>", "#define USE_WIFI", "#define WIFI_SSID \"sababa\"", "#define WIFI_PASSWORD \"sababababasis\"", "void setup() {", "  Serial.begin(115200);", "#ifdef USE_WIFI", "  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);", "  Serial.print(\"Connecting to Wi-Fi\");", "  while (WiFi.status() != WL_CONNECTED) {", "    Serial.print(\".\");", "    delay(500);", "  }", "#endif", "}", "int pin = 2;", "void loop() {", "  if (Serial.available()) {", "    pin = Serial.parseInt();", "  }", "  Serial.println(analogRead(pin)); ", "}"]}
{"code": "// Copyright 2017 Jonny Graham, 2018 David Conran\r\n#ifndef UNIT_TEST\r\n#include <Arduino.h>\r\n#endif\r\n#include <IRremoteESP8266.h>\r\n#include <IRsend.h>\r\n#include <ir_Fujitsu.h>\r\n\r\nconst uint16_t kIrLed = 4;  // ESP8266 GPIO pin to use. Recommended: 4 (D2).\r\nIRFujitsuAC ac(kIrLed);\r\n\r\nvoid printState() {\r\n  // Display the settings.\r\n  Serial.println(\"Fujitsu A/C remote is in the following state:\");\r\n  Serial.printf(\"  %s\\n\", ac.toString().c_str());\r\n  // Display the encoded IR sequence.\r\n  unsigned char* ir_code = ac.getRaw();\r\n  Serial.print(\"IR Code: 0x\");\r\n  for (uint8_t i = 0; i < ac.getStateLength(); i++)\r\n    Serial.printf(\"%02X\", ir_code[i]);\r\n  Serial.println();\r\n}\r\n\r\nvoid setup() {\r\n  ac.begin();\r\n  Serial.begin(115200);\r\n  delay(200);\r\n\r\n  // Set up what we want to send. See ir_Fujitsu.cpp for all the options.\r\n  Serial.println(\"Default state of the remote.\");\r\n  printState();\r\n  Serial.println(\"Setting desired state for A/C.\");\r\n  ac.setCmd(kFujitsuAcCmdTurnOn);\r\n  ac.setSwing(kFujitsuAcSwingBoth);\r\n  ac.setMode(kFujitsuAcModeCool);\r\n  ac.setFanSpeed(kFujitsuAcFanHigh);\r\n  ac.setTemp(24);  // 24C\r\n}\r\n\r\nvoid loop() {\r\n  // Now send the IR signal.\r\n  Serial.println(\"Sending IR command to A/C ...\");\r\n#if SEND_FUJITSU_AC\r\n  ac.send();\r\n#else  // SEND_FUJITSU_AC\r\n  Serial.println(\"Can't send because SEND_FUJITSU_AC has been disabled.\");\r\n#endif  // SEND_FUJITSU_AC\r\n  printState();\r\n  delay(5000);\r\n}\r\n", "line": 18, "slice": ["const uint16_t kIrLed = 4;  // ESP8266 GPIO pin to use. Recommended: 4 (D2).", "IRFujitsuAC ac(kIrLed);", "", "void setup() {", "  ac.begin();", "  ac.setCmd(kFujitsuAcCmdTurnOn);", "  ac.setSwing(kFujitsuAcSwingBoth);", "  ac.setMode(kFujitsuAcModeCool);", "  ac.setFanSpeed(kFujitsuAcFanHigh);", "  ac.setTemp(24);  // 24C", "}", "", "void loop() {", "#if SEND_FUJITSU_AC", "  ac.send();", "#endif  // SEND_FUJITSU_AC", "  delay(5000);", "}"]}
{"code": "/************************************************************\n\u25a0\u53c2\u8003\n\t\u25a0Arduino \u96fb\u5b50\u5de5\u4f5c \u5b9f\u8df5\u8b1b\u5ea7\n\t\tp156\n************************************************************/\n#define PLOTTER\n\n/************************************************************\n************************************************************/\nconst int PIR_PIN = 4;\n\n/******************************\n******************************/\nvoid setup(){\n\tpinMode( PIR_PIN, INPUT ); // set : Digital Pin : for open collector.\n\n\tSerial.begin( 9600 );\n}\n\n/******************************\n******************************/\nvoid loop() {\n\tint analog_val;\n\tfloat input_volt;\n\t\n\tanalog_val = analogRead(PIR_PIN); // \u8a66\u9a13\u7aef\u5b50\n\tinput_volt = float(analog_val) * 5.0 / 1023.0;\n\t\n#ifdef PLOTTER\n\tSerial.print( millis() / 1000 % 2 * 10 );\n\tSerial.print(\",\");\n#endif\n\n\tSerial.print(input_volt);\n\tSerial.print(\",\");\n\t\n\tif(digitalRead(PIR_PIN) == HIGH){ // open collector.\n\t\tSerial.println(5);\t// nobody\n\t}else{\n\t\tSerial.println(0);\t// somebody\n\t}\n\t\n#ifdef PLOTTER\n\tdelay(100);\n#else\n\tdelay(1000);\n#endif\n}\n", "line": 30, "slice": ["#define PLOTTER", "", "const int PIR_PIN = 4;", "", "void setup(){", "\tpinMode( PIR_PIN, INPUT );", "\tSerial.begin( 9600 );", "}", "", "void loop() {", "\tint analog_val;", "\tfloat input_volt;", "\t", "\tanalog_val = analogRead(PIR_PIN);", "\tinput_volt = float(analog_val) * 5.0 / 1023.0;", "\t", "\tif(digitalRead(PIR_PIN) == HIGH){", "\t\tSerial.println(5);", "\t}else{", "\t\tSerial.println(0);", "\t}", "}"]}
{"code": "#include <Wire.h> \n#include <SPI.h>\n#include <nRF24L01.h>\n#include <RF24.h>\n\n//#define DEBUG\n\nRF24 radio(10, 9); // CE, CSN\nconst byte address[6] = \"00001\";\n\nenum buttons {LYF, LYB, RXL, RXR, STOP, LIGHT, POWER_DOWN, POWER_UP};\n\nenum slaves {HEART};\n\ntypedef struct {\n  byte key;\n  byte value;\n} Package;\n\nPackage package;\n\nvoid setup() {\n  #ifdef DEBUG\n    Serial.begin(115200);\n  #endif\n  radio.begin();\n  radio.openReadingPipe(0, address);\n  radio.setPALevel(RF24_PA_HIGH);\n  radio.setDataRate(RF24_250KBPS);\n  radio.setPayloadSize(2);\n  radio.setChannel(2);\n  radio.startListening();\n  Wire.begin(); \n  #ifdef DEBUG\n    Serial.println(\"I am Receiver\");\n  #endif\n}\n\nvoid loop() {\n  if (radio.available()) {\n      radio.read(&package, sizeof(package));\n      #ifdef DEBUG\n        Serial.print(package.key);\n        Serial.println(package.value);\n      #endif\n      Wire.beginTransmission(slaves::HEART);\n      Wire.write((byte *)&package, sizeof package);\n      Wire.endTransmission();  \n  } \n}\n", "line": 43, "slice": ["RF24 radio(10, 9); // CE, CSN", "const byte address[6] = \"00001\";", "", "typedef struct {", "  byte key;", "  byte value;", "} Package;", "", "Package package;", "", "void setup() {", "  radio.begin();", "  radio.openReadingPipe(0, address);", "  radio.startListening();", "}", "", "void loop() {", "  if (radio.available()) {", "      radio.read(&package, sizeof(package));", "      Wire.beginTransmission(slaves::HEART);", "      Wire.write((byte *)&package, sizeof package);", "      Wire.endTransmission();  ", "  } ", "}"]}
{"code": "/*\r\n * This is an integration test for the IMU\r\n * Use SCL = PB6, SDA = PB7\r\n */\r\n\r\n#ifdef JOYSTICK\r\n\r\n\r\nvoid setup() {\r\n  // Start up serial\r\n  NeoSerial.begin(115200);\r\n\r\n  // Configure IMU for sample time\r\n  NeoSerial.println(\"Starting Joystick\");\r\n}\r\n\r\nvoid loop() {\r\n  // Sample IMU data if available\r\n\r\n  int joystickX = analogRead(PIN_JOYSTICK_X);\r\n  int joystickY = analogRead(PIN_JOYSTICK_Y);\r\n\r\n  float xval = mapJoystick(joystickX, 499, LINEAR_VELOCITY_MAX, LINEAR_VELOCITY_MIN);\r\n  float yval = mapJoystick(joystickY, 522, ANGULAR_VELOCITY_MAX, ANGULAR_VELOCITY_MIN);\r\n\r\n  NeoSerial.print(joystickX);\r\n  NeoSerial.print(\" \");\r\n  NeoSerial.print(joystickY);\r\n  NeoSerial.print(\" \");\r\n  NeoSerial.print(xval);\r\n  NeoSerial.print(\" \");\r\n  NeoSerial.print(yval);\r\n  NeoSerial.println();\r\n  \r\n}\r\n\r\nfloat mapJoystick(int input, int deadzone, const float& maxVal, const float& minVal) {\r\n  float output;\r\n  if (input >= deadzone) {\r\n    output = (float) (input - deadzone) / (JOYSTICK_MAX - deadzone) * maxVal;\r\n  } else {\r\n    output = (float) (deadzone - input) / (deadzone - JOYSTICK_MIN) * minVal;\r\n  }\r\n  return output;\r\n}\r\n\r\n#endif\r\n", "line": 26, "slice": ["#ifdef JOYSTICK", "", "int joystickX = analogRead(PIN_JOYSTICK_X);", "int joystickY = analogRead(PIN_JOYSTICK_Y);", "", "float xval = mapJoystick(joystickX, 499, LINEAR_VELOCITY_MAX, LINEAR_VELOCITY_MIN);", "float yval = mapJoystick(joystickY, 522, ANGULAR_VELOCITY_MAX, ANGULAR_VELOCITY_MIN);", "", "NeoSerial.print(joystickX);", "NeoSerial.print(\" \");", "NeoSerial.print(joystickY);", "NeoSerial.print(\" \");", "NeoSerial.print(xval);", "NeoSerial.print(\" \");", "NeoSerial.print(yval);", "", "float mapJoystick(int input, int deadzone, const float& maxVal, const float& minVal) {", "  float output;", "  if (input >= deadzone) {", "    output = (float) (input - deadzone) / (JOYSTICK_MAX - deadzone) * maxVal;", "  } else {", "    output = (float) (deadzone - input) / (deadzone - JOYSTICK_MIN) * minVal;", "  }", "  return output;", "}", "", "#endif"]}
{"code": "// LCD display\n// Manferdelli\n\n#include <LiquidCrystal.h>\n\ntypedef uint8_t byte;\n\n//  16x2 LCD display.  The LiquidCrystal library works with all LCD displays \n//  that are compatible with the Hitachi HD44780 driver.\n//\n// LCD RS pin to digital pin 12\n// LCD Enable pin to digital pin 11\n// LCD D4 pin to digital pin 5\n// LCD D5 pin to digital pin 4\n// LCD D6 pin to digital pin 3\n// LCD D7 pin to digital pin 2\n// LCD R/W pin to ground\n// LCD VSS pin to ground\n// LCD VCC pin to 5V\n// 10K resistor: ends to +5V and ground\n// wiper to LCD VO pin (pin 3)\n//\n// See: http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld\n\nconst int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;\nLiquidCrystal lcd(rs, en, d4, d5, d6, d7);\n\nvoid setup() {\n  Serial.begin(9600);\n  lcd.begin(16, 2);\n  lcd.clear();\n  lcd.leftToRight();\n  lcd.setCursor(0, 1);\n  lcd.write(\"Hello, John\");\n  lcd.setCursor(0, 0);\n  lcd.write(\"0123456789abcdef\");\n\n}\n\nvoid loop() {\n  // set the cursor to column 0, line 1 line 1 is the second row\n  lcd.setCursor(0, 1);\n  lcd.print(millis() / 1000);\n}\n", "line": 43, "slice": ["#include <LiquidCrystal.h>", "", "typedef uint8_t byte;", "", "const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;", "LiquidCrystal lcd(rs, en, d4, d5, d6, d7);", "", "void setup() {", "  lcd.begin(16, 2);", "}", "", "void loop() {", "  lcd.setCursor(0, 1);", "  lcd.print(millis() / 1000);", "}"]}
{"code": "// Must match baud on the serial monitor\n#define BAUD_RATE 9600\n\n// https://github.com/olikraus/U8g2_Arduino\n// These libraries need to be downloaded and installed manually.\n#include <U8x8lib.h>\n#ifdef U8X8_HAVE_HW_SPI\n#include <SPI.h>\n#endif\nU8X8_SH1107_128X128_HW_I2C u8x8(/* reset=*/ U8X8_PIN_NONE);\n\nvoid setup() {\n    setupSerial();\n\tsetupOLED();\n\ttestOLED();\n}\n\nvoid loop() {\n}\n\nvoid setupSerial() {\n\tSerial.begin(BAUD_RATE);\n\tSerial.println(\"-====-====-====-====-\");\n\tSerial.print(\"Serial Started at \");\n\tSerial.print(BAUD_RATE);\n\tSerial.println(\" Baud\");\n\tSerial.println(\"-====-====-====-====-\");\n}\n\nvoid setupOLED() {\n    u8x8.begin();\n\tSerial.println(\"OLED initialized!\");\n\tSerial.println(\"-====-====-====-====-\");\n}\n\nvoid testOLED() {\n\tunsigned long startTime = millis();\n\t\n    Serial.println(\"Started OLED draw test\");\n    Serial.println(\"-====-====-====-====-\");\n    u8x8.setFont(u8x8_font_chroma48medium8_r);\n\tu8x8.drawString(0,0,\"Hello World!\");\n\tSerial.println(\"Finnished OLED draw test\");\n    Serial.println(\"-====-====-====-====-\");\n\t\n\tunsigned long endTime = millis() - startTime;\n\tSerial.print(\"Time taken for test OLED (ms): \");\n\tSerial.println(endTime);\n\tSerial.println(\"-====-====-====-====-\");\n}", "line": 24, "slice": ["#define BAUD_RATE 9600", "#include <U8x8lib.h>", "U8X8_SH1107_128X128_HW_I2C u8x8(/* reset=*/ U8X8_PIN_NONE);", "void setup() {", "    setupSerial();", "\tsetupOLED();", "\ttestOLED();", "}", "void setupSerial() {", "\tSerial.begin(BAUD_RATE);", "}", "void setupOLED() {", "    u8x8.begin();", "}", "void testOLED() {", "    u8x8.setFont(u8x8_font_chroma48medium8_r);", "\tu8x8.drawString(0,0,\"Hello World!\");", "}"]}
{"code": "\n#include <miniSerial.h>\n\n\nvoid setup() {\n\tSerial.begin(9600);  // defaults to 19200, tx=PA9, rx=PA10\n\t// Serial.begin();   // other option\n\t// Serial.begin(19200, PA2, PA3);  // other option\n\tdelay(500);  // advise delay before serial output. Display wakeup reasons, not code reasons.\n#ifdef STM32F030x6  //this define is board ID\n    Serial.print(\"('030F4P6 found)\\n\\n\");\n    // original purpose of this library was for '030F4P6 board.  We found one!\n#endif\n\tSerial.print(\"\\nminiSerial demo.\\n\");\n\n\nSerial.println();\n\n\n}\n\n\n\nvoid loop() {\n\n\n\tSerial.write('H');  // no linefeed, so flows on\n\tSerial.println(\"ello...\");\n\tSerial.print(31741);\n\tSerial.print(\" = 0x\");   Serial.print(31741, HEX);\n\tSerial.print(\" = 0b\");  Serial.print(31741, BIN);\n\tSerial.println();\n    //Serial.println(-88.445, 2); // float is very expensive in flash (3.7k)\n\tdelay(2000);               \n}\n", "line": 11, "slice": ["#include <miniSerial.h>", "", "void setup() {", "\tSerial.begin(9600);  // defaults to 19200, tx=PA9, rx=PA10", "\tdelay(500);  // advise delay before serial output. Display wakeup reasons, not code reasons.", "\tSerial.print(\"\\nminiSerial demo.\\n\");", "\tSerial.println();", "}", "", "void loop() {", "\tSerial.println();", "}"]}
{"code": "\r\n#include <SPI.h>  \r\n#include \"RF24.h\"\r\n\r\n\r\nRF24 myRadio (7, 8);\r\nbyte addresses[][6] = {\"0\"};\r\n\r\nstruct package\r\n{\r\n  int X=1;\r\n  int Y=1;\r\n   int X1=1;\r\n  int Y1=1;\r\n};\r\n\r\n\r\ntypedef struct package Package;\r\nPackage data;\r\n\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  delay(100);\r\n  myRadio.begin();  \r\n  myRadio.setChannel(115); \r\n  myRadio.setPALevel(RF24_PA_MIN);\r\n  myRadio.setDataRate( RF24_250KBPS ) ; \r\n  myRadio.openWritingPipe( addresses[0]);\r\n  delay(100);\r\n}\r\n\r\nvoid loop()\r\n{\r\n \r\n  myRadio.write(&data, sizeof(data)); \r\n\r\n  Serial.print(\"X:\");\r\n  Serial.print(data.X);\r\n  Serial.print(\"    Y\");\r\n  Serial.println(data.Y);\r\n  data.X = analogRead(A0);\r\n  data.Y = analogRead(A1);\r\n  data.X1 = analogRead(A2);\r\n  data.Y1 = analogRead(A3);\r\n  delay(100);\r\n}\r\n", "line": 39, "slice": ["RF24 myRadio (7, 8);", "byte addresses[][6] = {\"0\"};", "", "struct package", "{", "  int X=1;", "  int Y=1;", "   int X1=1;", "  int Y1=1;", "};", "", "", "typedef struct package Package;", "Package data;", "", "void setup()", "{", "  myRadio.begin();  ", "  myRadio.openWritingPipe( addresses[0]);", "}", "", "void loop()", "{", " ", "  myRadio.write(&data, sizeof(data)); ", "", "  data.X = analogRead(A0);", "  data.Y = analogRead(A1);", "  data.X1 = analogRead(A2);", "  data.Y1 = analogRead(A3);", "}"]}
{"code": "// Complete Instructions to Get and Change ESP MAC Address: https://RandomNerdTutorials.com/get-change-esp32-esp8266-mac-address-arduino/\n/*\n#ifdef ESP32\n  \n#else\n  #include <ESP8266WiFi.h>\n#endif\n*/\n#include <WiFi.h>\nvoid setup(){\n  Serial.begin(115200);\n  Serial.println();\n  Serial.print(\"ESP Board MAC Address:  \");\n  Serial.println(WiFi.macAddress());\n}\n \nvoid loop(){\n  Serial.print(\"ESP Board MAC Address:  \");\n  Serial.println(WiFi.macAddress());\n  delay(3000);\n}\n", "line": 13, "slice": ["#include <WiFi.h>", "void setup(){", "  Serial.begin(115200);", "  Serial.println();", "  Serial.print(\"ESP Board MAC Address:  \");", "  Serial.println(WiFi.macAddress());", "}", " ", "void loop(){", "  Serial.print(\"ESP Board MAC Address:  \");", "  Serial.println(WiFi.macAddress());", "}"]}
{"code": "/*\n * SBUS input tester\n *\n * Copyright (c) 2021 Simon D. Levy\n *\n * MIT license\n */\n\n#include <sbus.h>\n\nSbusRx sbus_in(&Serial1);\n\nvoid setup() {\n\n    sbus_in.Begin(\n#ifdef ESP32\n          4, 14\n#endif\n        );\n\n    Serial.begin(115000);\n}\n\nvoid loop() {\n\n  if (sbus_in.Read()) {\n    /* Display the received data */\n    for (uint8_t i = 0; i < sbus_in.rx_channels().size(); i++) {\n      Serial.print(sbus_in.rx_channels()[i]);\n      Serial.print(\"\\t\");\n    }\n\n    /* Display lost frames and failsafe data */\n    Serial.print(sbus_in.lost_frame());\n    Serial.print(\"\\t\");\n    Serial.println(sbus_in.failsafe());\n  }\n}\n\n", "line": 29, "slice": ["#include <sbus.h>", "", "SbusRx sbus_in(&Serial1);", "", "void setup() {", "", "    sbus_in.Begin(", "#ifdef ESP32", "          4, 14", "#endif", "        );", "}", "", "void loop() {", "", "  if (sbus_in.Read()) {", "    for (uint8_t i = 0; i < sbus_in.rx_channels().size(); i++) {", "      Serial.print(sbus_in.rx_channels()[i]);", "      Serial.print(\"\\t\");", "    }", "", "    Serial.print(sbus_in.lost_frame());", "    Serial.print(\"\\t\");", "    Serial.println(sbus_in.failsafe());", "  }", "}"]}
{"code": "#include <Arduino.h>\n#include <AceCRC.h>\n\n// Define SERIAL_PORT_MONITOR for ESP32\n#ifndef SERIAL_PORT_MONITOR\n#define SERIAL_PORT_MONITOR Serial\n#endif\n\nusing namespace ace_crc::crc16ccitt_nibble;\n\nstatic const char CHECK_STRING[] = \"123456789\";\nstatic const size_t LENGTH = sizeof(CHECK_STRING) - 1; // ignore NUL char\n\nvoid setup() {\n#if ! defined(EPOXY_DUINO)\n  delay(1000);\n#endif\n  SERIAL_PORT_MONITOR.begin(115200);\n  while (!SERIAL_PORT_MONITOR); // Wait - Leonardo/Micro\n\n  crc_t crc = crc_init();\n  crc = crc_update(crc, CHECK_STRING, LENGTH);\n  crc = crc_finalize(crc);\n  SERIAL_PORT_MONITOR.print(\"0x\");\n  SERIAL_PORT_MONITOR.println((unsigned long) crc, 16);\n\n  crc = crc_calculate(CHECK_STRING, LENGTH);\n  SERIAL_PORT_MONITOR.print(\"0x\");\n  SERIAL_PORT_MONITOR.println((unsigned long) crc, 16);\n\n#if defined(EPOXY_DUINO)\n  exit(0);\n#endif\n}\n\nvoid loop() {\n}\n", "line": 24, "slice": ["#include <AceCRC.h>", "using namespace ace_crc::crc16ccitt_nibble;", "static const char CHECK_STRING[] = \"123456789\";", "static const size_t LENGTH = sizeof(CHECK_STRING) - 1; // ignore NUL char", "crc_t crc = crc_init();", "crc = crc_update(crc, CHECK_STRING, LENGTH);", "crc = crc_finalize(crc);", "crc = crc_calculate(CHECK_STRING, LENGTH);"]}
{"code": "\n/*\n  Utility functions to help debugging running code.\n*/\n\n#ifndef DEBUG_H\n#define DEBUG_H\n\n\n#define DEBUG_PRINT(str)        \\\n  Serial.print(millis());     \\\n  Serial.print(\": \");         \\\n  Serial.print(__PRETTY_FUNCTION__); \\\n  Serial.print(' ');          \\\n  Serial.print(__FILE__);     \\\n  Serial.print(':');          \\\n  Serial.print(__LINE__);     \\\n  Serial.print(' ');          \\\n  Serial.println(str);\n\n#endif\n", "line": 11, "slice": ["#define DEBUG_PRINT(str)        \\", "  Serial.print(millis());     \\", "  Serial.print(\": \");         \\", "  Serial.print(__PRETTY_FUNCTION__); \\", "  Serial.print(' ');          \\", "  Serial.print(__FILE__);     \\", "  Serial.print(':');          \\", "  Serial.print(__LINE__);     \\", "  Serial.print(' ');          \\", "  Serial.println(str);"]}
{"code": "const int photoPin = 0;\r\nconst int redLed = 7;\r\n\r\nconst int darkLevel = 500; //The value the photoresistor has to at least be before turning the LED on\r\nvoid setup()\r\n{\r\n\tSerial.begin(9600);\r\n\tpinMode(redLed, OUTPUT);\r\n}\r\n\r\n// Add the main program code into the continuous loop() function\r\nvoid loop()\r\n{\r\n\tint lightLevel = analogRead(photoPin);\r\n#ifdef DEBUG\r\n\tSerial.print(\"Light Level: \");\r\n\tSerial.println(lightLevel);\r\n\r\n#endif // DEBUG\r\n\r\n\tif (lightLevel > darkLevel)\r\n\t{\r\n\t\tdigitalWrite(redLed, HIGH);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdigitalWrite(redLed, LOW);\r\n\t}\r\n\tdelay(1000);\r\n}\r\n", "line": 16, "slice": ["const int photoPin = 0;", "const int redLed = 7;", "const int darkLevel = 500; //The value the photoresistor has to at least be before turning the LED on", "void loop()", "{", "\tint lightLevel = analogRead(photoPin);", "\tif (lightLevel > darkLevel)", "\t{", "\t\tdigitalWrite(redLed, HIGH);", "\t}", "\telse", "\t{", "\t\tdigitalWrite(redLed, LOW);", "\t}", "}"]}
{"code": "void neosetup() {\n  while (!DEBUG_PORT)\n    ;\n\n  DEBUG_PORT.print( F(\"NMEA.INO: started\\n\") );\n  DEBUG_PORT.print( F(\"  fix object size = \") );\n  DEBUG_PORT.println( sizeof(gps.fix()) );\n  DEBUG_PORT.print( F(\"  gps object size = \") );\n  DEBUG_PORT.println( sizeof(gps) );\n  DEBUG_PORT.println( F(\"Looking for GPS device on \" GPS_PORT_NAME) );\n\n\n#ifndef NMEAGPS_RECOGNIZE_ALL\n#error You must define NMEAGPS_RECOGNIZE_ALL in NMEAGPS_cfg.h!\n#endif\n\n#ifdef NMEAGPS_INTERRUPT_PROCESSING\n#error You must *NOT* define NMEAGPS_INTERRUPT_PROCESSING in NMEAGPS_cfg.h!\n#endif\n\n#if !defined( NMEAGPS_PARSE_GGA ) & !defined( NMEAGPS_PARSE_GLL ) & \\\n      !defined( NMEAGPS_PARSE_GSA ) & !defined( NMEAGPS_PARSE_GSV ) & \\\n      !defined( NMEAGPS_PARSE_RMC ) & !defined( NMEAGPS_PARSE_VTG ) & \\\n      !defined( NMEAGPS_PARSE_ZDA ) & !defined( NMEAGPS_PARSE_GST )\n\n  DEBUG_PORT.println( F(\"\\nWARNING: No NMEA sentences are enabled: no fix data will be displayed.\") );\n\n#else\n  if (gps.merging == NMEAGPS::NO_MERGING) {\n    DEBUG_PORT.print  ( F(\"\\nWARNING: displaying data from \") );\n    DEBUG_PORT.print  ( gps.string_for( LAST_SENTENCE_IN_INTERVAL ) );\n    DEBUG_PORT.print  ( F(\" sentences ONLY, and only if \") );\n    DEBUG_PORT.print  ( gps.string_for( LAST_SENTENCE_IN_INTERVAL ) );\n    DEBUG_PORT.println( F(\" is enabled.\\n\"\n                          \"  Other sentences may be parsed, but their data will not be displayed.\") );\n  }\n#endif\n\n  DEBUG_PORT.print  ( F(\"\\nGPS quiet time is assumed to begin after a \") );\n  DEBUG_PORT.print  ( gps.string_for( LAST_SENTENCE_IN_INTERVAL ) );\n  DEBUG_PORT.println( F(\" sentence is received.\\n\"\n                        \"  You should confirm this with NMEAorder.ino\\n\") );\n\n  trace_header( DEBUG_PORT );\n  DEBUG_PORT.flush();\n}\n", "line": 5, "slice": ["void neosetup() {", "  while (!DEBUG_PORT)", "    ;", "", "  DEBUG_PORT.print( F(\"NMEA.INO: started\\n\") );", "  DEBUG_PORT.print( F(\"  fix object size = \") );", "  DEBUG_PORT.println( sizeof(gps.fix()) );", "  DEBUG_PORT.print( F(\"  gps object size = \") );", "  DEBUG_PORT.println( sizeof(gps) );", "  DEBUG_PORT.println( F(\"Looking for GPS device on \" GPS_PORT_NAME) );", "}"]}
{"code": "void updateCurrentTemp() {\n\tdouble currentReading = readThermalcouple();\n\tif (currentReading == 0.00) {\n\t\t#ifdef USE_SERIAL\n\t\t\t#ifdef SHOW_ERROR\n\t\t\t\tSerial.print(F(\"error,\"));\n\t\t\t\tSerial.println(millis());\n\t\t\t#endif\n\t\t#endif\n\t\tcurrentTemperature = currentTemperature;\n\t} else {\n\t\tcurrentTemperature = currentReading; // don't change stored ftemperature\t\n\n\t}\n}\n\nfloat readThermalcouple() {\n\tfloat c = thermocouple.readCelsius();\n\tif (c == THERMOCOUPLE_DISCONNECTED) {\n      reflowState = REFLOW_STATE_ERROR;\n      reflowStatus = REFLOW_STATUS_OFF;\n\t}\n\tif (isnan(c))\n\t\treturn 0;\n\treturn c;\n}", "line": 6, "slice": ["Carrier code:", "void updateCurrentTemp() {", "\tdouble currentReading = readThermalcouple();", "\tif (currentReading == 0.00) {", "\t\tcurrentTemperature = currentTemperature;", "\t} else {", "\t\tcurrentTemperature = currentReading; // don't change stored ftemperature\t", "\t}", "}", "", "float readThermalcouple() {", "\tfloat c = thermocouple.readCelsius();", "\tif (c == THERMOCOUPLE_DISCONNECTED) {", "      reflowState = REFLOW_STATE_ERROR;", "      reflowStatus = REFLOW_STATUS_OFF;", "\t}", "\tif (isnan(c))", "\t\treturn 0;", "\treturn c;", "}"]}
{"code": "// 1-channel LoRa Gateway for ESP8266\n// Copyright (c) 2016, 2017, 2018 Maarten Westenberg\n// Verison 5.2.1\n// Date: 2018-06-06\n//\n// All rights reserved. This program and the accompanying materials\n// are made available under the terms of the MIT License\n// which accompanies this distribution, and is available at\n// https://opensource.org/licenses/mit-license.php\n//\n// NO WARRANTY OF ANY KIND IS PROVIDED\n//\n// Author: Maarten Westenberg (mw12554@hotmail.com)\n//\n// This file contains code for using the single channel gateway also as a sensor node. \n// Please specify the DevAddr and the AppSKey below (and on your LoRa backend).\n// Also you will have to choose what sensors to forward to your application.\n//\n// ============================================================================\n\t\t\n#if REPEATER==1\n\n#define _ICHAN 0\n#define _OCHAN 1\n\n#ifdef _TTNSERVER\n#error \"Please undefined _THINGSERVER, for REAPETR shutdown WiFi\"\n#endif\n\n// Send a LoRa message out from the gateway transmitter\n// XXX Maybe we should block the received ontul the message is transmitter\n\nint sendLora(char *msg, int len) {\n\t// Check whete len is not exceeding maximum length\n\tSerial.print(\"sendLora:: \");\n\t\n\tfor (int i=0; i< len; i++) {\n\t\tSerial.print(msg[1],HEX);\n\t\tSerial.print('.');\n\t}\n\t\n\tif (debug>=2) Serial.flush();\n\treturn(1);\n}\n\n#endif //REPEATER==1", "line": 35, "slice": ["#if REPEATER==1", "", "#define _ICHAN 0", "#define _OCHAN 1", "", "int sendLora(char *msg, int len) {", "\tSerial.print(\"sendLora:: \");", "\t", "\tfor (int i=0; i< len; i++) {", "\t\tSerial.print(msg[1],HEX);", "\t\tSerial.print('.');", "\t}", "\t", "\tif (debug>=2) Serial.flush();", "\treturn(1);", "}", "", "#endif //REPEATER==1"]}
{"code": "#include <Arduino.h>\n#include <pas-co2-serial-ino.hpp>\n\n/**\n * Select the serial interface:\n * - I2C (TwoWire)\n * - UART (HardwareSerial)\n * By default the I2C interfaces is selected. \n * Compile with -DINO_HW_SERIAL to select the UART interface.\n */\n#ifdef INO_HW_SERIAL\nHardwareSerial * bus = (HardwareSerial*) pltf->uart;\n#else\nTwoWire * bus = (TwoWire*) pltf->i2c;\n#endif\n\nPASCO2SerialIno cotwo(bus);\n\nuint8_t prodId, revId;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"pas co2 serial initialized\");\n  \n  Error_t err = cotwo.getDeviceID(prodId, revId);\n  if(pasco2::OK != err)\n  {\n    Serial.print(\"error: \");\n    Serial.println(err);\n  }\n\n  Serial.print(\"product id  : \");\n  Serial.println(prodId);\n  Serial.print(\"revision id : \");\n  Serial.println(revId);\n}\n\nvoid loop()\n{\n\n}", "line": 29, "slice": ["#include <Arduino.h>", "#include <pas-co2-serial-ino.hpp>", "", "#ifdef INO_HW_SERIAL", "HardwareSerial * bus = (HardwareSerial*) pltf->uart;", "#else", "TwoWire * bus = (TwoWire*) pltf->i2c;", "#endif", "", "PASCO2SerialIno cotwo(bus);", "", "uint8_t prodId, revId;", "", "void setup()", "{", "  Error_t err = cotwo.getDeviceID(prodId, revId);", "  if(pasco2::OK != err)", "  {", "    Serial.print(\"error: \");", "    Serial.println(err);", "  }", "", "  Serial.print(\"product id  : \");", "  Serial.println(prodId);", "}"]}
{"code": "\n#ifdef I2C_RTC\n// ---------------------------------------------------------------------------------\n// Set the system time from the RTC\nboolean I2C_RTC_Start()\n{\n  tmElements_t te;\n  time_t tm;\n\n  // Get current time\n  if ( RTC.read ( te ) )\n  {\n    tm = RTC.get();\n    setTime ( tm );\n    \n    #ifdef DEBUG\n    \tSerial << F(\"Real time clock detected \");\n    \tprintTime(tm);\n    \tSerial << F(\"Synched system time to   \");\n    \tprintTime(tm);\n    #endif\n    \n    return true;\n  }\n  else\n  {\n    \n    #ifdef DEBUG\n    \tif (RTC.chipPresent())\n    \t  Serial.println(F(\"Real time clock is stopped. Please run the SetTime example to initialize the time and begin running.\"));\n    \telse\n    \t  Serial.println(F(\"Real time clock read error. Please check the circuitry.\"));\n\n    \tSerial.print(F(\"Current system time is \"));\n    \tprintTime(now());\n    #endif\n    \n    return false;\n  }\n}\n\n#endif\n", "line": 34, "slice": ["#ifdef I2C_RTC", "boolean I2C_RTC_Start()", "{", "  tmElements_t te;", "  time_t tm;", "  if ( RTC.read ( te ) )", "  {", "    tm = RTC.get();", "    setTime ( tm );", "    return true;", "  }", "  else", "  {", "    return false;", "  }", "}", "#endif"]}
{"code": "#include <SPI.h>\n#include \"SH1106_SPI.h\"\n\n#define USE_FRAME_BUFFER\n\n#ifdef USE_FRAME_BUFFER\nSH1106_SPI_FB lcd;\n#else\nSH1106_SPI lcd;\n#endif\n\nvoid setup(void)\n{\n\tSerial.begin(9600);\n\tlcd.begin();\n\tlcd.print(F(\"Mobiiiina\"));\n#ifdef USE_FRAME_BUFFER\n\tlcd.renderAll();\n#endif\n}\n\nvoid loop(void) \n{\n\t\n}\n", "line": 16, "slice": ["#include \"SH1106_SPI.h\"", "#define USE_FRAME_BUFFER", "#ifdef USE_FRAME_BUFFER", "SH1106_SPI_FB lcd;", "#else", "SH1106_SPI lcd;", "#endif", "void setup(void)", "{", "\tlcd.begin();", "\tlcd.print(F(\"Mobiiiina\"));", "#ifdef USE_FRAME_BUFFER", "\tlcd.renderAll();", "#endif", "}"]}
{"code": "\nvoid sLog(String message, bool line) {\n  #ifdef DEBUG\n    line ? Serial.println(message) : Serial.print(message);\n  #endif\n}\n\n\nvoid initOutput () {\n  //Output ports, defined by default for nodemcu v2. Alter for others boards\n  //pinMode(16, OUTPUT); //D0\n  //pinMode(5, OUTPUT);  //D1\n  //pinMode(4, OUTPUT);  //D2\n  //pinMode(0, OUTPUT);  //D3\n  //pinMode(2, OUTPUT);  //D4\n  pinMode(14, OUTPUT); //D5\n  pinMode(12, OUTPUT); //D6\n  //pinMode(13, OUTPUT); //D7\n  //pinMode(15, OUTPUT); //D8\n  //pinMode(3, OUTPUT);  //D9\n  //pinMode(1, OUTPUT);  //D10\n}\n\nvoid initSerial() {\n  Serial.begin(115200);\n  sLog(\"\");\n}\n", "line": 4, "slice": ["void sLog(String message, bool line) {", "  #ifdef DEBUG", "    line ? Serial.println(message) : Serial.print(message);", "  #endif", "}", "", "void initSerial() {", "  Serial.begin(115200);", "  sLog(\"\");", "}"]}
{"code": "// scan i2c\n// Manferdelli\n\n#include <Wire.h>\n\nconst int measurementDelay= 5000;\ntypedef uint8_t byte;\nconst int maxAddress= 127;\n\nvoid setup() {\n  Serial.begin(9600);\n  Wire.begin();\n}\n\nvoid loop() {\n  byte err, address;\n  int num_devices = 0;\n\n  Serial.println(\"Scanning\");\n  for (address = 1; address < maxAddress; address++) {\n    Wire.beginTransmission(address);\n    err= Wire.endTransmission();\n    if (err == 0) {\n      num_devices++;\n      Serial.print(\"i2c device found at 0x\");\n      if (address < 16)\n        Serial.print(\"0\");\n      Serial.print(address, HEX);\n      Serial.println(\"\");\n    } else if (err == 4) {\n      Serial.print(\"i2c error at 0x\");\n      if (address < 16)\n        Serial.print(\"0\");\n      Serial.print(address, HEX);\n      Serial.println(\"\");\n    }\n  }\n\n  Serial.print(num_devices);\n  Serial.println(\" devices\");\n  delay(measurementDelay);\n}\n", "line": 25, "slice": ["#include <Wire.h>", "", "const int measurementDelay= 5000;", "typedef uint8_t byte;", "const int maxAddress= 127;", "", "void setup() {", "  Serial.begin(9600);", "  Wire.begin();", "}", "", "void loop() {", "  byte err, address;", "  int num_devices = 0;", "", "  for (address = 1; address < maxAddress; address++) {", "    Wire.beginTransmission(address);", "    err= Wire.endTransmission();", "    if (err == 0) {", "      num_devices++;", "    }", "  }", "", "  delay(measurementDelay);", "}"]}
{"code": "// Hall sensor\n// Manferdelli\n\ntypedef uint8_t byte;\nconst int dataPin= A0;\nconst int measurementDelay= 500;\n\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(dataPin, INPUT);\n}\n\nconst int zero_field= 527;\nvoid loop() {\n  int field_strength= analogRead(dataPin);\n  Serial.print(\"Field: \");\n  Serial.print(field_strength);\n  int calibrated_field = field_strength - zero_field;\n  Serial.print(\", calibrated field: \");\n  Serial.print(calibrated_field);\n  Serial.println(\"\");\n  delay(measurementDelay);\n}\n", "line": 17, "slice": ["typedef uint8_t byte;", "const int dataPin= A0;", "const int measurementDelay= 500;", "", "void setup() {", "  pinMode(dataPin, INPUT);", "}", "", "const int zero_field= 527;", "void loop() {", "  int field_strength= analogRead(dataPin);", "  int calibrated_field = field_strength - zero_field;", "  delay(measurementDelay);", "}"]}
{"code": "\nvoid processMIDI(void) {\n  byte type, channel, data1, data2, cable;\n\n  // fetch the MIDI message, defined by these 5 numbers (except SysEX)\n  //\n  type = usbMIDI.getType();       // which MIDI message, 128-255\n  data2 = usbMIDI.getData2();     // second data byte of message, 0-127  \n#ifdef DEBUG\n  channel = usbMIDI.getChannel(); // which MIDI channel, 1-16\n  data1 = usbMIDI.getData1();     // first data byte of message, 0-127\n  cable = usbMIDI.getCable();     // which virtual cable with MIDIx8, 0-7\n#endif\n\n  // print info about the message\n  //\n  switch (type) {\n\n    case usbMIDI.ControlChange: // 0xB0\n#ifdef DEBUG\n      Serial.print(\"Control Change, ch=\");\n      Serial.print(channel, DEC);\n      Serial.print(\", control=\");\n      Serial.print(data1, DEC);\n      Serial.print(\", value=\");\n      Serial.println(data2, DEC);\n#endif\n      blinkLEDS(data2 * 3);\n      break;\n  }\n\n}\n", "line": 21, "slice": ["void processMIDI(void) {", "  byte type, data2;", "", "  type = usbMIDI.getType();       // which MIDI message, 128-255", "  data2 = usbMIDI.getData2();     // second data byte of message, 0-127  ", "", "  switch (type) {", "", "    case usbMIDI.ControlChange: // 0xB0", "      blinkLEDS(data2 * 3);", "      break;", "  }", "", "}"]}
{"code": "//#define USE_BINARY\n\nconst int  sampleRate     = 250;\nconst long serialRate     = 2000000;\nconst int NWORDS          = 5;\nconst int WSIZE           = sizeof(uint16_t);\nconst int NBYTES          = NWORDS * WSIZE;\n\nvolatile bool pushData = false;\ntypedef union { uint16_t words[NWORDS]; uint8_t bytes[NBYTES]; } MODEL;\nMODEL m;\n\nIntervalTimer myTimer;\n\nvoid setup(void) {\n  for (int i = 0; i < NWORDS; i++) m.words[i] = i+1000;\n  pinMode(LED_BUILTIN, OUTPUT);\n  SerialUSB.begin(serialRate);\n  myTimer.begin(blinkLED, 1000000 / sampleRate);\n}\n\nvoid blinkLED(void) {\n  pushData = true;\n}\n\nvoid loop(void) {\n  static int counter = 0;\n  bool state = (counter++ >> 12) % 2;\n  digitalWrite(LED_BUILTIN, state ? HIGH : LOW);\n  if (pushData) {\n    pushData = false;\n    #ifdef USE_BINARY\n    SerialUSB.write(m.bytes, NBYTES);\n    #else\n    for (int i = 0; i < NWORDS; i++) {\n      if (i!=0) SerialUSB.print('\\t');\n      SerialUSB.print(m.words[i], DEC);\n    }\n    #endif\n    SerialUSB.write('\\n');\n  }\n}\n\n", "line": 36, "slice": ["const int NWORDS          = 5;", "typedef union { uint16_t words[NWORDS]; uint8_t bytes[NBYTES]; } MODEL;", "MODEL m;", "", "void setup(void) {", "  for (int i = 0; i < NWORDS; i++) m.words[i] = i+1000;", "}", "", "volatile bool pushData = false;", "", "void blinkLED(void) {", "  pushData = true;", "}", "", "void loop(void) {", "  if (pushData) {", "    pushData = false;", "    for (int i = 0; i < NWORDS; i++) {", "      if (i!=0) SerialUSB.print('\\t');", "      SerialUSB.print(m.words[i], DEC);", "    }", "    SerialUSB.write('\\n');", "  }", "}"]}
{"code": "#include <SPI.h>\n#include \"RF24.h\"\n\nRF24 radio(7, 8);\nbyte address[] = \"Aaron\"; // Six bytes incl. NUL\n\ntypedef struct {\n  float pressure;\n  float temperature;\n} prestemp_t;\n   \nvoid setup(void) {\n  Serial.begin(9600);\n  Serial.println(\"OHAI\");\n\n  radio.begin();\n  radio.setPALevel(RF24_PA_MAX);\n  radio.setDataRate(RF24_250KBPS);\n  radio.openReadingPipe(1, address);\n  radio.startListening();\n}\n\nvoid loop(void) {\n  prestemp_t data;\n\n  if(radio.available()){\n    radio.read(&data, 8);\n    Serial.print(\"P\");\n    Serial.print(data.pressure);\n    Serial.print(\"T\");\n    Serial.print(data.temperature);\n    Serial.println(\"\");\n  }\n}\n", "line": 28, "slice": ["#include <SPI.h>", "#include \"RF24.h\"", "", "RF24 radio(7, 8);", "byte address[] = \"Aaron\"; // Six bytes incl. NUL", "", "typedef struct {", "  float pressure;", "  float temperature;", "} prestemp_t;", "", "void setup(void) {", "  radio.begin();", "  radio.openReadingPipe(1, address);", "  radio.startListening();", "}", "", "void loop(void) {", "  prestemp_t data;", "", "  if(radio.available()){", "    radio.read(&data, 8);", "    Serial.print(\"P\");", "    Serial.print(data.pressure);", "    Serial.print(\"T\");", "    Serial.print(data.temperature);", "  }", "}"]}
{"code": "// Rotary encoder\n// Manferdelli\n\ntypedef uint8_t byte;\nconst int clockPin= 2;\nconst int dataPin= 4;\nconst int measurementDelay= 100;\n\nint position = -1;\nvoid encoder() {\n  if (digitalRead(clockPin) == digitalRead(dataPin))\n    position++;\n  else\n    position--;\n}\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(clockPin, INPUT);\n  pinMode(dataPin, INPUT);\n  digitalWrite(clockPin, HIGH);\n  digitalWrite(dataPin, HIGH);\n  attachInterrupt(0, encoder, CHANGE);\n}\n\nvoid loop() {\n  Serial.println(\"\");\n  Serial.print(\"Position: \");\n  Serial.print(position);\n  Serial.println(\"\");\n  delay(measurementDelay);\n}\n", "line": 28, "slice": ["typedef uint8_t byte;", "const int clockPin= 2;", "const int dataPin= 4;", "", "int position = -1;", "void encoder() {", "  if (digitalRead(clockPin) == digitalRead(dataPin))", "    position++;", "  else", "    position--;", "}", "", "void setup() {", "  pinMode(clockPin, INPUT);", "  pinMode(dataPin, INPUT);", "  attachInterrupt(0, encoder, CHANGE);", "}", "", "void loop() {", "  Serial.print(position);", "  delay(measurementDelay);", "}"]}
{"code": "#include <xZeroTouch.h>\n\nxZeroTouch ZeroTouch;\n\nstruct userData {\n  char  var1[32] = \"$!$SSID!0000000000000000000000!\";\n  char  var2[32] = \"$!$PSK1!0000000000000000000000!\";\n};\n\nstruct userData user;\n\nvoid setup() {\n  Serial.begin(BAUDSPEED);\n\n  pinMode(LED_RED, OUTPUT);\n  pinMode(LED_GREEN, OUTPUT);\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  digitalWrite(LED_RED, LOW);\n  digitalWrite(LED_GREEN, LOW);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  if (ZeroTouch.begin(user.var1, user.var2))\n  {\n    #ifdef DEBUG\n    Serial.println(\"WiFi connected!\");\n    Serial.print(\"IP address: \");\n    Serial.println(WiFi.localIP());\n    #endif\n    digitalWrite(LED_RED, LOW); \n    digitalWrite(LED_GREEN, HIGH); \n    digitalWrite(LED_BUILTIN, LOW);\n  }\n}\n\nvoid loop() {\n\n}\n", "line": 27, "slice": ["#include <xZeroTouch.h>", "", "xZeroTouch ZeroTouch;", "", "struct userData {", "  char  var1[32] = \"$!$SSID!0000000000000000000000!\";", "  char  var2[32] = \"$!$PSK1!0000000000000000000000!\";", "};", "", "struct userData user;", "", "if (ZeroTouch.begin(user.var1, user.var2))", "{", "  digitalWrite(LED_RED, LOW); ", "  digitalWrite(LED_GREEN, HIGH); ", "  digitalWrite(LED_BUILTIN, LOW);", "}"]}
{"code": "#if ENABLE_ETH\n\n\n\nbyte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };\n\n#ifdef STATIC_IP\nbyte ip[] = STATIC_IP;\n#endif\n\n\n\nvoid ethernetSetup() {\n  resetEthernet();\n}\n\nvoid ethernetLoop() {\n  sevDebug(0b10011110); // 'E'\n}\n\nvoid resetEthernet() {\n  Serial.print(F(\"Initializing Ethernet...\"));\n\n  \n  #ifdef STATIC_IP\n  Ethernet.begin(mac, ip); \n#else\n  Ethernet.begin(mac);\n#endif\n\n  Serial.println(F(\" OK.\"));\n\n}\n\n#else\n\nvoid ethernetSetup() { }\nvoid ethernetLoop() { }\n\n#endif\n", "line": 22, "slice": ["byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };", "", "#ifdef STATIC_IP", "byte ip[] = STATIC_IP;", "#endif", "", "void ethernetSetup() {", "  resetEthernet();", "}", "", "void resetEthernet() {", "  Serial.print(F(\"Initializing Ethernet...\"));", "", "  ", "  #ifdef STATIC_IP", "  Ethernet.begin(mac, ip); ", "#else", "  Ethernet.begin(mac);", "#endif", "", "  Serial.println(F(\" OK.\"));", "", "}"]}
{"code": "#include <FreeSixIMU.h>\n#include <FIMU_ADXL345.h>\n#include <FIMU_ITG3200.h>\n\n#define DEBUG\n#ifdef DEBUG\n#include \"DebugUtils.h\"\n#endif\n\n#include \"CommunicationUtils.h\"\n#include \"FreeSixIMU.h\"\n#include <Wire.h>\n\nint q[6]; //hold q values\n\n// Set the FreeIMU object\nFreeSixIMU my3IMU = FreeSixIMU();\n\nvoid setup() {\nSerial.begin(9600);\nWire.begin();\n\ndelay(5);\nmy3IMU.init();\ndelay(5);\n}\n\nvoid loop() { \n  \nmy3IMU.getRawValues(q);\n\nSerial.print(\"h\"); // send a header character\nSerial.print(\",\");\nSerial.print(q[0]);\nSerial.print(\",\");\nSerial.print(q[1]);\nSerial.print(\",\");  \nSerial.print(q[2]);\nSerial.print(\",\");\nSerial.print(q[3]);\nSerial.print(\",\");\nSerial.print(q[4]);\nSerial.print(\",\");  \nSerial.print(q[5]); \nSerial.print(\",\\n\");  \n\ndelay(62);\n}\n\n", "line": 32, "slice": ["#include <FreeSixIMU.h>", "", "int q[6]; //hold q values", "", "FreeSixIMU my3IMU = FreeSixIMU();", "", "void setup() {", "Wire.begin();", "", "my3IMU.init();", "}", "", "void loop() { ", "  ", "my3IMU.getRawValues(q);", "", "Serial.print(q[0]);", "Serial.print(\",\");", "Serial.print(q[1]);", "Serial.print(\",\");  ", "Serial.print(q[2]);", "Serial.print(\",\");", "Serial.print(q[3]);", "Serial.print(\",\");", "Serial.print(q[4]);", "Serial.print(\",\");  ", "Serial.print(q[5]); ", "Serial.print(\",\\n\");  ", "", "delay(62);", "}"]}
{"code": "#include <DHT.h>\n\n#include \"settings.h\"\n#include \"misc.hpp\"\n#include \"network.hpp\"\n\nDHT dht(DHT_PIN, DHT22);\n\nvoid setup() {\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  #ifdef DEBUG\n  Serial.begin(115200);\n  Serial.print(\"DEVICE ID: \");\n  Serial.println(DEVICE_ID);\n  #endif DEBUG\n\n  dht.begin();\n\n  if(!init_wifi())\n  {\n    blink_forever();\n  }\n  digitalWrite(LED_BUILTIN, HIGH);\n}\n\nvoid loop() {\n  float temperature = dht.readTemperature();\n  float humidity = dht.readHumidity();\n\n  if(isnan(temperature) || isnan(humidity))\n  {\n    #ifdef DEBUG\n    Serial.println(\"DHT values reading failed\");\n    #endif DEBUG\n    return;\n  }\n  #ifdef DEBUG\n  Serial.print(\"Temperature: \");\n  Serial.println(temperature);\n  Serial.print(\"Humidity: \");\n  Serial.println(humidity);\n  #endif DEBUG\n\n  send_data(temperature, humidity);\n  delay(LOOP_DELAY);\n}\n", "line": 14, "slice": ["#include <DHT.h>", "", "DHT dht(DHT_PIN, DHT22);", "", "void setup() {", "  dht.begin();", "}", "", "void loop() {", "  float temperature = dht.readTemperature();", "  float humidity = dht.readHumidity();", "", "  if(isnan(temperature) || isnan(humidity))", "  {", "    return;", "  }", "", "  send_data(temperature, humidity);", "}"]}
{"code": "// Analog Tester \n// analog testing tool for Arduino MEGA / UNO\n// Please View by Serial Plotter\n\n#ifdef ARDUINO_AVR_MEGA || ARDUINO_AVR_MEGA2560\n#define MAX 16\n#else\n#define MAX 6\n#endif\n#define SPACE 1000\n#define DELAY 5\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n  for(int i=0;i<MAX;i++){\n    int data = analogRead(i);\n    Serial.print(data+i*SPACE );\n    Serial.print(\",\");\n  }\n  Serial.println(\"*\");\n  delay(DELAY);\n  \n}\n", "line": 24, "slice": ["#ifdef ARDUINO_AVR_MEGA || ARDUINO_AVR_MEGA2560", "#define MAX 16", "#else", "#define MAX 6", "#endif", "#define SPACE 1000", "#define DELAY 5", "void loop() {", "  for(int i=0;i<MAX;i++){", "    int data = analogRead(i);", "    Serial.print(data+i*SPACE );", "    Serial.print(\",\");", "  }", "  Serial.println(\"*\");", "  delay(DELAY);", "}"]}
{"code": "#include \"ADS1115.h\"\n\n#ifdef SOFTWAREWIRE\n    #include <SoftwareWire.h>\n    SoftwareWire myWire(3, 2);\n    ADS1115<SoftwareWire> ads(myWire);//IIC\n#else\n    #include <Wire.h>\n    ADS1115<TwoWire> ads(Wire);//IIC\n#endif\n\nvoid setup(void) \n{\n    Serial.begin(115200);\n    while(!ads.begin(0x48)){\n        Serial.print(\"ads1115 init failed!!!\");\n        delay(1000);\n    }\n    //ads.begin(0x49) \n    //ads.begin(0x4A)\n    //ads.begin(0x4B)\n    ads.setOperateMode(ADS1115_MODE_SINGLE);   \n    ads.setOperateStaus(ADS1115_OS_SINGLE);\n    ads.setPGAGain(ADS1115_PGA_6_144); //MAX 6.144V \n    ads.setSampleRate(ADS1115_DR_860); //860 SPS\n    ads.setCompaMode(ADS1115_COMP_MODE_TRAD); \n    //Set Comparator mode to Traditional mode\n    ads.setCompaPolarity(ADS1115_COMP_POL_ACTVLOW); \n    //The ALERT pin keeping high when the ADC value beyond a threshold upper or lower value.\n    ads.setCompaLatching(ADS1115_COMP_LAT_LATCH);\n    //latching when the ADC value beyond a threshold upper or lower value. \n    ads.setCompaQueue(ADS1115_COMP_QUE_1CONV);\n    //comparing after 1 Conversion. \n    ads.setHighThreshold(0x4e20);\n    //set high threshold value to 0x4e20(0x0000 ~ 0x7fff)\n}\nvoid loop(void)\n{   \n    int16_t adc0;\n    adc0 = ads.getConversionResults(channel0); //P = AIN0, N = GND\n    Serial.print(\"AIN0: \"); Serial.println(adc0);\n    Serial.println(\" \");    \n    delay(1000);\n}", "line": 16, "slice": ["#include \"ADS1115.h\"", "", "#ifdef SOFTWAREWIRE", "    SoftwareWire myWire(3, 2);", "    ADS1115<SoftwareWire> ads(myWire);//IIC", "#else", "    ADS1115<TwoWire> ads(Wire);//IIC", "#endif", "", "void setup(void) ", "{", "    while(!ads.begin(0x48)){", "        delay(1000);", "    }", "    ads.setOperateMode(ADS1115_MODE_SINGLE);   ", "    ads.setOperateStaus(ADS1115_OS_SINGLE);", "    ads.setPGAGain(ADS1115_PGA_6_144); //MAX 6.144V ", "    ads.setSampleRate(ADS1115_DR_860); //860 SPS", "    ads.setCompaMode(ADS1115_COMP_MODE_TRAD); ", "    ads.setCompaPolarity(ADS1115_COMP_POL_ACTVLOW); ", "    ads.setCompaLatching(ADS1115_COMP_LAT_LATCH);", "    ads.setCompaQueue(ADS1115_COMP_QUE_1CONV);", "    ads.setHighThreshold(0x4e20);", "}", "", "void loop(void)", "{   ", "    int16_t adc0;", "    adc0 = ads.getConversionResults(channel0); //P = AIN0, N = GND", "}"]}
{"code": "#include <A6lib.h>\n\n#ifndef ESP8266\n#define D0 0\n#define D5 8\n#define D6 7\n#endif\n\n// Instantiate the library with TxPin, RxPin.\nA6lib A6l(D6, D5);\n\nvoid setup() {\n    Serial.begin(115200);\n\n    delay(1000);\n\n    // Power-cycle the module to reset it.\n    A6l.powerCycle(D0);\n    A6l.blockUntilReady(9600);\n}\n\nvoid loop() {\n    Serial.println(\"Checking call status...\");\n    callInfo cinfo = A6l.checkCallStatus();\n    Serial.println(\"Call status checked.\");\n\n    int sigStrength = A6l.getSignalStrength();\n    Serial.print(\"Signal strength percentage: \");\n    Serial.println(sigStrength);\n\n    delay(5000);\n\n    if (cinfo.number != NULL) {\n        if (cinfo.direction == DIR_INCOMING && cinfo.number == \"919999999999\") {\n            A6l.answer();\n        } else {\n            A6l.hangUp();\n        }\n        delay(1000);\n    } else {\n        Serial.println(\"No number yet.\");\n        delay(1000);\n    }\n}\n", "line": 28, "slice": ["#include <A6lib.h>", "", "#ifndef ESP8266", "#define D6 7", "#define D5 8", "#endif", "", "A6lib A6l(D6, D5);", "", "void setup() {", "    A6l.powerCycle(D0);", "    A6l.blockUntilReady(9600);", "}", "", "void loop() {", "    callInfo cinfo = A6l.checkCallStatus();", "", "    if (cinfo.number != NULL) {", "        if (cinfo.direction == DIR_INCOMING && cinfo.number == \"919999999999\") {", "            A6l.answer();", "        } else {", "            A6l.hangUp();", "        }", "    }", "}"]}
{"code": "void setup_i2c() {\n  Wire.begin(SLAVE_ADDRESS);\n  Wire.onReceive(receiveHandler);\n  Wire.onRequest(requestHandler);\n}\n\nvoid receiveHandler(int byteCount) {\n  char buf[byteCount-1];\n\n  inbound_t m;\n  if(Wire.available()) {\n    current_cmd = Wire.read();\n#ifdef SHOW_UI\n    screen.pos(7, 1, \"i2c>cmd=\");\n    Serial.print(current_cmd);\n#endif\n  }\n  outbound.cmd = current_cmd;\n  if (current_cmd == 5) { //speed + direction\n    em_brake_millis = now_millis + 1000;\n    while(Wire.available()) {\n      Wire.readBytes(buf, sizeof(buf));\n    }\n    memcpy(&m, buf, sizeof(m));\n    dm.setDirection(m.direction); \n    dm.setSpeed(m.speed);\n#ifdef SHOW_UI\n    screen.pos(8,1,\"i2c>speed=\");\n    Serial.print(m.speed);\n    Serial.print(\" direction=\");\n    Serial.print(m.direction);\n    Serial.print(\"                   \");\n#endif\n  }\n  else if (current_cmd == 9) { //toggleEnable\n    toggleEnable();\n    dm.setRunning(ENABLE_STATE); //toggleRunning\n  }\n}\n\nvoid requestHandler() {\n  outbound.cmd = current_cmd;\n  outbound.status = dm.getStatus();\n  outbound.current1 = dm.motor1->getCurrent();\n  outbound.current2 = dm.motor2->getCurrent();\n  Wire.write((char *)&outbound, sizeof(outbound));\n  // Wire.write(outbound.current1);\n  \n}", "line": 15, "slice": ["void setup_i2c() {", "  Wire.begin(SLAVE_ADDRESS);", "  Wire.onReceive(receiveHandler);", "  Wire.onRequest(requestHandler);", "}", "", "void receiveHandler(int byteCount) {", "  if(Wire.available()) {", "    current_cmd = Wire.read();", "  }", "  outbound.cmd = current_cmd;", "  if (current_cmd == 5) { //speed + direction", "    char buf[byteCount-1];", "    while(Wire.available()) {", "      Wire.readBytes(buf, sizeof(buf));", "    }", "    inbound_t m;", "    memcpy(&m, buf, sizeof(m));", "    dm.setDirection(m.direction); ", "    dm.setSpeed(m.speed);", "  }", "  else if (current_cmd == 9) { //toggleEnable", "    toggleEnable();", "    dm.setRunning(ENABLE_STATE); //toggleRunning", "  }", "}", "", "void requestHandler() {", "  outbound.cmd = current_cmd;", "  outbound.status = dm.getStatus();", "  outbound.current1 = dm.motor1->getCurrent();", "  outbound.current2 = dm.motor2->getCurrent();", "  Wire.write((char *)&outbound, sizeof(outbound));", "}"]}
{"code": "#ifndef _DEMO_BITMAP_INO_\r\n#define _DEMO_BITMAP_INO_\r\n\r\nvoid demoBitmap() \r\n{\r\n  // Display BMP as font\r\n  showDemoText(TN_BITMAP);\r\n\r\n  myOLED.setFont(BMP12864, false);\r\n\r\n  myOLED.print(0,0, \"0\");\r\n  OLEDshow();\r\n  delay(2000);\r\n  \r\n  myOLED.clr();\r\n  OLEDshow();\r\n  myOLED.print(0,0, \"1\");\r\n  OLEDshow();\r\n  delay(2000);\r\n}\r\n\r\n#endif\r\n", "line": 11, "slice": ["void demoBitmap() ", "{", "  myOLED.setFont(BMP12864, false);", "", "  myOLED.print(0,0, \"0\");", "  OLEDshow();", "  delay(2000);", "  ", "  myOLED.clr();", "  OLEDshow();", "}"]}
{"code": "#ifndef _DEMO_FONT_INO_\r\n#define _DEMO_FONT_INO_\r\n\r\nvoid demoFont() \r\n{\r\n  Serial.println(\"demoFont\");\r\n  showDemoText(TN_FONT);\r\n\r\n  myOLED.setFont(OLED_font6x8);\r\n  myOLED.printFlashMsg(0,0, tname[TN_FONT]);\r\n\r\n  myOLED.setFont(OLED_font6x8);\r\n  myOLED.printFlashMsg(0, 2, (char *) font_demo_small);\r\n  myOLED.print(0, 5, \"1234\");\r\n\r\n  myOLED.setFont(OLED_font8x16);\r\n  myOLED.printFlashMsg(0, 3, (char *) font_demo_large);\r\n\r\n  myOLED.setFont(OLED_fontNum);\r\n  myOLED.print(0, 6, \"1234\");\r\n\r\n  myOLED.setFont(OLED_fontBigNum);\r\n  myOLED.setInverse(true);\r\n  myOLED.print(64, 5, \"1234\");\r\n  myOLED.setInverse(false);\r\n\r\n  OLEDshow();\r\n  delay(3000);\r\n}\r\n\r\n#endif", "line": 14, "slice": ["void demoFont() ", "{", "  myOLED.setFont(OLED_fontBigNum);", "  myOLED.setInverse(true);", "  myOLED.print(64, 5, \"1234\");", "  myOLED.setInverse(false);", "", "  OLEDshow();", "  delay(3000);", "}"]}
{"code": "#include <ELECHOUSE_CC1101.h>\n//#define PRINT_BINARY\n\nunsigned long lastrx; \nunsigned long elapsed;\nbyte RX_buffer[61]={0};\nbyte sign_buffer[4]={0};\nbyte sizerx,i,flag;\n\nvoid setup()\n{\n  Serial.begin(115200);\n  delay(1000);\n  ELECHOUSE_cc1101.Init();\n  ELECHOUSE_cc1101.SetDataRate(3); // Needs to be the same in Tx and Rx\n  ELECHOUSE_cc1101.SetLogicalChannel(0); // Needs to be the same as receiver\n\tlastrx=millis();\n  ELECHOUSE_cc1101.SetReceive();\n}\n\n\nvoid loop() \n{\n  // Every packet, print out the whole line for rendering\n  if(ELECHOUSE_cc1101.CheckReceiveFlag())\n  {\n    lastrx = millis();\n    sizerx=ELECHOUSE_cc1101.ReceiveData(RX_buffer);\n\n#ifdef PRINT_BINARY\n    Serial.write(RX_buffer, sizerx);\n    Serial.write(sign_buffer, 4);\n#endif\n\n#ifndef PRINT_BINARY\n    for(i=0;i<sizerx;i++) {\n      Serial.print( RX_buffer[i], DEC);\n      Serial.print(\",\");\n    }\n    Serial.println();\n#endif\n\n    ELECHOUSE_cc1101.SetReceive();\n  }\n}\n\n\n\n", "line": 37, "slice": ["#include <ELECHOUSE_CC1101.h>", "byte RX_buffer[61]={0};", "byte sizerx,i;", "", "void setup()", "{", "  Serial.begin(115200);", "  ELECHOUSE_cc1101.Init();", "  ELECHOUSE_cc1101.SetReceive();", "}", "", "void loop() ", "{", "  if(ELECHOUSE_cc1101.CheckReceiveFlag())", "  {", "    sizerx=ELECHOUSE_cc1101.ReceiveData(RX_buffer);", "", "#ifndef PRINT_BINARY", "    for(i=0;i<sizerx;i++) {", "      Serial.print( RX_buffer[i], DEC);", "      Serial.print(\",\");", "    }", "    Serial.println();", "#endif", "", "    ELECHOUSE_cc1101.SetReceive();", "  }", "}"]}
{"code": "/// @dir pollee\n/// This can run on several nodes, and get data to the central \"poller\" node.\n// 2011-11-23 <jc@wippler.nl> http://opensource.org/licenses/mit-license.php\n//\n// Warning: this test will flood the radio band so nothing else gets through!\n//\n// To prepare for this test, you need to upload RF12demo to each pollee first,\n// and set its node ID, group (77) and band (868 MHz). Node IDs must be in the \n// range 1 .. NUM_NODES, as defined in poller.ino (all nodes must be present).\n\n#include <JeeLib.h>\n\ntypedef struct {\n  byte node;\n  long time;\n} Payload;\n\nPayload payload;\n\nvoid setup () {\n  Serial.begin(57600);\n  Serial.print(\"\\n[pollee]\");\n  // use the node ID previously stored in EEPROM by RF12demo\n  payload.node = rf12_config();\n}\n\nvoid loop () {\n  // wait for an incoming empty packet for us\n  if (rf12_recvDone() && rf12_crc == 0 && rf12_len == 0 && RF12_WANTS_ACK) {\n    // invent some data to send back\n    payload.time = millis();\n    // start transmission\n    rf12_sendStart(RF12_ACK_REPLY, &payload, sizeof payload);\n  }\n}\n", "line": 22, "slice": ["#include <JeeLib.h>", "", "typedef struct {", "  byte node;", "  long time;", "} Payload;", "", "Payload payload;", "", "void setup () {", "  payload.node = rf12_config();", "}", "", "void loop () {", "  if (rf12_recvDone() && rf12_crc == 0 && rf12_len == 0 && RF12_WANTS_ACK) {", "    payload.time = millis();", "    rf12_sendStart(RF12_ACK_REPLY, &payload, sizeof payload);", "  }", "}"]}
{"code": "\n#include <Arduino.h>\n#include <U8g2lib.h>\n\n#ifdef U8X8_HAVE_HW_SPI\n#include <SPI.h>\n#endif\n#ifdef U8X8_HAVE_HW_I2C\n#include <Wire.h>\n#endif\n/*\n  U8g2lib Example Overview:\n    Frame Buffer Examples: clearBuffer/sendBuffer. Fast, but may not work with all Arduino boards because of RAM consumption\n    Page Buffer Examples: firstPage/nextPage. Less RAM usage, should work with all Arduino boards.\n    U8x8 Text Only Example: No RAM usage, direct communication with display controller. No graphics, 8x8 Text only.\n    \n*/\n\n// Please UNCOMMENT one of the contructor lines below\n// U8g2 Contructor List (Frame Buffer)\nU8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);\n\nvoid setup(void) {\n  u8g2.begin();\n}\n\n\nvoid loop(void) {\n  int temp = 10;\n  u8g2.clearBuffer();         // clear the internal memory\n  u8g2.setFont(u8g2_font_courB10_tf); // choose a suitable font\n  //u8g2.drawStr(0,10,\"Hello World!\");  // write something to the internal memory\n  u8g2.drawStr(0,20,\"Temperature\");\n  u8g2.setFont(u8g2_font_courB24_tf);\n  u8g2.setCursor(40,50); //f\u00fcr .print braucht man setCursor\n  u8g2.print(temp);\n  u8g2.sendBuffer();          // transfer internal memory to the display\n  delay(1000);  \n}\n// + String(temp,0)\n", "line": 36, "slice": ["#include <Arduino.h>", "#include <U8g2lib.h>", "U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);", "void setup(void) {", "  u8g2.begin();", "}", "void loop(void) {", "  int temp = 10;", "  u8g2.setFont(u8g2_font_courB24_tf);", "  u8g2.setCursor(40,50); //f\u00fcr .print braucht man setCursor", "  u8g2.print(temp);", "}"]}
{"code": "#include <SPI.h>\r\n#include <LoRa.h>\r\n\r\n#ifdef ARDUINO_SAMD_MKRWAN1300\r\n#error \"This example is not compatible with the Arduino MKR WAN 1300 board!\"\r\n#endif\r\n\r\nvoid setup() {\r\n  Serial.begin(9600);\r\n  while (!Serial);\r\n\r\n  Serial.println(\"LoRa Receiver Callback\");\r\n\r\n  if (!LoRa.begin(915E6)) {\r\n    Serial.println(\"Starting LoRa failed!\");\r\n    while (1);\r\n  }\r\n\r\n  // Uncomment the next line to disable the default AGC and set LNA gain, values between 1 - 6 are supported\r\n  // LoRa.setGain(6);\r\n  \r\n  // register the receive callback\r\n  LoRa.onReceive(onReceive);\r\n\r\n  // put the radio into receive mode\r\n  LoRa.receive();\r\n}\r\n\r\nvoid loop() {\r\n  // do nothing\r\n}\r\n\r\nvoid onReceive(int packetSize) {\r\n  // received a packet\r\n  Serial.print(\"Received packet '\");\r\n\r\n  // read packet\r\n  for (int i = 0; i < packetSize; i++) {\r\n    Serial.print((char)LoRa.read());\r\n  }\r\n\r\n  // print RSSI of packet\r\n  Serial.print(\"' with RSSI \");\r\n  Serial.println(LoRa.packetRssi());\r\n}\r\n", "line": 35, "slice": ["#include <SPI.h>", "#include <LoRa.h>", "void setup() {", "  Serial.begin(9600);", "  while (!Serial);", "  if (!LoRa.begin(915E6)) {", "    Serial.println(\"Starting LoRa failed!\");", "    while (1);", "  }", "  LoRa.onReceive(onReceive);", "  LoRa.receive();", "}", "void onReceive(int packetSize) {", "  Serial.print(\"Received packet '\");", "  for (int i = 0; i < packetSize; i++) {", "    Serial.print((char)LoRa.read());", "  }", "  Serial.print(\"' with RSSI \");", "  Serial.println(LoRa.packetRssi());", "}"]}
{"code": "#include \"SomeSerial.h\"\n\nSomeSerial myHardOrUsbSerial(&Serial);\n\nSomeSerial mySoftSerial1(10, 11); // RX, TX\n\nSoftwareSerial mySoftwareSerial(8, 9); //RX, TX\nSomeSerial mySoftSerial2(&mySoftwareSerial);\n\nvoid setup() {\n  myHardOrUsbSerial.begin(115200);\n  mySoftSerial1.begin(19200);\n  mySoftSerial2.begin(9600);\n}\n\nvoid loop() {\n  testPrintWithSomeSerial(&myHardOrUsbSerial);\n  testPrintWithSomeSerial(&mySoftSerial1);\n  testPrintWithSomeSerial(&mySoftSerial2);\n  delay(1000);\n}\n\nvoid testPrintWithSomeSerial(SomeSerial* someSerial) {\n  someSerial->print(\"## start some serial at \");\n  someSerial->println(millis());\n  if (someSerial->isHardwareSerial()) {\n    someSerial->println(\"It is HardwareSerial\");\n    someSerial->thisHardwareSerial->println(\"Direct print to HardwareSerial\");\n\n  } else if (someSerial->isSerial_()) {\n    someSerial->println(\"It is USBAPI Serial_\");\n#ifdef __USB_SERIAL_AVAILABLE__\n    someSerial->thisSerial_->println(\"Direct print to USBAPI Serial_\");\n#endif\n\n  } else if (someSerial->isSoftwareSerial()) {\n    someSerial->println(\"It is SoftwareSerial\");\n    someSerial->thisSoftwareSerial->println(\"Direct print to SoftwareSerial\");\n  }\n  someSerial->println(\"## end some serial\");\n}\n\n", "line": 24, "slice": ["#include \"SomeSerial.h\"", "", "SomeSerial myHardOrUsbSerial(&Serial);", "", "SomeSerial mySoftSerial1(10, 11); // RX, TX", "", "SoftwareSerial mySoftwareSerial(8, 9); //RX, TX", "SomeSerial mySoftSerial2(&mySoftwareSerial);", "", "void setup() {", "  myHardOrUsbSerial.begin(115200);", "  mySoftSerial1.begin(19200);", "  mySoftSerial2.begin(9600);", "}", "", "void loop() {", "  testPrintWithSomeSerial(&myHardOrUsbSerial);", "  testPrintWithSomeSerial(&mySoftSerial1);", "  testPrintWithSomeSerial(&mySoftSerial2);", "}", "", "void testPrintWithSomeSerial(SomeSerial* someSerial) {", "  someSerial->print(\"## start some serial at \");", "  someSerial->println(millis());", "  if (someSerial->isHardwareSerial()) {", "    someSerial->println(\"It is HardwareSerial\");", "    someSerial->thisHardwareSerial->println(\"Direct print to HardwareSerial\");", "", "  } else if (someSerial->isSerial_()) {", "    someSerial->println(\"It is USBAPI Serial_\");", "#ifdef __USB_SERIAL_AVAILABLE__", "    someSerial->thisSerial_->println(\"Direct print to USBAPI Serial_\");", "#endif", "", "  } else if (someSerial->isSoftwareSerial()) {", "    someSerial->println(\"It is SoftwareSerial\");", "    someSerial->thisSoftwareSerial->println(\"Direct print to SoftwareSerial\");", "  }", "  someSerial->println(\"## end some serial\");", "}"]}
{"code": "#include <Wire.h>\n#include <Adafruit_Sensor.h>\n#include <Adafruit_LSM303.h>\n\nAdafruit_LSM303 lsm;\n\nvoid setup()\n{\n#ifndef ESP8266\n  while (!Serial);     // will pause Zero, Leonardo, etc until serial console opens\n#endif\n  Serial.begin(9600);\n\n  // Try to initialise and warn if we couldn't detect the chip\n  if (!lsm.begin())\n  {\n    Serial.println(\"Oops ... unable to initialize the LSM303. Check your wiring!\");\n    while (1);\n  }\n}\n\nvoid loop()\n{\n  lsm.read();\n  Serial.print(\"AX: \"); Serial.print((int)lsm.accelData.x); Serial.print(\" \");\n  Serial.print(\"AY: \"); Serial.print((int)lsm.accelData.y); Serial.print(\" \");\n  Serial.print(\"AZ: \"); Serial.print((int)lsm.accelData.z); Serial.print(\" \");\n  Serial.print(\"MX: \"); Serial.print((int)lsm.magData.x);   Serial.print(\" \");\n  Serial.print(\"MY: \"); Serial.print((int)lsm.magData.y);   Serial.print(\" \");\n  Serial.print(\"MZ: \"); Serial.println((int)lsm.magData.z); Serial.print(\" \");\n  delay(100);\n}\n", "line": 25, "slice": ["#include <Adafruit_Sensor.h>", "#include <Adafruit_LSM303.h>", "", "Adafruit_LSM303 lsm;", "", "void setup()", "{", "  if (!lsm.begin())", "  {", "    while (1);", "  }", "}", "", "void loop()", "{", "  lsm.read();", "  Serial.print(\"MZ: \"); Serial.println((int)lsm.magData.z); Serial.print(\" \");", "  delay(100);", "}"]}
{"code": "void vSupplyTest()\n{\n  uint16_t supplyVoltage = SW6C.readSupplyVoltage_mV();\n  if ((supplyVoltage > 3100 && supplyVoltage < 3400) || (supplyVoltage >4400 && supplyVoltage < 5200))\n  {\n    pass(0);\n  }\n  else\n  {\n    #ifdef PRINT_FAILURES\n     Serial.print(\"VSupply Fail: Measured: \");\n        Serial.println(supplyVoltage);\n    #endif\n    fail(0);\n  }\n}\n", "line": 11, "slice": ["void vSupplyTest()", "{", "  uint16_t supplyVoltage = SW6C.readSupplyVoltage_mV();", "  if ((supplyVoltage > 3100 && supplyVoltage < 3400) || (supplyVoltage >4400 && supplyVoltage < 5200))", "  {", "  }", "  else", "  {", "    Serial.print(\"VSupply Fail: Measured: \");", "    Serial.println(supplyVoltage);", "    fail(0);", "  }", "}"]}
{"code": "#define _Q(x) #x\n#define Q(x) _Q(x)\n\n#ifdef SECRET_WIFI_SSID\n  #define WIFI_SSID Q(SECRET_WIFI_SSID)\n#else\n  #define WIFI_SSID \"WIFI-SSID\"\n#endif\n\n#ifdef SECRET_WIFI_PW\n  #define WIFI_PW Q(SECRET_WIFI_PW)\n#else\n  #define WIFI_PW \"WIFI-PASSWORD\"\n#endif\n\nvoid initWiFi() {\n  WiFi.begin(WIFI_SSID, WIFI_PW);\n  Serial.print(\"WiFi \");\n  Serial.print(WIFI_SSID);\n  Serial.println(\" connecting\");\n\n  while (WiFi.status() != WL_CONNECTED) {\n    Serial.print(\".\");\n    delay(100);\n  }\n\n  Serial.println();\n  Serial.print(\"WiFi connected: \");\n  Serial.println(WiFi.localIP());\n}\n", "line": 18, "slice": ["#define _Q(x) #x", "#define Q(x) _Q(x)", "", "#ifdef SECRET_WIFI_SSID", "  #define WIFI_SSID Q(SECRET_WIFI_SSID)", "#else", "  #define WIFI_SSID \"WIFI-SSID\"", "#endif", "", "#ifdef SECRET_WIFI_PW", "  #define WIFI_PW Q(SECRET_WIFI_PW)", "#else", "  #define WIFI_PW \"WIFI-PASSWORD\"", "#endif", "", "void initWiFi() {", "  WiFi.begin(WIFI_SSID, WIFI_PW);", "  while (WiFi.status() != WL_CONNECTED) {", "    delay(100);", "  }", "  Serial.println(WiFi.localIP());", "}"]}
{"code": "/*\n * Uses ZCD output as interrupt to control triac AC duty cycle. Set above MAX_DIM_DUTY for 100% ON and below MIN_DIM_DUTY for completely OFF.\n * D2 = ZCD interrupt.\n * D3 = PWM interrupt for controlling duty cycle from ESP8266. Must be 1kHz frequency.\n * D5 = PWM output for controlling AC duty cycle to triac dimmer.\n */\n\n#include \"Dimmer.h\"\n#include \"PWM.hpp\"\n\n#define DEBUG // Comment to disable serial port\n\n#define MAX_DIM_DUTY 90\n#define MIN_DIM_DUTY 20\n\nPWM input_pwm(3);\nDimmer output_pwm(5);\n\nint input_pwm_value = 0;\n\nvoid setup() {\n  #ifdef DEBUG\n    Serial.begin(9600); // Serial for debug\n  #endif\n  input_pwm.begin(true);\n  output_pwm.begin();\n  randomSeed(analogRead(0)); // this line needed?\n}\n\nvoid loop() {\n  \n  input_pwm_value = input_pwm.getValue() / 10; // This assumes PWM frequency is 1kHz.\n  output_pwm.set(input_pwm_value);\n  delay(100);\n\n  #ifdef DEBUG\n    Serial.print(\"Value: \");\n    Serial.print(input_pwm_value);\n    Serial.print(\"\\tAGE: \");\n    Serial.println(input_pwm.getAge());\n  #endif\n\n}\n", "line": 37, "slice": ["#include \"Dimmer.h\"", "#include \"PWM.hpp\"", "", "PWM input_pwm(3);", "Dimmer output_pwm(5);", "", "int input_pwm_value = 0;", "", "void setup() {", "  input_pwm.begin(true);", "  output_pwm.begin();", "}", "", "void loop() {", "  ", "  input_pwm_value = input_pwm.getValue() / 10; // This assumes PWM frequency is 1kHz.", "  output_pwm.set(input_pwm_value);", "  delay(100);", "", "}"]}
{"code": "#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n#include <ESP8266WebServer.h>\n#include <DNSServer.h>\n\n#ifndef APSSID\n#define APSSID \"Group <GROUP_NUMBER>\"\n#endif\n\nconst char *ssid = APSSID;\nconst byte DNS_PORT = 53;\nIPAddress apIP(192, 168, 1, 1);\nDNSServer dnsServer;\n\nESP8266WebServer server(80);\nvoid handleRoot() {\n  server.send(200, \"text/html\", \"<h1>You are connected</h1>\");\n}\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n  Serial.print(\"Configuring access point...\");\n  \n  WiFi.mode(WIFI_AP);\n  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));\n  WiFi.softAP(ssid);\n\n  IPAddress myIP = WiFi.softAPIP();\n  Serial.print(\"AP IP address: \");\n  Serial.println(myIP);\n  server.on(\"/\", handleRoot);\n  server.begin();\n  Serial.println(\"HTTP server started\");\n  dnsServer.start(DNS_PORT, \"*\", apIP);\n}\n\nvoid loop() {\n  dnsServer.processNextRequest();\n  server.handleClient();\n}\n", "line": 24, "slice": ["#include <ESP8266WiFi.h>", "#include <WiFiClient.h>", "#include <ESP8266WebServer.h>", "#include <DNSServer.h>", "", "#ifndef APSSID", "#define APSSID \"Group <GROUP_NUMBER>\"", "#endif", "", "const char *ssid = APSSID;", "IPAddress apIP(192, 168, 1, 1);", "DNSServer dnsServer;", "", "ESP8266WebServer server(80);", "void handleRoot() {", "  server.send(200, \"text/html\", \"<h1>You are connected</h1>\");", "}", "", "void setup() {", "  WiFi.mode(WIFI_AP);", "  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));", "  WiFi.softAP(ssid);", "  server.on(\"/\", handleRoot);", "  server.begin();", "  dnsServer.start(DNS_PORT, \"*\", apIP);", "}", "", "void loop() {", "  server.handleClient();", "}"]}
{"code": "/*\n    Example: ReadData\n    Description: This example shows you how to read data from VariPass.\n*/\n\n#ifdef ESP8266\n    #include <ESP8266WiFi.h>\n#elif ESP32\n    #include <WiFi.h>\n#endif\n#include <VariPass.h>\n\n// WiFi settings\nconst char* ssid     = \"YourWifi\";  // Your WiFi SSID\nconst char* password = \"password\";  // Your WiFi password\n\n// You will need to register on VariPass (https://varipass.org) to proceed.\n// Once you have registered and confirmed your email, add a variable to your\n// Dashboard by pressing the plus sign. You will need the info available by \n// pressing the little chain icon on the newly added variable.\nString key    = \"Tl4g8ZQ0MFcBmQfO\"; // Your VariPass API key.\nString varid  = \"TUWmbh3U\";         // Your VariPass variable ID.\n\nvoid setup() {\n    Serial.begin(115200);\n\n    // Connect to the WiFi network.\n    WiFi.begin(ssid, password);\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.println(\"Successfully connected to the WiFi network!\");\n}\n\nvoid loop() {\n    // Variable which will be storing the result code.\n    int result;\n    \n    // Read variable value from VariPass.\n    int value = varipassReadInt(key, varid, &result);\n\n    // Check whether the reading was successful and handle accordingly.\n    if (result == VARIPASS_RESULT_SUCCESS)\n        Serial.println(\"Value successfully read! Value is: \" + String(value));\n    else\n        Serial.println(\"An error has occured reading the value! \" + varipassGetResultDescription(result));\n    \n    delay(2000);\n}\n", "line": 31, "slice": ["#include <VariPass.h>", "String key    = \"Tl4g8ZQ0MFcBmQfO\"; // Your VariPass API key.", "String varid  = \"TUWmbh3U\";         // Your VariPass variable ID.", "int result;", "int value = varipassReadInt(key, varid, &result);", "if (result == VARIPASS_RESULT_SUCCESS)", "    Serial.println(\"Value successfully read! Value is: \" + String(value));"]}
{"code": "// Example of using the non-volatile RAM storage on the DS1307.\n// You can write up to 56 bytes from address 0 to 55.\n// Data will be persisted as long as the DS1307 has battery power.\n\n#include \"RTClib.h\"\nRTC_DS1307 rtc;\n\n\nvoid setup () {\n\n#ifndef ESP8266\n  while (!Serial); // for Leonardo/Micro/Zero\n#endif\n  Serial.begin(9600);\n  rtc.begin();\n\n\n  // Routine\n  uint32_t activeUntilNvram= readUint32FromNvram(0);\n  Serial.print(\"active Until NVRAM = \");\n  Serial.println(activeUntilNvram);\n  uint32_t timeInitializedNvram = readUint32FromNvram(4);\n  Serial.print(\"time initialized NVRAM = \");\n  Serial.println(timeInitializedNvram);\n\n  setNvramToZero();\n  printAllNvram();\n\n  /*\n  int address = 0;\n  uint32_t key1 = 123456999; //0 to initialize, \n  storeUint32InNvram(key1, 0);\n\n  uint32_t key2 = readUint32FromNvram(address);\n  Serial.print(\"final result = \");\n  Serial.println(key2);\n  */\n}\n\nvoid loop () {\n  // Do nothing in the loop.\n}\n", "line": 20, "slice": ["#include \"RTClib.h\"", "RTC_DS1307 rtc;", "void setup () {", "  Serial.begin(9600);", "  rtc.begin();", "  uint32_t activeUntilNvram= readUint32FromNvram(0);", "  Serial.print(\"active Until NVRAM = \");", "  Serial.println(activeUntilNvram);", "  uint32_t timeInitializedNvram = readUint32FromNvram(4);", "  Serial.print(\"time initialized NVRAM = \");", "  Serial.println(timeInitializedNvram);", "  setNvramToZero();", "  printAllNvram();", "}"]}
{"code": "\nint addressRed = 0;\nint addressGreen = 1;\nint addressBlue = 2;\n\n\nvoid readRGBFromEEPROM() {\n  valueRed = EEPROM.read(addressRed);\n  valueGreen = EEPROM.read(addressGreen);\n  valueBlue = EEPROM.read(addressBlue);\n\n  #ifdef DEBUG\n  Serial.print(\"EEPROM values read: R: \");\n  Serial.print(valueRed);\n  Serial.print(\" G: \");\n  Serial.print(valueGreen);\n  Serial.print(\" B: \");\n  Serial.println(valueBlue);\n  #endif\n\n  writeRGBValues();\n}\n\n\nvoid writeRGBToEEPROM() {\n  EEPROM.write(addressRed, valueRed);\n  EEPROM.write(addressGreen, valueGreen);\n  EEPROM.write(addressBlue, valueBlue);  \n\n  #ifdef DEBUG\n  Serial.println(\"Values written to EEPROM\");\n  #endif\n}\n\n", "line": 13, "slice": ["int addressRed = 0;", "int addressGreen = 1;", "int addressBlue = 2;", "", "valueRed = EEPROM.read(addressRed);", "valueGreen = EEPROM.read(addressGreen);", "valueBlue = EEPROM.read(addressBlue);"]}
{"code": "#include <dtostrg.h>\n\ndouble number;\nchar buff[30];\n\n#ifdef DTOSTR_D\nvoid debug_print(char *msg, double d) {\n  Serial.print(msg);\n  Serial.println(d);\n}\n#endif\nvoid setup() {\n  // put your setup code here, to run once:\n\n  Serial.begin(115200);\n\n  number = 1234.567890123456789;\n  Serial.println();\n  Serial.println(\"10 3: 1234.567890123456789\");\n  Serial.println(\"10 3\");\n  Serial.println(dtostrg(number, 10, 3, buff));\n  Serial.println(dtostrg(number, -10, 3, buff));\n  Serial.println(dtostrg(-number, 10, 3, buff));\n  Serial.println(dtostrg(-number, -10, 3, buff));\n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n", "line": 7, "slice": ["double number;", "char buff[30];", "", "number = 1234.567890123456789;", "Serial.println(dtostrg(number, 10, 3, buff));"]}
{"code": "#include <GY21.h>\n\n#ifdef ESP8266\n#define SCL 14 // D5 ON NODEMCU\n#define SDA 12 // D6 ON NODEMCU\n#endif\n\n// Connect VIN to 3-5VDC\n// Connect GND to ground\n// Connect SCL to I2C clock pin\n// Connect SDA to I2C data pin\n\nGY21 sensor;\n\nvoid setup()\n{\n  Serial.begin(74880);\n  Serial.println(\"GY-21_test\");\n\n#ifdef ESP8266\n  Wire.begin(SDA, SCL);\n#else\n  Wire.begin();\n#endif\n\n}\n\nvoid loop()\n{\n  float temp = sensor.GY21_Temperature();\n  float hum = sensor.GY21_Humidity();\n\n  Serial.print(\"Temp: \");\n  Serial.print(temp);\n  Serial.print(\"\u00b0C    \");\n  Serial.print(\"Humidity: \");\n  Serial.print(hum);\n  Serial.println(\"\\%\");\n\n  delay(500);\n}\n", "line": 33, "slice": ["#include <GY21.h>", "", "GY21 sensor;", "", "void setup()", "{", "  Serial.begin(74880);", "}", "", "void loop()", "{", "  float temp = sensor.GY21_Temperature();", "  float hum = sensor.GY21_Humidity();", "", "  Serial.print(\"Temp: \");", "  Serial.print(temp);", "  Serial.print(\"\u00b0C    \");", "  Serial.print(\"Humidity: \");", "  Serial.print(hum);", "  Serial.println(\"\\%\");", "", "  delay(500);", "}"]}
{"code": "// demo: Use TX2RTS as digital input\n// adlerweb, 2017-06-24\n#include <SPI.h>\n#include \"mcp_can.h\"\n\n/*SAMD core*/\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n  #define SERIAL SerialUSB\n#else\n  #define SERIAL Serial\n#endif\n\n#define SPI_CS_PIN 10\n\nMCP_CAN CAN(SPI_CS_PIN); // Set CS pin\n\n\nvoid setup()\n{\n    SERIAL.begin(115200);\n\n    while (CAN_OK != CAN.begin(CAN_500KBPS))              // init can bus : baudrate = 500k\n    {\n        SERIAL.println(\"CAN init failed, retry\");\n        delay(100);\n    }\n    SERIAL.println(\"CAN init ok\");\n\n    if(CAN.mcpPinMode(MCP_TX2RTS, MCP_PIN_IN))\n    {\n        SERIAL.println(\"TX2RTS is now an input\");\n    }\n    else\n    {\n        SERIAL.println(\"Could not switch TX2RTS\");\n    }\n}\n\nvoid loop()\n{\n    SERIAL.print(\"TX2RTS is currently \");\n    SERIAL.println(CAN.mcpDigitalRead(MCP_TX2RTS));\n    delay(500);\n}\n\n/*********************************************************************************************************\n  END FILE\n*********************************************************************************************************/\n", "line": 41, "slice": ["#include <SPI.h>", "#include \"mcp_can.h\"", "#define SPI_CS_PIN 10", "MCP_CAN CAN(SPI_CS_PIN); // Set CS pin", "void setup()", "{", "    while (CAN_OK != CAN.begin(CAN_500KBPS))              // init can bus : baudrate = 500k", "    {", "        delay(100);", "    }", "    if(CAN.mcpPinMode(MCP_TX2RTS, MCP_PIN_IN))", "    {", "    }", "}", "void loop()", "{", "    SERIAL.println(CAN.mcpDigitalRead(MCP_TX2RTS));", "    delay(500);", "}"]}
{"code": "#ifdef ENABLE_INA\n\n#include <Adafruit_INA219.h>\nAdafruit_INA219 ina219;\n\nfloat shuntvoltage = 0;\nfloat busvoltage = 0;\nfloat current_mA = 0;\nfloat loadvoltage = 0;\n\nvoid ina_start() {\n  ina219.begin(); //verificar se tem retorno\n  Serial.println(F(\"<INA_START=DONE>\"));\n}\n\nvoid ina_cmd(uint8_t Settings) {\n  float shuntvoltage = 0;\n  float busvoltage = 0;\n  float current_mA = 0;\n  float loadvoltage = 0;\n  \n  shuntvoltage = ina219.getShuntVoltage_mV();\n  busvoltage = ina219.getBusVoltage_V();\n  current_mA = ina219.getCurrent_mA();\n  loadvoltage = busvoltage + (shuntvoltage / 1000);\n  \n  switch (Settings) {\n    case 0: //bvolt\n      Serial.print(F(\"<INA_VBUS=\")); Serial.print(busvoltage); Serial.println(F(\">\"));\n      break;\n    case 1: //svolt\n      Serial.print(F(\"<INA_VSHUNT=\")); Serial.print(shuntvoltage); Serial.println(F(\">\"));\n      break;\n    case 2: //lvolt\n      Serial.print(F(\"<INA_VLOAD=\")); Serial.print(loadvoltage); Serial.println(F(\">\"));\n      break;\n    case 3: //current\n      Serial.print(F(\"<INA_ALOAD=\")); Serial.print(current_mA); Serial.println(F(\">\"));\n      break;\n  }\n\n  \n}\n\n\n\n\n#endif\n\n\r\n", "line": 29, "slice": ["#include <Adafruit_INA219.h>", "Adafruit_INA219 ina219;", "float shuntvoltage = 0;", "float busvoltage = 0;", "float current_mA = 0;", "float loadvoltage = 0;", "void ina_cmd(uint8_t Settings) {", "  float shuntvoltage = 0;", "  float busvoltage = 0;", "  float current_mA = 0;", "  float loadvoltage = 0;", "  shuntvoltage = ina219.getShuntVoltage_mV();", "  busvoltage = ina219.getBusVoltage_V();", "  current_mA = ina219.getCurrent_mA();", "  loadvoltage = busvoltage + (shuntvoltage / 1000);", "  switch (Settings) {", "    case 2: //lvolt", "      Serial.print(F(\"<INA_VLOAD=\")); Serial.print(loadvoltage); Serial.println(F(\">\"));", "      break;", "  }", "}"]}
{"code": "#include <DNSServer.h>\n#ifdef ESP32\n#include <WiFi.h>\n#include <AsyncTCP.h>\n#elif defined(ESP8266)\n#include <ESP8266WiFi.h>\n#include <ESPAsyncTCP.h>\n#endif\n#include \"ESPAsyncWebServer.h\"\n\nDNSServer dnsServer;\nAsyncWebServer server(80);\n\nclass CaptiveRequestHandler : public AsyncWebHandler {\npublic:\n  CaptiveRequestHandler() {}\n  virtual ~CaptiveRequestHandler() {}\n\n  bool canHandle(AsyncWebServerRequest *request){\n    //request->addInterestingHeader(\"ANY\");\n    return true;\n  }\n\n  void handleRequest(AsyncWebServerRequest *request) {\n    AsyncResponseStream *response = request->beginResponseStream(\"text/html\");\n    response->print(\"<!DOCTYPE html><html><head><title>Captive Portal</title></head><body>\");\n    response->print(\"<p>This is out captive portal front page.</p>\");\n    response->printf(\"<p>You were trying to reach: http://%s%s</p>\", request->host().c_str(), request->url().c_str());\n    response->printf(\"<p>Try opening <a href='http://%s'>this link</a> instead</p>\", WiFi.softAPIP().toString().c_str());\n    response->print(\"</body></html>\");\n    request->send(response);\n  }\n};\n\n\nvoid setup(){\n  //your other setup stuff...\n  WiFi.softAP(\"esp-captive\");\n  dnsServer.start(53, \"*\", WiFi.softAPIP());\n  server.addHandler(new CaptiveRequestHandler()).setFilter(ON_AP_FILTER);//only when requested from AP\n  //more handlers...\n  server.begin();\n}\n\nvoid loop(){\n  dnsServer.processNextRequest();\n}\n", "line": 26, "slice": ["#include \"ESPAsyncWebServer.h\"", "AsyncWebServer server(80);", "class CaptiveRequestHandler : public AsyncWebHandler {", "public:", "  CaptiveRequestHandler() {}", "  void handleRequest(AsyncWebServerRequest *request) {", "    AsyncResponseStream *response = request->beginResponseStream(\"text/html\");", "    response->printf(\"<p>Try opening <a href='http://%s'>this link</a> instead</p>\", WiFi.softAPIP().toString().c_str());", "    request->send(response);", "  }", "};", "void setup(){", "  WiFi.softAP(\"esp-captive\");", "  server.addHandler(new CaptiveRequestHandler()).setFilter(ON_AP_FILTER);", "  server.begin();", "}"]}
{"code": "#include <ESP8266WiFi.h>\r\n\r\n#ifndef STASSID\r\n#define STASSID \"RED-VALAREZO1\"\r\n#define STAPSK  \"clavered1\"\r\n#endif\r\n\r\nvoid setup_wifi(){\r\n  delay(10);\r\n  Serial.println();\r\n  Serial.print(\"Conectando a \");\r\n  Serial.println(STASSID);\r\n  WiFi.begin(STASSID, STAPSK);\r\n  \r\n  while (WiFi.waitForConnectResult()  != WL_CONNECTED) {    // se espera indefinidamente hasta que exista coneccion\r\n    delay(500);\r\n    Serial.print(\".\");\r\n  }\r\n\r\n  Serial.println(\"\");\r\n  Serial.println(\"Conectado a red WiFi!\");\r\n  Serial.println(\"Direccion IP: \");\r\n  Serial.println(WiFi.localIP());\r\n}\r\n", "line": 11, "slice": ["#include <ESP8266WiFi.h>", "", "#ifndef STASSID", "#define STASSID \"RED-VALAREZO1\"", "#define STAPSK  \"clavered1\"", "#endif", "", "void setup_wifi(){", "  Serial.println(STASSID);", "  WiFi.begin(STASSID, STAPSK);", "  ", "  while (WiFi.waitForConnectResult()  != WL_CONNECTED) {    ", "    delay(500);", "    Serial.print(\".\");", "  }", "}"]}
{"code": "/**\n * Basic input/output test for MCP23016 expander.\n */\n\n#include <Arduino.h>\n#include \"CyMCP23016.h\"\n\n#ifdef ESP8266\n#define PIN_SDA 4\n#define PIN_SCL 5\n#endif\n\nCyMCP23016 mcp;\n\nvoid setup() {\n    Serial.begin(115200);\n\n#ifdef __AVR\n    // Init MCP23016 at the default address. This assumes we are running on\n    // an ATmel AVR-based arduino, like the Arduino Uno.\n    mcp.begin();\n#elif defined(ESP8266)\n    // Init MCP23016 at the default address. This assumes we are running\n    // on an Adafruit Huzzah ESP8266, which shares SDA and SCL with\n    // GPIOs 4 & 5, respectively.\n    mcp.begin(PIN_SDA, PIN_SCL);\n#endif\n\n    // Set Pin 0 on Port 0 as an output.\n    mcp.pinMode(MCP23016_PIN_GPIO0_0, OUTPUT);\n}\n\nvoid loop() {\n    delay(1000);\n\n    // Set the pin HIGH and read back the state.\n    mcp.digitalWrite(MCP23016_PIN_GPIO0_0, HIGH);\n    uint8_t val = mcp.digitalRead(MCP23016_PIN_GPIO0_0);\n    Serial.print(F(\"Pin 0.0 is \"));\n    Serial.println(val == HIGH ? \"HIGH\" : \"LOW\");\n\n    delay(1000);\n\n    // Set the pin LOW and read back the state.\n    mcp.digitalWrite(MCP23016_PIN_GPIO0_0, LOW);\n    val = mcp.digitalRead(MCP23016_PIN_GPIO0_0);\n    Serial.print(F(\"Pin 0.0 is \"));\n    Serial.println(val == HIGH ? \"HIGH\" : \"LOW\");\n}", "line": 39, "slice": ["#include \"CyMCP23016.h\"", "CyMCP23016 mcp;", "void setup() {", "    Serial.begin(115200);", "    mcp.begin();", "    mcp.pinMode(MCP23016_PIN_GPIO0_0, OUTPUT);", "}", "void loop() {", "    mcp.digitalWrite(MCP23016_PIN_GPIO0_0, LOW);", "    uint8_t val = mcp.digitalRead(MCP23016_PIN_GPIO0_0);", "    Serial.print(F(\"Pin 0.0 is \"));", "    Serial.println(val == HIGH ? \"HIGH\" : \"LOW\");", "}"]}
{"code": "\n#ifdef ENCODER_HARDWARE\n\n#include \"src/HardwareEncoder.h\"\n\n/*\n * For this project TIMER4 is used for PWM\n * Use TIMER2 and TIMER3 for encoders\n */\n\n// Create HardwareEncoder objects\nHardwareEncoder leftEncoder(QUAD_TIMER_2);\nHardwareEncoder rightEncoder(QUAD_TIMER_3);\n\nvoid setup() {\n  // Start up serial\n  Serial.begin(115200);\n\n  // Config encoders\n  leftEncoder.begin();\n  rightEncoder.begin();\n}\n\nvoid loop() {\n  // Print ticks\n  Serial.print(\"left/right: \"); \n  Serial.print(leftEncoder.sampleTicks());\n  Serial.print(\" \"); \n  Serial.print(rightEncoder.sampleTicks());\n  Serial.println();\n\n  // Type something into serial to reset ticks\n  while(Serial.available() > 0) {\n    // Flush buffer\n    Serial.read();\n\n    // Reset encoders\n    leftEncoder.resetTicks();\n    rightEncoder.resetTicks();\n  }\n}\n\n#endif\r\n", "line": 26, "slice": ["#ifdef ENCODER_HARDWARE", "", "#include \"src/HardwareEncoder.h\"", "", "HardwareEncoder leftEncoder(QUAD_TIMER_2);", "HardwareEncoder rightEncoder(QUAD_TIMER_3);", "", "void setup() {", "  leftEncoder.begin();", "  rightEncoder.begin();", "}", "", "void loop() {", "  while(Serial.available() > 0) {", "    Serial.read();", "", "    leftEncoder.resetTicks();", "    rightEncoder.resetTicks();", "  }", "}", "", "#endif"]}
{"code": "/* ----------------------------------------------\n  Modul Send HTTP request for Due\n  part of Arduino Mega Server project\n------------------------------------------------- */\n\n#ifdef SEND_FEATURE\n\n// target net settings\nbyte TARGET_IP[] = {192, 168, 2, 8};\nint TARGET_PORT = 80;\n\n// EthernetClient object\nEthernetClient tclient;\n\nvoid sendInit() {\n  initStart(\"Send\");\n  modulSend = MODUL_ENABLE;\n  initDone();\n}\n\nvoid sendHttpRequest(byte ip[], int port, EthernetClient cl) {\n  if (cl.connect(ip, port)) { \n    timeStamp();\n    Serial.print(\"Host \");\n    printIp(ip);\n    Serial.print(\" \");\n    Serial.println(buf);\n    cl.println(buf);\n    cl.print(\"Host: \");\n    sendIpClient(SELF_IP, cl);\n    cl.println();\n    cl.println(); \n    delay(100);\n    cl.stop();\n  } else {\n      timeStamp();\n      Serial.print(\"Host \");\n      printIp(ip);\n      Serial.print(\" not connected (\");\n      Serial.print(buf);\n      Serial.println(\")\");\n    }\n}\n\nvoid sendRequest(byte ip[], int port, char object[], int value, EthernetClient cl) {\n  sprintf(buf, \"GET /?%s=%d\", object, value); \n  sendHttpRequest(ip, port, cl);\n}\n\n#endif // SEND_FEATURE\r\n", "line": 24, "slice": ["byte TARGET_IP[] = {192, 168, 2, 8};", "int TARGET_PORT = 80;", "EthernetClient tclient;", "void sendHttpRequest(byte ip[], int port, EthernetClient cl) {", "  if (cl.connect(ip, port)) { ", "    cl.println(buf);", "    cl.print(\"Host: \");", "    sendIpClient(SELF_IP, cl);", "    cl.println();", "    cl.println(); ", "    delay(100);", "    cl.stop();", "  } else {", "      Serial.print(\"Host \");", "      printIp(ip);", "      Serial.print(\" not connected (\");", "      Serial.print(buf);", "      Serial.println(\")\");", "    }", "}", "void sendRequest(byte ip[], int port, char object[], int value, EthernetClient cl) {", "  sprintf(buf, \"GET /?%s=%d\", object, value); ", "  sendHttpRequest(ip, port, cl);", "}"]}
{"code": "/* Create a WiFi access point and provide a web server on it. */\n\n#include <ESP8266WiFi.h>\n#include <WiFiClient.h>\n\n#ifndef APSSID\n#define APSSID \"ESPap\"\n#define APPSK  \"thereisnospoon\"\n#endif\n\n/* Set these to your desired credentials. */\nconst char *ssid = APSSID;\nconst char *password = APPSK;\n\nIPAddress local_IP(192,168,0,1);\nIPAddress gateway(192,168,0,1);\nIPAddress subnet(255,255,255,0);\n\nvoid setup() {\n  delay(1000);\n  Serial.begin(115200);\n  Serial.println();\n  Serial.print(\"Configuring access point...\");\n  /* You can remove the password parameter if you want the AP to be open. */\n  WiFi.softAPConfig(local_IP, gateway, subnet);\n  WiFi.softAP(ssid, password);\n\n  IPAddress myIP = WiFi.softAPIP();\n  Serial.print(\"AP IP address: \");\n  Serial.println(myIP);\n}\n\nvoid loop() { }\n", "line": 23, "slice": ["#include <ESP8266WiFi.h>", "#include <WiFiClient.h>", "#define APSSID \"ESPap\"", "#define APPSK  \"thereisnospoon\"", "const char *ssid = APSSID;", "const char *password = APPSK;", "IPAddress local_IP(192,168,0,1);", "IPAddress gateway(192,168,0,1);", "IPAddress subnet(255,255,255,0);", "WiFi.softAPConfig(local_IP, gateway, subnet);", "WiFi.softAP(ssid, password);", "IPAddress myIP = WiFi.softAPIP();"]}
{"code": "// https://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/\n\n// defines pins numbers\nconst int trigPin = 9;\nconst int echoPin = 10;\n\n// defines variables\nlong duration;\nint distance;\n\nvoid setup() {\n  pinMode(trigPin, OUTPUT); // def trigPin pin as a OUTPUT\n  pinMode(echoPin, INPUT); // def echoPin pin as a INPUT\n  Serial.begin(9600); // Starts the serial communication\n}\n\n// the loop function runs over and over again forever\nvoid loop() {\n  digitalWrite(trigPin, LOW);\n  delayMicroseconds(2);\n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(10);\n  digitalWrite(trigPin, LOW);\n  duration = pulseIn(echoPin, HIGH);\n  distanceCm= duration*0.034/2;\n  distanceInch = duration*0.0133/2;\n  lcd.setCursor(0,0); // Sets the location at which subsequent text written to the LCD will be displayed\n  lcd.print(\"Distance: \"); // Prints string \"Distance\" on the LCD\n  lcd.print(distanceCm); // Prints the distance value from the sensor\n  lcd.print(\" cm\");\n  delay(10);\n  lcd.setCursor(0,1);\n  lcd.print(\"Distance: \");\n  lcd.print(distanceInch);\n  lcd.print(\" inch\");\n  delay(10);\n}", "line": 28, "slice": ["// defines pins numbers", "const int trigPin = 9;", "const int echoPin = 10;", "", "// defines variables", "long duration;", "", "void setup() {", "  pinMode(trigPin, OUTPUT); // def trigPin pin as a OUTPUT", "  pinMode(echoPin, INPUT); // def echoPin pin as a INPUT", "}", "", "void loop() {", "  digitalWrite(trigPin, LOW);", "  delayMicroseconds(2);", "  digitalWrite(trigPin, HIGH);", "  delayMicroseconds(10);", "  digitalWrite(trigPin, LOW);", "  duration = pulseIn(echoPin, HIGH);", "}"]}
{"code": "#include <Arduino.h>\n#include <U8g2lib.h>\n\n#include <OneWire.h>\n#include <DallasTemperature.h>\n\n// DS18b20\u6570\u636e\u8f93\u51fa\u811a\u63a5\u5f00\u53d1\u677f\u6570\u5b57\u5f15\u811a2\n#define ONE_WIRE_BUS 8\n\nOneWire oneWire(ONE_WIRE_BUS);\nDallasTemperature sensors(&oneWire);\n\n#ifdef U8X8_HAVE_HW_SPI\n#include <SPI.h>\n#endif\n#ifdef U8X8_HAVE_HW_I2C\n#include <Wire.h>\n#endif\n//\u5b9a\u4e49OLED\u8fde\u63a5\u7ebf\u5e8f\nU8G2_SSD1306_128X64_NONAME_F_4W_SW_SPI u8g2(U8G2_R0, /* clock=*/ 4, /* data=*/ 5, \n                                            /* cs=*/ 3, /* dc=*/ 7, /* reset=*/ 6);\n\nvoid setup(void) {\n  Serial.begin(9600);\n  sensors.begin(); //\u521d\u59cb\u5316DS18b20\n  u8g2.begin();  //\u521d\u59cb\u5316OLED\n  u8g2.enableUTF8Print();//\u6253\u5f00UTF8\u8f93\u51fa\n}\n\nvoid loop(void) {\n//    u8g2.setFont(u8g2_font_ncenB10_tr);//\u8bbe\u7f6e\u5b57\u4f53\n    u8g2.setFont(u8g2_font_wqy15_t_chinese1);\n    u8g2.setFontDirection(0);\n    u8g2.clearBuffer();          // \u6e05\u9664\u5185\u90e8\u7f13\u51b2\u533a\n    u8g2.setCursor(0, 40);\n    u8g2.print(\"\u73b0\u5728\u662f\uff1a\");\n    sensors.requestTemperatures(); // \u53d1\u9001\u547d\u4ee4\u83b7\u53d6\u6e29\u5ea6\n    float val = sensors.getTempCByIndex(0);//\u5c06\u83b7\u53d6\u5230\u7684\u6e29\u5ea6\u6570\u503c\u4fdd\u5b58\u5728\u53d8\u91cf\u4e2d\n    u8g2.setCursor(54,40);    //\u8bbe\u7f6e\u5149\u6807\u4f4d\u7f6e\n    u8g2.print(val);  //\u8f93\u51fa\u53d8\u91cf\u6570\u503c\n    u8g2.setCursor(99, 40);//\u8bbe\u7f6e\u5149\u6807\u4f4d\u7f6e\n    u8g2.println(\"\u5ea6\"); //\u5355\u4f4d\n    u8g2.sendBuffer(); // \u5c4f\u5e55\u8f93\u51fa\n    delay(100);\n}\n", "line": 36, "slice": ["#include <OneWire.h>", "#include <DallasTemperature.h>", "#define ONE_WIRE_BUS 8", "OneWire oneWire(ONE_WIRE_BUS);", "DallasTemperature sensors(&oneWire);", "void setup(void) {", "  sensors.begin(); //\u521d\u59cb\u5316DS18b20", "}", "void loop(void) {", "    sensors.requestTemperatures(); // \u53d1\u9001\u547d\u4ee4\u83b7\u53d6\u6e29\u5ea6", "    float val = sensors.getTempCByIndex(0);//\u5c06\u83b7\u53d6\u5230\u7684\u6e29\u5ea6\u6570\u503c\u4fdd\u5b58\u5728\u53d8\u91cf\u4e2d", "    u8g2.print(val);  //\u8f93\u51fa\u53d8\u91cf\u6570\u503c", "}"]}
{"code": "void initPins(){\n\n  pinMode(TRACKERBALL_XA, INPUT_PULLUP);\n  pinMode(TRACKERBALL_XB, INPUT_PULLUP);\n  \n  pinMode(TRACKERBALL_YA, INPUT_PULLUP);\n  pinMode(TRACKERBALL_YB, INPUT_PULLUP);\n\n\n  //pinMode(LCD4, OUTPUT);\n  //pinMode(LCD5, OUTPUT);\n  //pinMode(LCD6, OUTPUT);\n  //pinMode(LCD7, OUTPUT);\n  //pinMode(LCDRS, OUTPUT);\n  //pinMode(LCDEN, OUTPUT);\n  //pinMode(LCDRW, OUTPUT);\n  //pinMode(VIB1ENABLE, OUTPUT);\n  //pinMode(VIB1PWMPIN, OUTPUT);\n  //pinMode(VIB2ENABLE, OUTPUT);\n  //pinMode(VIB2PWMPIN, OUTPUT);\n\n  pinMode(USER_SWITCH_PIN, INPUT_PULLUP);\n  //pinMode(USER_LED_PIN, OUTPUT);\n  pinMode(SOUNDER_PIN, OUTPUT);\n  pinMode(PIN_PERIPHERAL_POWER_ENABLE, OUTPUT);\n  pinMode(PIN_5V_ENABLE, OUTPUT);\n  disablePeripheralPower();\n  disable5VPower();\n}\n\n/*\nvoid initLCD(){\n  // 7 pin connection (fast): normal LCD, single HD44780 controller\n  //LiquidCrystalFast(uint8_t rs, uint8_t rw, uint8_t enable, uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7) \n  #ifdef LCDOK\n    lcd.begin(nColumns, nRows);\n    // Print a message to the LCD.\n    \n    lcd.clear();\n    lcd.setCursor(0, 0); lcd.print(\"System Online!\");\n    //lcd.setCursor(0, 1);\n    //if(!USB) lcd.print(\"NO USB!\");\n    //else lcd.print(\"USB Connected!\");\n  #endif\n}*/\n", "line": 40, "slice": ["Without the context of line 40, it's impossible to determine which lines influence it. Please provide the line 40 or the context around it."]}
{"code": "#define DEBUG\n\nconst int LED_PIN = 8;\nString serialData = \"\";\nboolean isSerialDataReceived = false;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(LED_PIN, OUTPUT);\n}\n\n\nvoid loop() {\n  while (Serial.available()) {\n    char character = Serial.read();\n    if (character == '\\n' || character == '\\r') {\n      isSerialDataReceived = true;\n    } else {\n      serialData.concat(character);\n    }\n  }\n\n  if (isSerialDataReceived) {\n    if (serialData.length() > 0) {\n      #ifdef DEBUG\n        Serial.print(\"Received: \");\n        Serial.println(serialData);\n      #endif\n\n      //**** \u0412\u0430\u0448\u0430 \u043b\u043e\u0433\u0438\u043a\u0430 ****//\n      if (serialData == \"on\") {\n        digitalWrite(LED_PIN, HIGH);\n      }\n      if (serialData == \"off\") {\n        digitalWrite(LED_PIN, LOW);\n      }\n      //**** \u0414\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043b\u043e\u0433\u0438\u043a\u0438 :) ****//\n      \n    }\n    \n    isSerialDataReceived = false;\n    serialData = \"\";\n  }\n  \n\n  \n}\n", "line": 26, "slice": ["const int LED_PIN = 8;", "String serialData = \"\";", "boolean isSerialDataReceived = false;", "", "void loop() {", "  while (Serial.available()) {", "    char character = Serial.read();", "    if (character == '\\n' || character == '\\r') {", "      isSerialDataReceived = true;", "    } else {", "      serialData.concat(character);", "    }", "  }", "", "  if (isSerialDataReceived) {", "    if (serialData.length() > 0) {", "      if (serialData == \"on\") {", "        digitalWrite(LED_PIN, HIGH);", "      }", "      if (serialData == \"off\") {", "        digitalWrite(LED_PIN, LOW);", "      }", "    }", "    ", "    isSerialDataReceived = false;", "    serialData = \"\";", "  }", "}"]}
{"code": "#include <Adafruit_INA260.h>\n#ifdef __AVR__\n  #include <avr/power.h>\n#endif\n\n\nint delayval = 100; // delay for half a second\n\nAdafruit_INA260 ina260 = Adafruit_INA260();\n\nvoid setup() {\n  while (!Serial) { delay(10); }\n  Serial.begin(115200);\n  Serial.println(\"Adafruit INA260 tuning test\");\n\n  ina260.begin();\n\n  // set the number of samples to average\n  ina260.setAveragingCount(INA260_COUNT_16);\n  // set the time over which to measure the current and bus voltage\n  ina260.setVoltageConversionTime(INA260_TIME_140_us);\n  ina260.setCurrentConversionTime(INA260_TIME_140_us);\n}\n\nvoid loop() {\n  // measure and print current, voltage, and power to display on the serial plotter\n  Serial.print(ina260.readCurrent());\n  Serial.print(\" \");\n  Serial.print(ina260.readBusVoltage());\n  Serial.print(\" \");\n  Serial.print(ina260.readPower());\n  Serial.println();\n \n  delay(125); // Delay for a period of time (in milliseconds).\n}\n", "line": 27, "slice": ["#include <Adafruit_INA260.h>", "", "Adafruit_INA260 ina260 = Adafruit_INA260();", "", "void setup() {", "  ina260.begin();", "  ina260.setAveragingCount(INA260_COUNT_16);", "  ina260.setVoltageConversionTime(INA260_TIME_140_us);", "  ina260.setCurrentConversionTime(INA260_TIME_140_us);", "}", "", "void loop() {", "  Serial.print(ina260.readCurrent());", "  Serial.print(\" \");", "  Serial.print(ina260.readBusVoltage());", "  Serial.print(\" \");", "  Serial.print(ina260.readPower());", "  Serial.println();", "}"]}
{"code": "#ifdef ENABLE_MAG\n\n#include \"HMC5883L.h\"\n\nHMC5883L mag;\nint16_t mx, my, mz;\n\n\nvoid mag_start () {\n  mag.initialize();\n  Serial.print(F(\"<MAG_START=\"));\n  Serial.print(mag.testConnection());\n  Serial.println(F(\">\"));\n}\n\n\nvoid mag_cmd (uint8_t Setting) {\n  float heading;\n  switch (Setting) {\n    case 0:\n      mag.getHeading(&mx, &my, &mz);\n      heading = atan2(my, mx);\n      if(heading < 0) heading += 2 * M_PI;\n      Serial.print(F(\"<MAG_DATA=\"));\n      Serial.print(F(\",\")); Serial.print(mx);\n      Serial.print(F(\",\")); Serial.print(my);\n      Serial.print(F(\",\")); Serial.print(mz);\n      Serial.println(F(\">\"));\n      break;\n    case 1:\n      Serial.print(F(\"<MAG_HEAD=\")); \n      Serial.print(heading * 180/M_PI); \n      Serial.println(F(\">\"));\n      break;\n  }\n}\n\n\n\n#endif\r\n", "line": 11, "slice": ["HMC5883L mag;", "int16_t mx, my, mz;", "void mag_cmd (uint8_t Setting) {", "  float heading;", "  switch (Setting) {", "    case 0:", "      mag.getHeading(&mx, &my, &mz);", "      heading = atan2(my, mx);", "      if(heading < 0) heading += 2 * M_PI;", "      break;", "    case 1:", "      Serial.print(F(\"<MAG_HEAD=\")); ", "      Serial.print(heading * 180/M_PI); ", "      Serial.println(F(\">\"));", "      break;", "  }", "}"]}
{"code": "// --- SETUP\n\n\nvoid setup()\n{\n  #ifdef DEBUG_MODE\n    Serial.begin(9600);\n  #endif\n  delay(1000);\n  initializeInterface();\n  pinMode(LED_BUILTIN, OUTPUT);\n\n  //updates the RAM with the EEPROM values if there are correct\n  EEPROM.get(SETUP_COMPLETE_ADDRESS, setupComplete);\n  if (setupComplete == SETUP_COMPLETE_MAGIC_NUMBER) {    // if setupComplete == SETUP_COMPLETE_MAGIC_NUMBER, we consider the data in EEPROM is safe and complete, therefore we use it to initialize the RAM, otherwise we wait for UART communication\n    getDataEeprom();\n  } \n  else { // EEPROM was not (or incorrectly) initiated  \n    Serial.begin(9600); // Careful, when using the arduino pro mini 3.3V, the baud rate of the monitor must be set to 4800\n    while (!Serial) {\n    ; // wait for serial port to connect\n    }\n    Serial.print(\"FACTORY SETUP MODE\"); \n    // The command for the factory setup mode should be: #<SERIAL_NUMBER>;<STARTING_CODE>;<SECRET_KEY> \n    // For example #1234;123456789;a29ab82edc5fbbc41ec9530f6dac86b1\n  }\n  initializeTime();\n  initializeActivation();\n}\n", "line": 23, "slice": ["void setup()", "{", "  EEPROM.get(SETUP_COMPLETE_ADDRESS, setupComplete);", "  if (setupComplete == SETUP_COMPLETE_MAGIC_NUMBER) {    ", "    getDataEeprom();", "  } ", "  else {  ", "    Serial.begin(9600); ", "    while (!Serial) {", "    ; ", "    }", "    Serial.print(\"FACTORY SETUP MODE\"); ", "  }", "  initializeTime();", "  initializeActivation();", "}"]}
{"code": "#ifdef ENABLE_UV\n\n#include \"Adafruit_VEML6070.h\"\n\nAdafruit_VEML6070 uv = Adafruit_VEML6070();\n\nvoid uv_start(){\n  uv.begin(VEML6070_1_T);\n  Serial.println(F(\"<UV_START=TRUE><UV_ITIME=1>\"));\n}\n\nvoid uv_read(){\n  Serial.print(\"<UV_READ=\");\n  Serial.print(uv.readUV());\n  Serial.println(\">\");\n}\n\nvoid uv_set_it(){\n  uint8_t temp = value_string.toInt();\n  if (temp < 4) {\n    uv.begin(temp);\n    Serial.print(\"<UV_ITIME=\");\n    Serial.print(temp);\n    Serial.println(\">\");\n  }\n}\n#endif\r\n", "line": 13, "slice": ["#include \"Adafruit_VEML6070.h\"", "", "Adafruit_VEML6070 uv = Adafruit_VEML6070();", "", "void uv_start(){", "  uv.begin(VEML6070_1_T);", "}", "", "void uv_set_it(){", "  uint8_t temp = value_string.toInt();", "  if (temp < 4) {", "    uv.begin(temp);", "  }", "}"]}
{"code": "\n#include \"LTC2941.h\"\n\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n  #define SERIAL SerialUSB\n#else\n  #define SERIAL Serial\n#endif\n\nfloat coulomb = 0, mAh = 0, percent = 0;\n\nvoid setup(void)\n{\n    Wire.begin();\n    \n    SERIAL.begin(115200);\n    while(!SERIAL.available());\n    \n    SERIAL.println(\"LTC2941 Raw Data\");\n    \n    ltc2941.initialize();\n    ltc2941.setBatteryFullMAh(1050);\n}\n\nvoid loop(void)\n{\n    coulomb = ltc2941.getCoulombs();\n    mAh = ltc2941.getmAh();\n    percent = ltc2941.getPercent();\n    \n    SERIAL.print(coulomb);\n    SERIAL.print(\"mC,\");\n    SERIAL.print(mAh);\n    SERIAL.print(\"mAh,\");\n    SERIAL.print(percent);\n    SERIAL.print(\"%\");\n    \n    SERIAL.println();\n    \n    delay(1000);\n}\n", "line": 31, "slice": ["#include \"LTC2941.h\"", "", "float coulomb = 0, mAh = 0, percent = 0;", "", "void setup(void)", "{", "    ltc2941.initialize();", "    ltc2941.setBatteryFullMAh(1050);", "}", "", "void loop(void)", "{", "    coulomb = ltc2941.getCoulombs();", "    mAh = ltc2941.getmAh();", "    percent = ltc2941.getPercent();", "    ", "    SERIAL.print(coulomb);", "    SERIAL.print(\"mC,\");", "    SERIAL.print(mAh);", "    SERIAL.print(\"mAh,\");", "    SERIAL.print(percent);", "    SERIAL.print(\"%\");", "    ", "    delay(1000);", "}"]}
{"code": "#include <Arduino.h>\n\ntypedef volatile uint32_t REG32;\n#define pREG32 (REG32 *)\n\n#define DEVICE_ID_HIGH    (*(pREG32 (0x10000060)))\n#define DEVICE_ID_LOW     (*(pREG32 (0x10000064)))\n#define MAC_ADDRESS_HIGH  (*(pREG32 (0x100000a8)))\n#define MAC_ADDRESS_LOW   (*(pREG32 (0x100000a4)))\n\nvoid setup() {\n  Serial.begin(115200);\n\n  Serial.println(\"Bluefruit 52 HW Info\");\n  Serial.println(\"\");\n\n  // MAC Address\n  uint32_t addr_high = ((MAC_ADDRESS_HIGH) & 0x0000ffff) | 0x0000c000;\n  uint32_t addr_low  = MAC_ADDRESS_LOW;\n  Serial.print(\"MAC Address: \");\n  Serial.print((addr_high >> 8) & 0xFF, HEX); Serial.print(\":\");\n  Serial.print((addr_high) & 0xFF, HEX); Serial.print(\":\");\n  Serial.print((addr_low >> 24) & 0xFF, HEX); Serial.print(\":\");\n  Serial.print((addr_low >> 16) & 0xFF, HEX); Serial.print(\":\");\n  Serial.print((addr_low >> 8) & 0xFF, HEX); Serial.print(\":\");\n  Serial.print((addr_low) & 0xFF, HEX); Serial.println(\"\");\n\n  // Unique Device ID\n  Serial.print(\"Device ID  : \");\n  Serial.print(DEVICE_ID_HIGH, HEX);\n  Serial.println(DEVICE_ID_LOW, HEX);\n\n  // MCU Variant;\n  Serial.printf(\"MCU Variant: nRF%X 0x%08X\\n\",NRF_FICR->INFO.PART, NRF_FICR->INFO.VARIANT);\n  Serial.printf(\"Memory     : Flash = %d KB, RAM = %d KB\\n\", NRF_FICR->INFO.FLASH, NRF_FICR->INFO.RAM);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n", "line": 20, "slice": ["#include <Arduino.h>", "", "typedef volatile uint32_t REG32;", "#define pREG32 (REG32 *)", "", "#define DEVICE_ID_HIGH    (*(pREG32 (0x10000060)))", "#define DEVICE_ID_LOW     (*(pREG32 (0x10000064)))", "", "void setup() {", "  Serial.begin(115200);", "", "  // Unique Device ID", "  Serial.print(\"Device ID  : \");", "  Serial.print(DEVICE_ID_HIGH, HEX);", "  Serial.println(DEVICE_ID_LOW, HEX);", "}"]}
{"code": "#ifdef ESP8266\n#include <ESP8266WiFi.h>\n#else\n#include <WiFi.h>\n#endif\n\n#include \"myapp.h\"\n\n#define SSID  \"..\"  //  insert your wlan ssid\n#define PASS  \"..\"  //  .. and password\n#include <init.h>   //  and remove this line\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(SSID, PASS);\n  Serial.print(\"\\nConnecting\");\n  while (WiFi.status() != WL_CONNECTED) delay(500),Serial.print(\".\"); Serial.println(\"ok!\");\n  Serial.print(\"Connected as \");\n  Serial.println(WiFi.localIP());\n  myApp.begin();\n}\n\nvoid loop() {\n  myApp.loop();\n}\n", "line": 17, "slice": ["#define SSID  \"..\"  //  insert your wlan ssid", "#define PASS  \"..\"  //  .. and password", "WiFi.mode(WIFI_STA);", "WiFi.begin(SSID, PASS);", "while (WiFi.status() != WL_CONNECTED) delay(500),Serial.print(\".\"); Serial.println(\"ok!\");", "Serial.println(WiFi.localIP());"]}
{"code": "// Infrared\n// Manferdelli\n\n#include <IRremote.h>\n\ntypedef uint8_t byte;\nconst int dataPin= 12;\nconst int measurementDelay= 200;\n\nIRrecv receiver(dataPin);\n\nvoid setup() {\n  Serial.begin(9600);\n  receiver.enableIRIn();\n}\n\nvoid loop() {\n  decode_results results;\n\n  if (receiver.decode(&results)) {\n    Serial.print(results.value, HEX);\n    Serial.println(\"\");\n    receiver.resume();\n  }\n  delay(measurementDelay);\n}\n", "line": 21, "slice": ["#include <IRremote.h>", "", "typedef uint8_t byte;", "const int dataPin= 12;", "", "IRrecv receiver(dataPin);", "", "void setup() {", "  receiver.enableIRIn();", "}", "", "void loop() {", "  decode_results results;", "", "  if (receiver.decode(&results)) {", "    receiver.resume();", "  }", "  delay(measurementDelay);", "}"]}
{"code": "#include <Wire.h>\n#include <AS5600.h>\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n  #define SERIAL SerialUSB\n  #define SYS_VOL   3.3\n#else\n  #define SERIAL Serial\n  #define SYS_VOL   5\n#endif\n\nAMS_5600 ams5600;\n\nint ang, lang = 0;\n\nvoid setup()\n{\n  SERIAL.begin(115200);\n  Wire.begin();\n  SERIAL.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>> \");\n  if(ams5600.detectMagnet() == 0 ){\n    while(1){\n        if(ams5600.detectMagnet() == 1 ){\n            SERIAL.print(\"Current Magnitude: \");\n            SERIAL.println(ams5600.getMagnitude());\n            break;\n        }\n        else{\n            SERIAL.println(\"Can not detect magnet\");\n        }\n        delay(1000);\n    }\n  }\n  /* mode = 0, output PWM, mode = 1 output analog (full range from 0% to 100% between GND and VDD*/\n  ams5600.setOutPut(0);\n}\n\nvoid loop()\n{\n}\n", "line": 23, "slice": ["#include <Wire.h>", "#include <AS5600.h>", "", "AMS_5600 ams5600;", "", "void setup()", "{", "  SERIAL.begin(115200);", "  Wire.begin();", "  if(ams5600.detectMagnet() == 0 ){", "    while(1){", "        if(ams5600.detectMagnet() == 1 ){", "            SERIAL.println(ams5600.getMagnitude());", "            break;", "        }", "    }", "    delay(1000);", "  }", "  ams5600.setOutPut(0);", "}"]}
{"code": "#include <stdint.h>\n#include <string.h>\n\n#include \"miniforth.h\"\n#include \"getline.h\"\n#include \"helpers.h\"\n\nvoid setup()\n{\n    Serial.begin(115200); \n}\n\nvoid loop()\n{\n    static char line[MAX_LINE_LENGTH];\n    static int runBefore;\n    static Forth miniforth;\n\n    if (!runBefore) {\n        runBefore = 1;\n        miniforth.reset();\n    }\n    if (!get(line))\n        exit(0);\n    if (miniforth.parse_line(line, line + strlen(line)))\n        Serial.print(F(\" OK\\n\"));\n}\n\n#ifdef __NATIVE_BUILD__\n\nint main()\n{\n    setup();\n    while(1) {\n        loop();\n    }\n}\n\nSerialStub Serial;\n\n#endif\n", "line": 26, "slice": ["#include <stdint.h>", "#include <string.h>", "", "#include \"miniforth.h\"", "#include \"getline.h\"", "#include \"helpers.h\"", "", "void loop()", "{", "    static char line[MAX_LINE_LENGTH];", "    static Forth miniforth;", "", "    if (!get(line))", "        exit(0);", "    if (miniforth.parse_line(line, line + strlen(line)))", "        Serial.print(F(\" OK\\n\"));", "}", "", "#ifdef __NATIVE_BUILD__", "", "SerialStub Serial;", "", "#endif"]}
{"code": "#ifdef DEBUG\n#include \"animation.h\"\n\nvoid print_binary_number(unsigned char data) {\n\tfor(int i = 7; i >= 0; i--) Serial.print((data & (1 << i)) > 0, DEC);\n}\n\nvoid print_led_state() {\n\tfor(int row = 0; row < 8; row++) {\n\t\tfor(int col = 0; col < 8; col++) {\n\t\t\tSerial.print(led_state[row * 8 + col], DEC);\n\t\t\tSerial.print(\" \");\n\t\t}\n\t\tSerial.print(\"\\n\\r\");\n\t}\n}\n\nvoid print_padded_number(unsigned int number, const char* pad_with, unsigned int pad_count) {\n\tunsigned int pad_amount = pad_count - (int) log10(number);\n\tfor(int i = 0; i < pad_amount; i++) Serial.print(pad_with);\n\tSerial.print(number, DEC);\n}\n\nvoid print_ani_debug(unsigned int effect_index, unsigned long relative_time) {\n\tSerial.print(\"[\");\n\tprint_padded_number(effect_index + 1, \"0\", 2);\n\tSerial.print(\"] time \");\n\tprint_padded_number(relative_time / 1000, \" \", 2);\n\tSerial.print(\",\");\n\tprint_padded_number(relative_time % 1000, \"0\", 2);\n\tSerial.print(\"\\r\\n\");\n}\n\n#endif\n\n", "line": 5, "slice": ["void print_padded_number(unsigned int number, const char* pad_with, unsigned int pad_count) {", "\tunsigned int pad_amount = pad_count - (int) log10(number);", "\tfor(int i = 0; i < pad_amount; i++) Serial.print(pad_with);", "\tSerial.print(number, DEC);", "}", "", "void print_ani_debug(unsigned int effect_index, unsigned long relative_time) {", "\tSerial.print(\"[\");", "\tprint_padded_number(effect_index + 1, \"0\", 2);", "\tSerial.print(\"] time \");", "\tprint_padded_number(relative_time / 1000, \" \", 2);", "\tSerial.print(\",\");", "\tprint_padded_number(relative_time % 1000, \"0\", 2);", "\tSerial.print(\"\\r\\n\");", "}"]}
{"code": "#include \"FlexCAN.h\" // https://github.com/pawelsky/FlexCAN_Library\n\n// #define TEMP_MON\n#define STBY 28\n#define ID 0x631\n\nFlexCAN bus(500000, 0, 1, 1); // The last two parameters specify the use of pins 29 & 30 instead of 3 & 4\nCAN_message_t message;\nunsigned long lastWrite = 0;\nint counter = 0;\n\nvoid setup() {\n \tSerial.begin(9600);\n\tbus.begin();\n\n\t// standby pin needs to be set low if on TEMP_MON\n\t#ifdef TEMP_MON\n\t\tdigitalWrite(STBY, LOW);\n\t#endif\n\n    message.len = 8;\n    message.id = 0;\n}\n\nvoid loop() {\n\tif(millis() - lastWrite > 1000) {\n\t\tmessage.buf[0] = counter++;\n\t\t\n        if(bus.write(message)) {\n\t\t\tSerial.print(\"sent message: \");\n\t\t\tSerial.println(counter);\n\t\t} else\n\t\t\tSerial.println(\"message failed to send\");\n        \n        lastWrite = millis();\n\t}\n}\n\n// void writeBuffer(int )\n\n// most likely not going to use this function\nvoid writeBuffer(String text) {\n\tfor(int i = 0; i < message.len; i++)\n\t\tmessage.buf[i] = text.charAt(i);\n}", "line": 30, "slice": ["#include \"FlexCAN.h\" // https://github.com/pawelsky/FlexCAN_Library", "#define ID 0x631", "FlexCAN bus(500000, 0, 1, 1); // The last two parameters specify the use of pins 29 & 30 instead of 3 & 4", "CAN_message_t message;", "unsigned long lastWrite = 0;", "int counter = 0;", "void setup() {", " \tSerial.begin(9600);", "\tbus.begin();", "    message.len = 8;", "    message.id = 0;", "}", "void loop() {", "\tif(millis() - lastWrite > 1000) {", "\t\tmessage.buf[0] = counter++;", "        if(bus.write(message)) {", "\t\t\tSerial.print(\"sent message: \");", "\t\t\tSerial.println(counter);", "\t\t} else", "\t\t\tSerial.println(\"message failed to send\");", "        lastWrite = millis();", "\t}", "}"]}
{"code": "#include \"DFRobot_GDL.h\"\n#if defined(ESP8266)||defined(ESP32)\n#define DC  D3\n#define CS  D4\n#define RST D5\n#define BL  D6\n#else\n#define DC  2 \n#define CS  3\n#define RST 5\n#define BL  6\n#endif\n\nDFRobot_ST7789_240x240_HW_SPI screen(DC,CS,RST,BL);\nuint16_t unicodeArray[0];\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  screen.begin();\n  screen.fillScreen(COLOR_RGB565_BLACK);\n  screen.setFont(&SIMKAIFont48pt);\n  screen.setTextColor(COLOR_RGB565_RED);\n  screen.print(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\");\n  #ifdef ARDUINO_SAM_ZERO\n  SerialUSB.print(\"\u4f4d\u56fe\u6570\u636e(\u5b57\u8282): \");\n  SerialUSB.println(sizeof(SIMKAIFont48ptBitmaps));\n  SerialUSB.print(\"\u5b57\u5f62\u6570\u636e(\u5b57\u8282): \");\n  SerialUSB.println(sizeof(SIMKAIFont48ptGlyphs));\n  SerialUSB.print(\"SIMKAIFont48pt\u7ed3\u6784\u4f53\u53d8\u91cf\u5360\u7528\u7684\u5b57\u8282\u4e3a:  \");\n  SerialUSB.println(sizeof(SIMKAIFont48pt));\n  SerialUSB.print(\"unicode:  \");\n  SerialUSB.println(sizeof(unicodeArray));\n  #else\n  Serial.print(\"\u4f4d\u56fe\u6570\u636e(\u5b57\u8282): \");\n  Serial.println(sizeof(SIMKAIFont48ptBitmaps));\n  Serial.print(\"\u5b57\u5f62\u6570\u636e(\u5b57\u8282): \");\n  Serial.println(sizeof(SIMKAIFont48ptGlyphs));\n  Serial.print(\"SIMKAIFont48pt\u7ed3\u6784\u4f53\u53d8\u91cf\u5360\u7528\u7684\u5b57\u8282\u4e3a:  \");\n  Serial.println(sizeof(SIMKAIFont48pt));\n  Serial.print(\"unicode:  \");\n  Serial.println(sizeof(unicodeArray));\n  #endif\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n", "line": 23, "slice": ["#include \"DFRobot_GDL.h\"", "#if defined(ESP8266)||defined(ESP32)", "#define DC  D3", "#define CS  D4", "#define RST D5", "#define BL  D6", "#else", "#define DC  2 ", "#define CS  3", "#define RST 5", "#define BL  6", "#endif", "DFRobot_ST7789_240x240_HW_SPI screen(DC,CS,RST,BL);", "void setup() {", "  Serial.begin(115200);", "  screen.begin();", "  screen.setFont(&SIMKAIFont48pt);", "  screen.setTextColor(COLOR_RGB565_RED);", "  screen.print(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\");", "  #ifdef ARDUINO_SAM_ZERO", "  SerialUSB.print(\"\u4f4d\u56fe\u6570\u636e(\u5b57\u8282): \");", "  SerialUSB.println(sizeof(SIMKAIFont48ptBitmaps));", "  SerialUSB.print(\"\u5b57\u5f62\u6570\u636e(\u5b57\u8282): \");", "  SerialUSB.println(sizeof(SIMKAIFont48ptGlyphs));", "  SerialUSB.print(\"SIMKAIFont48pt\u7ed3\u6784\u4f53\u53d8\u91cf\u5360\u7528\u7684\u5b57\u8282\u4e3a:  \");", "  SerialUSB.println(sizeof(SIMKAIFont48pt));", "  SerialUSB.print(\"unicode:  \");", "  SerialUSB.println(sizeof(unicodeArray));", "  #else", "  Serial.print(\"\u4f4d\u56fe\u6570\u636e(\u5b57\u8282): \");", "  Serial.println(sizeof(SIMKAIFont48ptBitmaps));", "  Serial.print(\"\u5b57\u5f62\u6570\u636e(\u5b57\u8282): \");", "  Serial.println(sizeof(SIMKAIFont48ptGlyphs));", "  Serial.print(\"SIMKAIFont48pt\u7ed3\u6784\u4f53\u53d8\u91cf\u5360\u7528\u7684\u5b57\u8282\u4e3a:  \");", "  Serial.println(sizeof(SIMKAIFont48pt));", "  Serial.print(\"unicode:  \");", "  Serial.println(sizeof(unicodeArray));", "  #endif", "}"]}
{"code": "#include \"DHTesp.h\"\n\n#ifdef ESP32\n#pragma message(THIS EXAMPLE IS FOR ESP8266 ONLY!)\n#error Select ESP8266 board.\n#endif\n\nDHTesp dht;\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial.println();\n  Serial.println(\"Status\\tHumidity (%)\\tTemperature (C)\\t(F)\\tHeatIndex (C)\\t(F)\");\n  String thisBoard= ARDUINO_BOARD;\n  Serial.println(thisBoard);\n\n  // Autodetect is not working reliable, don't use the following line\n  // dht.setup(17);\n  // use this instead: \n  dht.setup(17, DHTesp::DHT22); // Connect DHT sensor to GPIO 17\n}\n\nvoid loop()\n{\n  delay(dht.getMinimumSamplingPeriod());\n\n  float humidity = dht.getHumidity();\n  float temperature = dht.getTemperature();\n\n  Serial.print(dht.getStatusString());\n  Serial.print(\"\\t\");\n  Serial.print(humidity, 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(temperature, 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(dht.toFahrenheit(temperature), 1);\n  Serial.print(\"\\t\\t\");\n  Serial.print(dht.computeHeatIndex(temperature, humidity, false), 1);\n  Serial.print(\"\\t\\t\");\n  Serial.println(dht.computeHeatIndex(dht.toFahrenheit(temperature), humidity, true), 1);\n  delay(2000);\n}\n\n", "line": 31, "slice": ["#include \"DHTesp.h\"", "", "DHTesp dht;", "", "void setup()", "{", "  dht.setup(17, DHTesp::DHT22); // Connect DHT sensor to GPIO 17", "}", "", "void loop()", "{", "  delay(dht.getMinimumSamplingPeriod());", "", "  float humidity = dht.getHumidity();", "  float temperature = dht.getTemperature();", "", "  Serial.println(dht.computeHeatIndex(dht.toFahrenheit(temperature), humidity, true), 1);", "  delay(2000);", "}"]}
{"code": "// https://github.com/pcbreflux/espressif/blob/master/esp32/arduino/sketchbook/ESP32_int_temp_sensor/ESP32_int_temp_sensor.ino\n\n#include <time.h>\n#include <sys/time.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nuint8_t temprature_sens_read();\n//uint8_t g_phyFuns;\n\n#ifdef __cplusplus\n}\n#endif\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  tzset();\n}\n\nuint8_t temp_farenheit;\nfloat temp_celsius;\nchar strftime_buf[64];\ntime_t now = 0;\nstruct tm timeinfo;\nchar buf[256];\n\n\nvoid loop() {\n  localtime_r(&now, &timeinfo);\n  strftime(strftime_buf, sizeof(strftime_buf), \"%c\", &timeinfo);\n  sprintf(buf, \"scan start %02d:%02d:%02d \", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);\n  Serial.print (buf);\n\n  temp_farenheit = temprature_sens_read();\n  temp_celsius = ( temp_farenheit - 32 ) / 1.8;\n  Serial.print(\"Temp onBoard \");\n  Serial.print(temp_farenheit);\n  Serial.print(\"\u00b0F \");\n  Serial.print(temp_celsius);\n  Serial.println(\"\u00b0C\");\n  delay(1000);\n  now++;\n}\n", "line": 39, "slice": ["uint8_t temprature_sens_read();", "", "uint8_t temp_farenheit;", "float temp_celsius;", "", "void loop() {", "  temp_farenheit = temprature_sens_read();", "  temp_celsius = ( temp_farenheit - 32 ) / 1.8;", "  Serial.print(\"Temp onBoard \");", "  Serial.print(temp_farenheit);", "  Serial.print(\"\u00b0F \");", "  Serial.print(temp_celsius);", "  Serial.println(\"\u00b0C\");", "  delay(1000);", "  now++;", "}"]}
{"code": "#define debug\n\n#define ntc_thresh 450\n#define pwm_min 30\n#define sensor_avg_weight 30\n\n#define ntc_pin A0\n#define pot_pin A1\n#define pwm_pin 3\n#define turbo_pin 2\n\nint ntc = ntc_thresh;\n\nvoid setup() {\n#ifdef debug\n  Serial.begin(115200);\n#endif\n  pinMode(ntc_pin, INPUT);\n  pinMode(pot_pin, INPUT);\n  pinMode(pwm_pin, OUTPUT);\n  pinMode(turbo_pin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  ntc = ((ntc * (sensor_avg_weight - 1)) + analogRead(ntc_pin)) / sensor_avg_weight;\n\n#ifdef debug\n  Serial.print(\"pwm: \");\n  Serial.print(map(analogRead(pot_pin), 1023, 0, pwm_min, 255));\n  Serial.print(\" ntc: \");\n  Serial.println(ntc);\n#endif\n\n  if (ntc < ntc_thresh) {\n    if (!digitalRead(turbo_pin)) analogWrite(pwm_pin, 255);\n    else analogWrite(pwm_pin, map(analogRead(pot_pin), 1023, 0, pwm_min, 255));\n  }\n  else {\n    analogWrite(pwm_pin, 0);\n  }\n\n  delay(1000);\n}\n", "line": 28, "slice": ["#define ntc_thresh 450", "#define pwm_min 30", "#define sensor_avg_weight 30", "", "#define ntc_pin A0", "#define pot_pin A1", "#define pwm_pin 3", "#define turbo_pin 2", "", "int ntc = ntc_thresh;", "", "void setup() {", "  pinMode(ntc_pin, INPUT);", "  pinMode(pot_pin, INPUT);", "  pinMode(pwm_pin, OUTPUT);", "  pinMode(turbo_pin, INPUT_PULLUP);", "}", "", "void loop() {", "  ntc = ((ntc * (sensor_avg_weight - 1)) + analogRead(ntc_pin)) / sensor_avg_weight;", "", "  if (ntc < ntc_thresh) {", "    if (!digitalRead(turbo_pin)) analogWrite(pwm_pin, 255);", "    else analogWrite(pwm_pin, map(analogRead(pot_pin), 1023, 0, pwm_min, 255));", "  }", "  else {", "    analogWrite(pwm_pin, 0);", "  }", "}"]}
{"code": "#ifdef ESP32\r\n  #include <WiFi.h>\r\n#else\r\n  #include <ESP8266WiFi.h>\r\n#endif\r\n\r\nvoid setup(){\r\n  Serial.begin(115200);\r\n  Serial.println();\r\n  Serial.print(\"ESP Board MAC Address:  \");\r\n  Serial.println(WiFi.macAddress());\r\n}\r\n \r\nvoid loop(){\r\n\r\n}\r\n", "line": 10, "slice": ["#ifdef ESP32", "  #include <WiFi.h>", "#else", "  #include <ESP8266WiFi.h>", "#endif", "", "void setup(){", "  Serial.begin(115200);", "  Serial.println();", "  Serial.print(\"ESP Board MAC Address:  \");", "  Serial.println(WiFi.macAddress());", "}"]}
{"code": "// EspDebug - Test sketch for ESP8266 module\n\n#include \"Arduino.h\"\n\n// Emulate Serial1 on pins 7/6 if not present\n#ifndef HAVE_HWSERIAL1\n#include \"SoftwareSerial.h\"\nSoftwareSerial Serial1(6, 7); // RX, TX\n#endif\n\nvoid setup()\n{\n  Serial.begin(115200); // serial port used for debugging\n  Serial1.begin(9600);  // your ESP's baud rate might be different\n}\n \nvoid loop()\n{\n  if(Serial1.available())  // check if the ESP is sending a message\n  {\n    while(Serial1.available())\n    {\n      int c = Serial1.read(); // read the next character\n      Serial.write((char)c);  // writes data to the serial monitor\n    }\n  }\n \n  if(Serial.available())\n  {\n    // wait to let all the input command in the serial buffer\n    delay(10);\n\n    // read the input command in a string\n    String cmd = \"\";\n    while(Serial.available())\n    {\n      cmd += (char)Serial.read();\n    }\n\n    // print the command and send it to the ESP\n    Serial.println();\n    Serial.print(\">>>> \");\n    Serial.println(cmd);\n\n    // send the read character to the ESP\n    Serial1.print(cmd);\n  }\n}\n", "line": 42, "slice": ["#include \"Arduino.h\"", "", "#ifndef HAVE_HWSERIAL1", "#include \"SoftwareSerial.h\"", "SoftwareSerial Serial1(6, 7); // RX, TX", "#endif", "", "void setup()", "{", "  Serial1.begin(9600);  // your ESP's baud rate might be different", "}", "", "void loop()", "{", "  if(Serial.available())", "  {", "    String cmd = \"\";", "    while(Serial.available())", "    {", "      cmd += (char)Serial.read();", "    }", "", "    Serial1.print(cmd);", "  }", "}"]}
{"code": "/* ************************************************************************\n * ***            Super Graphing Data Logger - EEPROM config            ***\n * ************************************************************************\n * Everett Robinson, December 2016.\n *\n * The following extra non standard libraries were used, and will need to be\n * added to the libraries folder:\n * - EEPROMAnything: http://playground.arduino.cc/Code/EEPROMWriteAnything\n *\n * This sketch helps you set the values in EEPROM which are necessary for\n * Super Graphing Data Logger. It should only need the be run once before\n * the first time you set up SGDL, or in the unlikely event that the EEPROM\n * becomes corrupted.\n *\n * Please ensure that the values in configuration config are appropriate for\n * your project before uncommenting the EEPROM_writeAnything(0, config); line.\n *\n */\n\n#include <EEPROM.h>\n#include \"EEPROMAnything.h\"\n\ntypedef struct{\n    unsigned long newFileTime;\n    char workingFilename[19];\n  } configuration;\n\n//This is a one off thing, so everything is in setup\nvoid setup(){\n  Serial.begin(9600);\n  \n  //Create the config struct to write to EEPROM, change values as appropriate\n  //Make sure your filename is not too long for the workingFilename char array \n  configuration config = {1356912000L,\"/data/25-12-12.csv\"};\n  //Write the values to the EEPROM\n  EEPROM_writeAnything(0, config);       //Uncomment when you're sure everything is correct\n  configuration config2;                   //Create a second config struct for verification\n  EEPROM_readAnything(0,config2);\n  Serial.print(\"The value read from EEPROM for newFileTime is: \");\n  Serial.println(config2.newFileTime);\n  Serial.print(\"The value read from EEPROM for workingFilename is: \");\n  Serial.println(config2.workingFilename);\n  Serial.println(\"If those values are correct then everything went as planned. Otherwise,\");\n  Serial.println(\"please double check that the values declared for the struct config are\");\n  Serial.println(\"correct and that that EEPROM_writeAnything line is uncommented.\");\n}\n\n\nvoid loop(){\n}\n", "line": 39, "slice": ["#include <EEPROM.h>", "#include \"EEPROMAnything.h\"", "typedef struct{", "    unsigned long newFileTime;", "    char workingFilename[19];", "  } configuration;", "void setup(){", "  configuration config = {1356912000L,\"/data/25-12-12.csv\"};", "  EEPROM_writeAnything(0, config);", "  configuration config2;", "  EEPROM_readAnything(0,config2);", "  Serial.println(config2.workingFilename);", "}"]}
{"code": "/*\n  RGB Sensor Project\n  ==================\n\n  This is the header file for RGB sensor liblary.\n  Programmed By: Yasiru Senerath karunanayaka 190301H\n*/\n\n#ifndef DisplayFunctions\n#define DisplayFunctions\n\n#include <Arduino.h>\n\n\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n\n//Set the LCD address to 0x27 for a 16 column and 2 row display\n\nLiquidCrystal_I2C  lcd(0x27, 16, 2);\n\nvoid initLCD(){\n  lcd,begin();\n  lcd.backlight();\n}\n\nvoid printMsg(String message, int delay_ = 1000){\n  lcd.clear();\n  lcd.print(message);\n  delay(delay_);\n  lcd.clear();\n}\n", "line": 29, "slice": ["#include <LiquidCrystal_I2C.h>", "", "LiquidCrystal_I2C  lcd(0x27, 16, 2);", "", "void printMsg(String message, int delay_ = 1000){", "  lcd.clear();", "  lcd.print(message);", "  delay(delay_);", "  lcd.clear();", "}"]}
{"code": "#include <mButton.h>\n\nmButton\tpulsante;\n\n\nvoid setup() {\n\tSerial.begin(9600);\n\tSerial.println(\"TEST\");\n  //PIN: 7\n  //DBOUNCE TIME: 25 ms\n  //POINT OF FUNCTION RELEASE: typedef void(*funRelease)(long long tmp_pressButton);: void release(long long t)\n  //POINT OF FUNCTION PRESS:typedef void(*funPress)();: void press()\n  //POINT OF FUNCTION CHANGE STATE BUTTON typedef void(*funPress)(): NULL\n  //In questo caso l'oggetto bottone non sar\u00e0 reattivo al cambio di stato, ma solo alla pressione press e al rilascio release del pulsante\n\tpulsante.begin(7, 25, true, release, press, NULL);\n  //Inizializzazione dell'oggetto pulsante\n}\n\nvoid press() {\n\tSerial.print(millis());\n\tSerial.println(\" - Pulsante Premuto\");\n\n}\n\nvoid release(long long t) {\n\tSerial.print(millis());\n\tSerial.print(\" - Rilasciato. Pressione durata: \");\n\tSerial.print (((int)t)/1000);\n\tSerial.println(\" sec\");\n}\n\n\n// the loop function runs over and over again until power down or reset\nvoid loop() {\n\t//funzione di controllo degli stati del pulsante\n  pulsante.checkStateButton();\n}\n", "line": 20, "slice": ["#include <mButton.h>", "", "mButton\tpulsante;", "", "void setup() {", "\tpulsante.begin(7, 25, true, release, press, NULL);", "}", "", "void press() {", "\tSerial.print(millis());", "\tSerial.println(\" - Pulsante Premuto\");", "}", "", "void release(long long t) {", "\tSerial.print(millis());", "\tSerial.print(\" - Rilasciato. Pressione durata: \");", "\tSerial.print (((int)t)/1000);", "\tSerial.println(\" sec\");", "}", "", "void loop() {", "  pulsante.checkStateButton();", "}"]}
{"code": "#include <MB4052.h>\n\nstatic const uint8_t adc_CS = 5;\t// connected to MB4052 SC pin\nstatic const uint8_t adc_CLK = 3;\t// connected to MB4052 ADC CLK pin\nstatic const uint8_t adc_DATA = 4;\t// connected to MB4052 Data out pin\nstatic const uint8_t adc_C0 = 6;\t// connected to MB4052 C0 pin\nstatic const uint8_t adc_C1 = 7;\t// connected to MB4052 C1 pin\n\ntypedef MB4052<adc_CS, adc_CLK, adc_DATA, adc_C0, adc_C1> adc;\n\nvoid setup()\n{\n\tadc::begin();\n\n\tpinMode(LED_BUILTIN, OUTPUT);\n\tdigitalWrite(LED_BUILTIN, LOW);\n\n\tSerial.begin(9600);\n\tdelay(100);\n\tSerial.println(\"Starting ADC on 4 channels...\");\n\tSerial.flush();\n}\n\nvoid loop() \n{\n\tint av[4];\n\t\n\tdigitalWrite(LED_BUILTIN, HIGH);\n\n\tfor (int i = 0; i < 4; i++)\n\t\tav[i] = adc::readADC(i);\n\n\tSerial.print(0);\n\tSerial.print(\", \");\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tSerial.print(av[i]);\n\t\tSerial.print(\", \");\n\t}\n\tSerial.println(255);\n\n\tdigitalWrite(LED_BUILTIN, LOW);\n\tdelay(100);\n}\n\n", "line": 33, "slice": ["#include <MB4052.h>", "", "static const uint8_t adc_CS = 5;\t// connected to MB4052 SC pin", "static const uint8_t adc_CLK = 3;\t// connected to MB4052 ADC CLK pin", "static const uint8_t adc_DATA = 4;\t// connected to MB4052 Data out pin", "static const uint8_t adc_C0 = 6;\t// connected to MB4052 C0 pin", "static const uint8_t adc_C1 = 7;\t// connected to MB4052 C1 pin", "", "typedef MB4052<adc_CS, adc_CLK, adc_DATA, adc_C0, adc_C1> adc;", "", "void setup()", "{", "\tadc::begin();", "}", "", "void loop() ", "{", "\tint av[4];", "", "\tfor (int i = 0; i < 4; i++)", "\t\tav[i] = adc::readADC(i);", "", "\tfor (int i = 0; i < 4; i++)", "\t{", "\t\tSerial.print(av[i]);", "\t\tSerial.print(\", \");", "\t}", "\tSerial.println(255);", "}"]}
{"code": "// SPI is needed by the RF24 library. It includes it, but for some reason the ide doesn't compile that,\n// so we have to include it here.\n#include <SPI.h>\n#include <RF24.h>\n#include \"setup_printf.h\"\n#include \"common.h\"\n\n// Function declarations.\nint init_radio();\n\n// Local data.\n// Radio is using pins 9 and 10, as well as SPI pins.\nRF24 radio(9, 10);\ntemp_reading last_reading;\n\nvoid setup() {\n  Serial.begin(57600);\n  init_radio();\n  setup_printf();\n  memset(&last_reading, 0, PAYLOAD_SIZE);\n}\n\nvoid loop() {\n  while (!radio.available()) {\n    // Wait for data to be available.\n  }\n  radio.read(&last_reading, PAYLOAD_SIZE);\n  // for whatever reason, printf didn't work here.\n  Serial.print(last_reading.idx);\n  Serial.print(',');\n  Serial.print(last_reading.loop_start);\n  Serial.print(',');\n  Serial.print(last_reading.tx_millis);\n  Serial.print(',');\n  Serial.println(last_reading.temp);\n  // Wait for the next transmission (minus 100 so we don't miss it because of timing imprecisions)\n  delay(INTERVAL - 100);\n}\n\n// Function definitions.\nint init_radio() {\n  radio.begin();\n  radio.setPayloadSize(PAYLOAD_SIZE);\n  radio.openReadingPipe(1, PIPE);\n  radio.startListening();\n#ifdef __DEBUG // from common.h\n  radio.printDetails();\n#endif\n}\n\n", "line": 29, "slice": ["#include <RF24.h>", "#include \"common.h\"", "RF24 radio(9, 10);", "temp_reading last_reading;", "init_radio();", "memset(&last_reading, 0, PAYLOAD_SIZE);", "while (!radio.available()) {", "}", "radio.read(&last_reading, PAYLOAD_SIZE);", "delay(INTERVAL - 100);", "int init_radio() {", "  radio.begin();", "  radio.setPayloadSize(PAYLOAD_SIZE);", "  radio.openReadingPipe(1, PIPE);", "  radio.startListening();", "#ifdef __DEBUG // from common.h", "  radio.printDetails();", "#endif", "}"]}
{"code": "#include <AsyncDelay.h>\n#include <SoftWire.h>\n#include <AS3935.h>\n\n#ifdef JTD\n#include <DisableJTAG.h>\n#endif\n\nSoftWire i2c(14, 17);\nuint8_t addr = 0x03;\n\nvoid setup(void)\n{\n#ifdef JTD\n  disableJTAG();\n#endif\n  \n  Serial.begin(9600);\n  i2c.setTimeout_ms(40);\n  i2c.setDelay_us(2);\n  i2c.begin();\n  i2c.stop();\n  \n  for (uint8_t reg = 0; reg < 0x10; ++reg) {\n    delay(50);\n    i2c.start(addr, SoftWire::writeMode);\n    i2c.write(reg);\n    i2c.repeatedStart(addr, SoftWire::readMode);\n    //i2c.stop();\n    //i2c.start(addr, SoftWire::readMode);\n    uint8_t val;\n    i2c.readThenNack(val);\n    i2c.stop();\n    \n    Serial.print(\"Reg: 0x\");\n    Serial.print(reg, HEX);\n    Serial.print(\": 0x\");\n    Serial.println(val, HEX);\n    Serial.flush();\n  }\n  \n}\n\nvoid loop(void)\n{\n  ;\n}\n", "line": 35, "slice": ["#include <SoftWire.h>", "", "SoftWire i2c(14, 17);", "uint8_t addr = 0x03;", "", "void setup(void)", "{", "  i2c.setTimeout_ms(40);", "  i2c.setDelay_us(2);", "  i2c.begin();", "  i2c.stop();", "  ", "  for (uint8_t reg = 0; reg < 0x10; ++reg) {", "    i2c.start(addr, SoftWire::writeMode);", "    i2c.write(reg);", "    i2c.repeatedStart(addr, SoftWire::readMode);", "    uint8_t val;", "    i2c.readThenNack(val);", "    i2c.stop();", "  }", "  ", "}"]}
{"code": "\n//#define DEBUG //uncomment fo debugging\n#ifdef DEBUG\n#else\n  #define TWOBYTES // uncomment to use the two bytes through USB sending protocol\n#endif\n\n#define BUFFER_SIZE 16 //abs max per transmission 32Bytes, 16 for this\n#define ANALOG_PIN 0 \n#define DELTA 500 - 7 //usenconds, 2000Hz, error time\n\n\nunsigned int value = 0;\nunsigned long int t1, t2;\n\nunsigned long int delta_t = DELTA;\nunsigned long int delta_t2 = DELTA;\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  delay(1000);\n  #ifdef DEBUG\n    Serial.println(\"Starting RX\");\n  #endif\n\n}\n\nvoid loop() {\n  t1 = micros();\n   value = analogRead(ANALOG_PIN);\n    #ifdef TWOBYTES\n      Serial.write(value/256);\n      Serial.write(value%256);\n    #endif\n   t2 = micros() - t1;\n   #ifdef DEBUG\n      Serial.print(\"Value: \");\n      Serial.print(value);\n      Serial.print(\" || Waiting Time: \");\n      Serial.print(DELTA - t2);\n      Serial.print(\"us \");\n      Serial.print(\" || t2: \");\n      Serial.print(t2);\n      Serial.println(\"us\");\n   #endif\n   delayMicroseconds(DELTA - t2);\n  \n}\n", "line": 38, "slice": ["#define TWOBYTES // uncomment to use the two bytes through USB sending protocol", "#define ANALOG_PIN 0 ", "#define DELTA 500 - 7 //usenconds, 2000Hz, error time", "", "unsigned int value = 0;", "unsigned long int t1, t2;", "", "unsigned long int delta_t = DELTA;", "unsigned long int delta_t2 = DELTA;", "", "void loop() {", "  t1 = micros();", "   value = analogRead(ANALOG_PIN);", "    #ifdef TWOBYTES", "      Serial.write(value/256);", "      Serial.write(value%256);", "    #endif", "   t2 = micros() - t1;", "   delayMicroseconds(DELTA - t2);", "  ", "}"]}
{"code": "/*\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * regenbogencode@gmail.com wrote this file. As long as you retain this notice\n * you can do whatever you want with this stuff. If we meet some day, and you\n * think this stuff is worth it, you can buy me a beer in return\n */\n#include <Arduino.h>\n#ifdef ESP8266\n#include <ESP8266WiFi.h>\n#elif ESP32\n#include <WiFi.h>\n#endif\n#include \"ESPNowW.h\"\n\nuint8_t mac[] = {0x36, 0x33, 0x33, 0x33, 0x33, 0x33};\n\nvoid onRecv(const uint8_t *mac_addr, const uint8_t *data, int data_len) {\n    char macStr[18];\n    snprintf(macStr, sizeof(macStr), \"%02x:%02x:%02x:%02x:%02x:%02x\",\n             mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4],\n             mac_addr[5]);\n    Serial.print(\"Last Packet Recv from: \");\n    Serial.println(macStr);\n    Serial.print(\"Last Packet Recv Data: \");\n    // if it could be a string, print as one\n    if (data[data_len - 1] == 0)\n        Serial.printf(\"%s\\n\", data);\n    // additionally print as hex\n    for (int i = 0; i < data_len; i++) {\n        Serial.printf(\"%x \", data[i]);\n    }\n    Serial.println(\"\");\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"ESPNow receiver Demo\");\n#ifdef ESP8266\n    WiFi.mode(WIFI_STA); // MUST NOT BE WIFI_MODE_NULL\n#elif ESP32\n    WiFi.mode(WIFI_MODE_STA);\n#endif\n    ESPNow.set_mac(mac);\n    WiFi.disconnect();\n    ESPNow.init();\n    ESPNow.reg_recv_cb(onRecv);\n}\n\nvoid loop() {}", "line": 22, "slice": ["#include \"ESPNowW.h\"", "", "uint8_t mac[] = {0x36, 0x33, 0x33, 0x33, 0x33, 0x33};", "", "void onRecv(const uint8_t *mac_addr, const uint8_t *data, int data_len) {", "    char macStr[18];", "    snprintf(macStr, sizeof(macStr), \"%02x:%02x:%02x:%02x:%02x:%02x\",", "             mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4],", "             mac_addr[5]);", "    Serial.print(\"Last Packet Recv from: \");", "    Serial.println(macStr);", "    Serial.print(\"Last Packet Recv Data: \");", "    if (data[data_len - 1] == 0)", "        Serial.printf(\"%s\\n\", data);", "    for (int i = 0; i < data_len; i++) {", "        Serial.printf(\"%x \", data[i]);", "    }", "    Serial.println(\"\");", "}", "", "void setup() {", "    Serial.begin(115200);", "    Serial.println(\"ESPNow receiver Demo\");", "#ifdef ESP8266", "    WiFi.mode(WIFI_STA);", "#elif ESP32", "    WiFi.mode(WIFI_MODE_STA);", "#endif", "    ESPNow.set_mac(mac);", "    WiFi.disconnect();", "    ESPNow.init();", "    ESPNow.reg_recv_cb(onRecv);", "}"]}
{"code": "#include <Arduino.h>\n#include <SPI.h>\n#include <ssd1351.h>\n\n// use this to do Color c = RGB(...) instead of `RGB c = RGB(...)` or ssd1351::LowColor c = RGB(...)\n// because it's slightly faster and guarantees you won't be sending wrong colours to the display.\n\n// Choose color depth - IndexedColor, LowColor and HighColor currently supported\n// typedef ssd1351::IndexedColor Color;\n// typedef ssd1351::LowColor Color;\ntypedef ssd1351::HighColor Color;\n\n// Choose display buffering - NoBuffer or SingleBuffer currently supported\n// auto display = ssd1351::SSD1351<Color, ssd1351::NoBuffer, 128, 96>();\nauto display = ssd1351::SSD1351<Color, ssd1351::SingleBuffer, 128, 96>();\n\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Booting...\");\n  display.begin();\n  display.setTextSize(1);\n  Serial.println(\"Display set up.\");\n}\n\nvoid loop() {\n  unsigned long before = millis();\n  display.fillScreen(ssd1351::RGB());\n\n  if (millis() > 5000) {\n\t  display.setFont(FreeMonoBold24pt7b);\n\t  display.setTextSize(1);\n  }\n\n  char test_string[] = \"Test\";\n  uint16_t w = display.getTextWidth(test_string);\n\n  display.setCursor(64 - w/2, 40);\n  display.setTextColor(ssd1351::RGB(255, 255, 255));\n  display.print(test_string);\n  display.drawLine(63, 0, 63, 96, ssd1351::RGB(255, 0, 0));\n\n  display.updateScreen();\n  Serial.println(millis() - before);\n}\n", "line": 40, "slice": ["#include <Arduino.h>", "#include <SPI.h>", "#include <ssd1351.h>", "typedef ssd1351::HighColor Color;", "auto display = ssd1351::SSD1351<Color, ssd1351::SingleBuffer, 128, 96>();", "void setup() {", "  display.begin();", "  display.setTextSize(1);", "}", "void loop() {", "  display.fillScreen(ssd1351::RGB());", "  char test_string[] = \"Test\";", "  uint16_t w = display.getTextWidth(test_string);", "  display.setCursor(64 - w/2, 40);", "  display.setTextColor(ssd1351::RGB(255, 255, 255));", "  display.print(test_string);", "  display.drawLine(63, 0, 63, 96, ssd1351::RGB(255, 0, 0));", "  display.updateScreen();", "}"]}
{"code": "#include <Wire.h>\n#include <AS5600.h>\n#ifdef ARDUINO_SAMD_VARIANT_COMPLIANCE\n  #define SERIAL SerialUSB\n  #define SYS_VOL   3.3\n#else\n  #define SERIAL Serial\n  #define SYS_VOL   5\n#endif\n\nAMS_5600 ams5600;\n\nint ang, lang = 0;\n\nvoid setup()\n{\n  SERIAL.begin(115200);\n  Wire.begin();\n  SERIAL.println(\">>>>>>>>>>>>>>>>>>>>>>>>>>> \");\n  if(ams5600.detectMagnet() == 0 ){\n    while(1){\n        if(ams5600.detectMagnet() == 1 ){\n            SERIAL.print(\"Current Magnitude: \");\n            SERIAL.println(ams5600.getMagnitude());\n            break;\n        }\n        else{\n            SERIAL.println(\"Can not detect magnet\");\n        }\n        delay(1000);\n    }\n  }\n}\n/*******************************************************\n/* Function: convertRawAngleToDegrees\n/* In: angle data from AMS_5600::getRawAngle\n/* Out: human readable degrees as float\n/* Description: takes the raw angle and calculates\n/* float value in degrees.\n/*******************************************************/\nfloat convertRawAngleToDegrees(word newAngle)\n{\n  /* Raw data reports 0 - 4095 segments, which is 0.087 of a degree */\n  float retVal = newAngle * 0.087;\n  return retVal;\n}\nvoid loop()\n{\n    SERIAL.println(String(convertRawAngleToDegrees(ams5600.getRawAngle()),DEC));\n}\n", "line": 23, "slice": ["#include <Wire.h>", "#include <AS5600.h>", "AMS_5600 ams5600;", "/*******************************************************", "/* Function: convertRawAngleToDegrees", "/* In: angle data from AMS_5600::getRawAngle", "/* Out: human readable degrees as float", "/* Description: takes the raw angle and calculates", "/* float value in degrees.", "/*******************************************************/", "float convertRawAngleToDegrees(word newAngle)", "{", "  /* Raw data reports 0 - 4095 segments, which is 0.087 of a degree */", "  float retVal = newAngle * 0.087;", "  return retVal;", "}", "void loop()", "{", "    SERIAL.println(String(convertRawAngleToDegrees(ams5600.getRawAngle()),DEC));", "}"]}
{"code": "#include <Adafruit_NeoPixel.h>\r\n#include <avr/power.h>\r\nint tie = 0;\r\nint toe = 0;\r\n#ifdef __AVR__\r\n#endif\r\n#define PIN 6\r\n#define NUMPIXELS 64\r\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\r\n#define DELAYVAL 500\r\nint a = -1;\r\nint b = -20;\r\nint c = -40;\r\nint d = -60;\r\nvoid setup() {\r\n  Serial.begin(9600);\r\n  pixels.begin();\r\n}\r\nvoid loop() {\r\n  pixels.clear();\r\n  for (int i = 0; i < 64000; i++) {\r\n    Serial.print(a++);\r\n    Serial.print(\" \");\r\n    Serial.print(b++);\r\n    Serial.print(\" \");\r\n    Serial.print(c++);\r\n    Serial.print(\" \");\r\n    Serial.println(d++);\r\n    if (a >= 0) {\r\n      pixels.setPixelColor(a, pixels.Color(15, 25, 150));\r\n    }\r\n    if (b >= 0) {\r\n      pixels.setPixelColor(b, pixels.Color(15, 25, 150));\r\n    }\r\n    if (c >= 0) {\r\n      pixels.setPixelColor(c, pixels.Color(15, 25, 150));\r\n    }\r\n    if (d >= 0) {\r\n      pixels.setPixelColor(d, pixels.Color(15, 25, 150));\r\n    }\r\n    pixels.show();\r\n    delay(100);\r\n\r\n  }\r\n}\r\n", "line": 22, "slice": ["#include <Adafruit_NeoPixel.h>", "#define PIN 6", "#define NUMPIXELS 64", "Adafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);", "int a = -1;", "int b = -20;", "int c = -40;", "int d = -60;", "void setup() {", "  pixels.begin();", "}", "void loop() {", "  pixels.clear();", "  for (int i = 0; i < 64000; i++) {", "    Serial.print(a++);", "    Serial.print(b++);", "    Serial.print(c++);", "    Serial.println(d++);", "    if (a >= 0) {", "      pixels.setPixelColor(a, pixels.Color(15, 25, 150));", "    }", "    if (b >= 0) {", "      pixels.setPixelColor(b, pixels.Color(15, 25, 150));", "    }", "    if (c >= 0) {", "      pixels.setPixelColor(c, pixels.Color(15, 25, 150));", "    }", "    if (d >= 0) {", "      pixels.setPixelColor(d, pixels.Color(15, 25, 150));", "    }", "    pixels.show();", "  }", "}"]}
{"code": "// --- LOOP\n\n\nvoid loop() {\n  // --- FACTORY SETUP MODE\n  if(setupComplete != SETUP_COMPLETE_MAGIC_NUMBER) {\n    if (Serial.available() > 0) {  // send data only when you receive data; condition in setupComplete in case the eeprom was badly initialized\n      handleIncomingChar();\n    }\n  \n    if (setupComplete == SETUP_COMPLETE_MAGIC_NUMBER) {\n      initialiseEEPROMData();\n      getDataEeprom();\n      Serial.print(\"count = \");\n      Serial.println(lastCount);\n      blinkLed(3);\n      #ifndef DEBUG_MODE\n        Serial.end(); // closes the serial communication for more safety\n      #endif\n    }\n  }\n  \n  // --- TOKEN INPUT MODE\n  else {\n    if (isDataAvailable()) {\n      delay(100);\n      handleIncomingKeypress();   \n    }\n    handleActivationTime();\n  }\n}\n", "line": 14, "slice": ["void loop() {", "  if(setupComplete != SETUP_COMPLETE_MAGIC_NUMBER) {", "    if (Serial.available() > 0) {  ", "      handleIncomingChar();", "    }", "  ", "    if (setupComplete == SETUP_COMPLETE_MAGIC_NUMBER) {", "      initialiseEEPROMData();", "      getDataEeprom();", "      Serial.print(\"count = \");", "      Serial.println(lastCount);", "      blinkLed(3);", "      #ifndef DEBUG_MODE", "        Serial.end(); ", "      #endif", "    }", "  }", "  ", "  else {", "    if (isDataAvailable()) {", "      delay(100);", "      handleIncomingKeypress();   ", "    }", "    handleActivationTime();", "  }", "}"]}
{"code": "//\n//    FILE: Average.ino\n//  AUTHOR: Rob dot Tillaart at gmail dot com\n// VERSION: 0.2\n// PURPOSE: Sample sketch for statistic library Arduino\n//\n\n#include \"Statistic.h\"\n\nStatistic myStats;\n\nvoid setup(void)\n{\n  Serial.begin(9600);\n  Serial.print(\"Demo Statistics lib \");\n  Serial.print(STATISTIC_LIB_VERSION);\n  myStats.clear(); //explicitly start clean\n}\n\nvoid loop(void)\n{\n  long rn = random(0, 9999);\n  myStats.add(rn/100.0 + 1);\n  if (myStats.count() == 10000)\n  {\n    Serial.print(\"  Count: \");\n    Serial.println(myStats.count());\n    Serial.print(\"  Min: \");\n    Serial.println(myStats.minimum(),4);\n    Serial.print(\"  Max: \");\n    Serial.println(myStats.maximum(),4);\n    Serial.print(\"  Average: \");\n    Serial.println(myStats.average(), 4);\n    // uncomment in Statistic.h file to use stdev\n    #ifdef STAT_USE_STDEV\n    Serial.print(\"    pop stdev: \");\n    Serial.println(myStats.pop_stdev(), 4);\n    Serial.print(\"  unbias stdev: \");\n    Serial.println(myStats.unbiased_stdev(), 4);\n    #endif\n    Serial.println(\"=====================================\");\n    myStats.clear();\n    delay(1000);\n  }\n}", "line": 15, "slice": ["#include \"Statistic.h\"", "", "Statistic myStats;", "", "void setup(void)", "{", "  myStats.clear(); //explicitly start clean", "}", "", "void loop(void)", "{", "  long rn = random(0, 9999);", "  myStats.add(rn/100.0 + 1);", "  if (myStats.count() == 10000)", "  {", "    Serial.println(myStats.count());", "    Serial.println(myStats.minimum(),4);", "    Serial.println(myStats.maximum(),4);", "    Serial.println(myStats.average(), 4);", "    #ifdef STAT_USE_STDEV", "    Serial.println(myStats.pop_stdev(), 4);", "    Serial.println(myStats.unbiased_stdev(), 4);", "    #endif", "    myStats.clear();", "  }", "}"]}
{"code": "#include <math.h>\n#include \"HAB_Thermistor.h\"\nnamespace HAB {\nnamespace Sensors {\n\n// Some constants for the analog temperature conversion.\nconst float thermistorNominal = 10000.0;\nconst float temperatureNominal = 25.0;\nconst float bCoefficient = 3950.0;\nconst float pullupResistor = 10000.0;\n\n// Constructor for the thermistor that accepts physical pin addresses\nThermistor::Thermistor(int pin) {\n  m_pin = pin;\n}\n\nTemperatureData Thermistor::getTemperature() {\n  TemperatureData data;\n  float rawAverageVoltage = 0.0;\n  for (uint8_t i = 0; i < 5; i++) {\n    rawAverageVoltage += analogRead(m_pin);\n    delay(10);\n  }\n\n  rawAverageVoltage /= 5.0;\n  data.raw = rawAverageVoltage;\n\n  float rawResistance = pullupResistor / (1023 / rawAverageVoltage - 1);\n\n  float steinhart = rawResistance / thermistorNominal;\n  steinhart = log(steinhart) / bCoefficient;\n  steinhart += 1.0 / (temperatureNominal + 273.15);\n  steinhart = (1.0 / steinhart) - 273.15;\n\n  data.tempC = steinhart;\n  data.tempF = (data.tempC * 1.8) + 32.0;\n\n#ifdef HAB_DEVELOPMENT\n  Serial.println(\"PIN = \" + String(m_pin));\n  Serial.println(\"RAW = \" + String(data.raw));\n  Serial.println(\"TEMP = \" + String(data.tempC) + \" C\");\n  Serial.println(\"TEMP = \" + String(data.tempF) + \" F\");\n  Serial.print(\"\\n\");\n#endif\n  return data;\n}\n\n}\n}\n", "line": 43, "slice": ["#include <math.h>", "#include \"HAB_Thermistor.h\"", "namespace HAB {", "namespace Sensors {", "", "const float thermistorNominal = 10000.0;", "const float temperatureNominal = 25.0;", "const float bCoefficient = 3950.0;", "const float pullupResistor = 10000.0;", "", "Thermistor::Thermistor(int pin) {", "  m_pin = pin;", "}", "", "TemperatureData Thermistor::getTemperature() {", "  TemperatureData data;", "  float rawAverageVoltage = 0.0;", "  for (uint8_t i = 0; i < 5; i++) {", "    rawAverageVoltage += analogRead(m_pin);", "    delay(10);", "  }", "", "  rawAverageVoltage /= 5.0;", "  data.raw = rawAverageVoltage;", "", "  float rawResistance = pullupResistor / (1023 / rawAverageVoltage - 1);", "", "  float steinhart = rawResistance / thermistorNominal;", "  steinhart = log(steinhart) / bCoefficient;", "  steinhart += 1.0 / (temperatureNominal + 273.15);", "  steinhart = (1.0 / steinhart) - 273.15;", "", "  data.tempC = steinhart;", "  data.tempF = (data.tempC * 1.8) + 32.0;", "", "  return data;", "}", "", "}", "}"]}
{"code": "\n#include <ESP8266WiFi.h>\n#include <espnow.h>\nuint8_t mainMACAddress[] = {0x40, 0xF5, 0x20, 0x2D, 0x4E, 0x10};\n\ntypedef struct MiniGyro{\n  bool left;\n  uint16_t acceleration;\n  //uint16_t velocity;\n} MiniGyro;\nuint16_t gyroData[2];\nMiniGyro miniGyro;\n\n\n// Callback function that will be executed when data is received\nvoid OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len) {\n  memcpy(&miniGyro, incomingData, sizeof(miniGyro));\n\n//  Serial.print(\"Bytes received: \");\n//  Serial.println(len);\n  if (miniGyro.left){\n    gyroData[0] = miniGyro.acceleration;\n  } else {\n    gyroData[1] = miniGyro.acceleration;\n  }\n  Serial.print(miniGyro.left? \"L :\":\"R: \");\n  Serial.print(\" a: \");\n  Serial.println(miniGyro.acceleration);\n}\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.disconnect();\n  if (esp_now_init() != 0){\n    Serial.println(\"Error initializing ESP-NOW\");\n    return;\n  }\n  esp_now_set_self_role(ESP_NOW_ROLE_SLAVE);\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  \n}\n", "line": 19, "slice": ["#include <ESP8266WiFi.h>", "#include <espnow.h>", "uint8_t mainMACAddress[] = {0x40, 0xF5, 0x20, 0x2D, 0x4E, 0x10};", "", "typedef struct MiniGyro{", "  bool left;", "  uint16_t acceleration;", "  //uint16_t velocity;", "} MiniGyro;", "uint16_t gyroData[2];", "MiniGyro miniGyro;", "", "// Callback function that will be executed when data is received", "void OnDataRecv(uint8_t * mac, uint8_t *incomingData, uint8_t len) {", "  memcpy(&miniGyro, incomingData, sizeof(miniGyro));", "  if (miniGyro.left){", "    gyroData[0] = miniGyro.acceleration;", "  } else {", "    gyroData[1] = miniGyro.acceleration;", "  }", "  Serial.print(miniGyro.left? \"L :\":\"R: \");", "  Serial.print(\" a: \");", "  Serial.println(miniGyro.acceleration);", "}", "", "void setup() {", "  Serial.begin(115200);", "  esp_now_set_self_role(ESP_NOW_ROLE_SLAVE);", "  esp_now_register_recv_cb(OnDataRecv);", "}"]}
{"code": "#ifndef LED_BUILTIN\r\n#define LED_BUILTIN 2\r\n#endif\r\nTaskHandle_t TaskBlink;\r\nvoid Blink(void *pvParameters);\r\nvoid setup() {\r\n  // put your setup code here, to run once:\r\n  Serial.begin(115200);\r\n  //Set up task 1 to run on core 0\r\n  xTaskCreatePinnedToCore(\r\n    Blink,\r\n    \"TaskBlink\",\r\n    10000,\r\n    NULL,\r\n    2,\r\n    &TaskBlink,\r\n    0);\r\n}\r\n\r\nvoid loop() {\r\n  // put your main code here, to run repeatedly:\r\n  //Serial.println(millis());\r\n}\r\n\r\nvoid Blink(void *pvparameters) {\r\n  pinMode(LED_BUILTIN, OUTPUT);\r\n\r\n\r\n  for (;;) {\r\n    Serial.print(\"Blink running on core \");\r\n    Serial.println(xPortGetCoreID());\r\n    digitalWrite(LED_BUILTIN, HIGH);\r\n    vTaskDelay(1000);\r\n    digitalWrite(LED_BUILTIN, LOW);\r\n    vTaskDelay(1000);\r\n  }\r\n}\r\n", "line": 30, "slice": ["#ifndef LED_BUILTIN", "#define LED_BUILTIN 2", "#endif", "TaskHandle_t TaskBlink;", "void Blink(void *pvParameters);", "void setup() {", "  xTaskCreatePinnedToCore(", "    Blink,", "    \"TaskBlink\",", "    10000,", "    NULL,", "    2,", "    &TaskBlink,", "    0);", "}", "void Blink(void *pvparameters) {", "  pinMode(LED_BUILTIN, OUTPUT);", "  for (;;) {", "    digitalWrite(LED_BUILTIN, HIGH);", "    vTaskDelay(1000);", "    digitalWrite(LED_BUILTIN, LOW);", "    vTaskDelay(1000);", "  }", "}"]}
{"code": "\n#include \"NESJOY.h\"\nNESJOY nes(7, 8, 9);\nJoy j;\nvoid setup()\n{\n\tnes.init();\n\tSerial.begin(9600);\n}\n\n// Add the main program code into the continuous loop() function\nvoid loop()\n{\n\tj = nes.Read();\n\tchar c[100] = { ' ' };\n#ifdef STM32\n\n#else\n\tsnprintf(c, 100, \"A:%d, B:%d, SEL:%d, START:%d, UP:%d, DOWN:%d, LEFT:%d, RIGHT:%d \\n\", j.A, j.B, j.SEL, j.START, j.UP, j.DOWN, j.LEFT, j.RIGHT);\n\tSerial.print(c);\n#endif // STM32\n\n\tdelay(100);\n}\r\n", "line": 20, "slice": ["#include \"NESJOY.h\"", "NESJOY nes(7, 8, 9);", "Joy j;", "void loop()", "{", "\tj = nes.Read();", "\tchar c[100] = { ' ' };", "\tsnprintf(c, 100, \"A:%d, B:%d, SEL:%d, START:%d, UP:%d, DOWN:%d, LEFT:%d, RIGHT:%d \\n\", j.A, j.B, j.SEL, j.START, j.UP, j.DOWN, j.LEFT, j.RIGHT);", "\tSerial.print(c);", "}"]}
{"code": "#include <ESP8266WiFi.h>\n#include <WiFiUdp.h>\n\nconst unsigned int SERVER_PORT  = 9999;\nconst char *SERVER_NAME         = \"NODEMCU\";\nconst char *SERVER_PASWD        = \"\";\nconst int SERVER_CHANNEL        = 4;\n\nIPAddress AP_SERVER(192, 168, 4, 1);\n\ntypedef struct _udp_packet {\n  int id;\n  char local[32];\n  float distance;\n  bool enabled;\n} UDP_PACKET;\n\nWiFiUDP Udp;\n//UDP_PACKET packet = {1, \"room\", 0, true};\n//UDP_PACKET packet = {2, \"kitchen\", 0, false};\nUDP_PACKET packet = {3, \"living room\", 0, true};\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial.println();\n\n  WiFi.mode(WIFI_STA);\n  Serial.printf(\"Connecting to %s \", SERVER_NAME);\n  WiFi.begin(SERVER_NAME, SERVER_PASWD);\n\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\" connected\");\n  Udp.begin(SERVER_PORT);\n}\n\nvoid loop()\n{\n  packet.distance = random(0, 1000);\n\n  Udp.beginPacket(AP_SERVER, SERVER_PORT);\n  Udp.write((byte *)&packet, sizeof(UDP_PACKET));\n  Udp.endPacket();\n  delay(1000);\n}\n", "line": 35, "slice": ["const unsigned int SERVER_PORT  = 9999;", "IPAddress AP_SERVER(192, 168, 4, 1);", "typedef struct _udp_packet {", "  int id;", "  char local[32];", "  float distance;", "  bool enabled;", "} UDP_PACKET;", "WiFiUDP Udp;", "UDP_PACKET packet = {3, \"living room\", 0, true};", "void setup()", "{", "  Udp.begin(SERVER_PORT);", "}", "void loop()", "{", "  packet.distance = random(0, 1000);", "  Udp.beginPacket(AP_SERVER, SERVER_PORT);", "  Udp.write((byte *)&packet, sizeof(UDP_PACKET));", "}"]}
{"code": "#include <SPI.h>  \n#include \"RF24.h\"\n\nRF24 myRadio (9, 10);\nbyte addresses[][6] = {\"0\"};\n\nstruct package {\n  int id=1;\n  float temperature = 18.3;\n  char  text[300] = \"Text to be transmit\";\n};\n\n\ntypedef struct package Package;\nPackage data;\n\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(1000);\n  \n  myRadio.begin();  \n  myRadio.setChannel(55); \n  myRadio.setPALevel(RF24_PA_MAX);\n  myRadio.setDataRate( RF24_1MBPS );\n  myRadio.openWritingPipe(addresses[0]);\n}\n\nvoid loop() {\n  myRadio.write(&data, sizeof(data)); \n\n  Serial.print(\"\\nPackage:\");\n  Serial.print(data.id);\n  Serial.print(\"\\n\");\n  Serial.println(data.temperature);\n  Serial.println(data.text);\n  data.id = data.id + 1;\n  data.temperature = data.temperature+0.1;\n  delay(100);\n}\n", "line": 32, "slice": ["RF24 myRadio (9, 10);", "byte addresses[][6] = {\"0\"};", "", "struct package {", "  int id=1;", "  float temperature = 18.3;", "  char  text[300] = \"Text to be transmit\";", "};", "", "", "typedef struct package Package;", "Package data;", "", "myRadio.begin();  ", "myRadio.setChannel(55); ", "myRadio.setPALevel(RF24_PA_MAX);", "myRadio.setDataRate( RF24_1MBPS );", "myRadio.openWritingPipe(addresses[0]);", "", "myRadio.write(&data, sizeof(data)); ", "", "data.id = data.id + 1;", "data.temperature = data.temperature+0.1;"]}
{"code": "#ifdef ENCODER\r\n#include \"src/Encoder.h\"\r\n\r\n// For Arduino MEGA - pins 2,3,18,19, (20,21 - used for i2c)\r\nEncoder leftEncoder(LEFT_ENCODER);  // pins 2,3\r\nEncoder rightEncoder(RIGHT_ENCODER); // pins 18,19\r\n\r\nvoid setup() {\r\n  // Set up serial\r\n  NeoSerial.begin(115200);\r\n\r\n  NeoSerial.println(\"Starting up.\");\r\n  // Set up encoder\r\n  leftEncoder.begin();\r\n  rightEncoder.begin();\r\n}\r\n\r\nvoid loop() {\r\n  // Print counts of each encoder\r\n  NeoSerial.print(\"ticks: \"); \r\n  NeoSerial.print(leftEncoder.sampleTicks());\r\n  NeoSerial.print(\", \");\r\n  NeoSerial.print(rightEncoder.sampleTicks());\r\n  NeoSerial.println();\r\n}\r\n\r\n#endif\r\n", "line": 20, "slice": ["#ifdef ENCODER", "#include \"src/Encoder.h\"", "", "Encoder leftEncoder(LEFT_ENCODER);  // pins 2,3", "Encoder rightEncoder(RIGHT_ENCODER); // pins 18,19", "", "void setup() {", "  leftEncoder.begin();", "  rightEncoder.begin();", "}", "", "void loop() {", "  NeoSerial.print(rightEncoder.sampleTicks());", "}", "#endif"]}
{"code": "\nvoid setup() {\n  Serial.begin(9600);\n  setupBluetooth();\n}\n\nvoid loop() {\n  //Write to Matlab\n  Serial1.println(\"I love big fat nuts\");\n\n  //Read from Matlab\n  if(Serial1.available() > 0){\n    Serial.print(Serial1.readString());\n  }\n}\n\nvoid setupBluetooth(){\n  Serial1.begin(9600);\n  #ifndef ESP8266\n    while(!Serial1);     // will pause Zero, Leonardo, etc until Serial1 console opens\n  #endif\n}\n\n", "line": 13, "slice": ["void setup() {", "  setupBluetooth();", "}", "", "void setupBluetooth(){", "  Serial1.begin(9600);", "  #ifndef ESP8266", "    while(!Serial1);     // will pause Zero, Leonardo, etc until Serial1 console opens", "  #endif", "}", "", "void loop() {", "  if(Serial1.available() > 0){", "    Serial.print(Serial1.readString());", "  }", "}"]}
{"code": "#ifdef ARDUINO_ARCH_ESP32\n#include <WiFi.h>\n#else\n#include <ESP8266WiFi.h>\n#endif\n#include \"IIJMachinistClient.h\"\n\n#define WIFI_ID \"YOUR WIFI SSID HERE\"\n#define WIFI_PASS \"YOUR WIFI PASSWORD HERE\"\n#define MACHINIST_API_KEY \"YOUR Machinist API KEY here\"\n\nIIJMachinistClient c(MACHINIST_API_KEY);\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial.println();\n  delay(3000);\n\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(WIFI_ID, WIFI_PASS);\n\n  // wait for WiFi connection\n  Serial.print(\"\\nWaiting for WiFi to connect...\");\n  while ((WiFi.status() != WL_CONNECTED))\n  {\n    Serial.print(\".\");\n    delay(1000);\n  }\n  Serial.println(\" connected\");\n\n  randomSeed(analogRead(0));\n  c.setDebugSerial(Serial);\n  c.init();\n}\n\nvoid loop()\n{\n  float value = (float)random(10000) / 100.;\n\n  //\u3042\u3089\u304b\u3058\u3081 Machinist \u306e UI \u304b\u3089 \"test\" \u3068\u3044\u3046\u540d\u79f0\u306e Agent \u3092\u4f5c\u6210\u3057\u3066\u304a\u304d\u307e\u3059\u3002\n  int s = c.post(\"test\", \"NAME\\\\SPACE\", \"NAME\", value, \"KEY\", \"VALUE\");\n  if (s == 200)\n    Serial.println(\"OK\");\n  else\n    Serial.println(\"NG status=\" + String(s));\n  delay(60 * 1000);\n}\n", "line": 24, "slice": ["#define MACHINIST_API_KEY \"YOUR Machinist API KEY here\"", "", "IIJMachinistClient c(MACHINIST_API_KEY);", "", "void setup()", "{", "  c.setDebugSerial(Serial);", "  c.init();", "}", "", "void loop()", "{", "  float value = (float)random(10000) / 100.;", "  int s = c.post(\"test\", \"NAME\\\\SPACE\", \"NAME\", value, \"KEY\", \"VALUE\");", "  if (s == 200)", "    Serial.println(\"OK\");", "  else", "    Serial.println(\"NG status=\" + String(s));", "  delay(60 * 1000);", "}"]}
{"code": "/* \r\n *  https://circuits4you.com\r\n *  ESP32 Internal Temperature Sensor Example\r\n */\r\n\r\n #ifdef __cplusplus\r\n  extern \"C\" {\r\n #endif\r\n\r\n  uint8_t temprature_sens_read();\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\nuint8_t temprature_sens_read();\r\n//====================================================\r\n//         Setup\r\n//====================================================\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n}\r\n\r\n//====================================================\r\n//         Loop\r\n//====================================================\r\nvoid loop() {\r\n  Serial.print(\"Temperature: \");\r\n  \r\n  // Convert raw temperature in F to Celsius degrees\r\n  Serial.print((temprature_sens_read() - 32) / 1.8);\r\n  Serial.println(\" C\");\r\n  delay(1000);\r\n}\r\n", "line": 28, "slice": ["#ifdef __cplusplus", "  extern \"C\" {", " #endif", "", "  uint8_t temprature_sens_read();", "", "#ifdef __cplusplus", "}", "#endif", "", "uint8_t temprature_sens_read();", "", "void loop() {", "  Serial.print((temprature_sens_read() - 32) / 1.8);", "  delay(1000);", "}"]}
{"code": "// LCD-i2c\n// Manferdelli\n\n#include <Wire.h>\n#include <LiquidCrystal_I2C.h>\n\n// SDA-->A4\n// SDL-->A5\ntypedef uint8_t byte;\nconst int printDelay = 50;\nconst int freezeDelay = 1000;\n\nconst int i2cAddress = 0x27;\nconst int numCols = 16;\nconst int numRows = 2;\n\nLiquidCrystal_I2C lcd(i2cAddress, numCols, numRows);\n\nvoid printLine(int line_no, const char* msg) {\n  if (strlen(msg) > numCols)\n    return;\n  int l = strlen(msg);\n  int pos = 0;\n  for (; pos < l; pos++) {\n    lcd.setCursor(pos, line_no);\n    lcd.print(msg[pos]);\n    delay(printDelay);\n  }\n  char blank = ' ';\n  for (; pos < numCols; pos++) {\n    lcd.setCursor(pos, line_no);\n    lcd.print(blank);\n    delay(printDelay);\n  }\n}\n\nvoid setup() {\n  lcd.init();\n  lcd.backlight();\n}\n\nvoid loop() {\n  lcd.clear();\n  printLine(0, \"Hello, John\");\n  delay(freezeDelay);\n  printLine(1, \"Welcome to IoT\");\n  delay(freezeDelay);\n}\n", "line": 26, "slice": ["#include <Wire.h>", "#include <LiquidCrystal_I2C.h>", "typedef uint8_t byte;", "const int printDelay = 50;", "const int numCols = 16;", "LiquidCrystal_I2C lcd(i2cAddress, numCols, numRows);", "void printLine(int line_no, const char* msg) {", "  if (strlen(msg) > numCols)", "    return;", "  int l = strlen(msg);", "  int pos = 0;", "  for (; pos < l; pos++) {", "    lcd.setCursor(pos, line_no);", "    lcd.print(msg[pos]);", "    delay(printDelay);", "  }", "  char blank = ' ';", "  for (; pos < numCols; pos++) {", "    lcd.setCursor(pos, line_no);", "    lcd.print(blank);", "    delay(printDelay);", "  }", "}", "void loop() {", "  printLine(1, \"Welcome to IoT\");", "}"]}
{"code": "\n#include <ustr.h>\n\nconst char PROGMEM in_rom[] = \"in rom\";\nchar in_ram[] = \"in ram\";\n\nvoid modify_first_char_and_display(ustr u)\n{\n    Serial.print(\"    \");\n    (*u)++;\n    while (*u)\n    {\n        Serial.print(*u++);\n    }\n    Serial.println();\n}\n\nvoid setup()\n{\n    Serial.begin(115200);\n\n    // initialize eeprom\n#ifdef ESP8266\n    EEPROM.begin(512);\n#endif\n    EEPROM.put(510, '!');\n    EEPROM.put(511, 0);\n\n    Serial.println(\"I am always modified the same way:\");\n    modify_first_char_and_display(ustr::ptr(in_ram));\n\n    Serial.println(\"I cannot be modified:\");\n    modify_first_char_and_display(ustr::rom(in_rom));\n\n    Serial.println(\"I am changing accross reboots:\");\n    modify_first_char_and_display(ustr::ee(510));\n\n    Serial.println(\"I cannot be modified:\");\n    modify_first_char_and_display(USTR(\"i am in rom too\"));\n}\n\nvoid loop()\n{\n}\n", "line": 9, "slice": ["#include <ustr.h>", "", "const char PROGMEM in_rom[] = \"in rom\";", "char in_ram[] = \"in ram\";", "", "void modify_first_char_and_display(ustr u)", "{", "    (*u)++;", "    while (*u)", "    {", "        Serial.print(*u++);", "    }", "}", "", "void setup()", "{", "    modify_first_char_and_display(ustr::ptr(in_ram));", "    modify_first_char_and_display(ustr::rom(in_rom));", "    modify_first_char_and_display(ustr::ee(510));", "    modify_first_char_and_display(USTR(\"i am in rom too\"));", "}"]}
{"code": "/**@file esc_programmer.ino */\n#include <Servo.h>\n\n/** \\def ESC_PIN\n\tThe pin number of which the ESC data pin should be connected to.\n*/\n\n#define ESC_PIN 10\n\nServo esc;\n\n/**\n * How to set up the ESC:\n * \n * Connect pins, but don't start ESC\t\\n\n * Run this code\t\\n\n * Send signal 2000\t\\n\n * Hold \"set\" button on ESC and switch it on\t\\n\n * Wait for orange solid light\t\\n\n * Release \"set\" button and wait for solid red\t\\n\n * Send signal 700\t\\n\n * Wait for solid orange\t\\n\n * Send signal 1000 'neutral'\t\\n\n * Wait for beep and no light\t\\n\n * Switch off ESC\t\\n\n * Turn on ESC, ready to use!\n */\n\n/**\n\tThis function sets up the serial communication, used with e.g. the Arduino Studio Serial monitor\n*/\nvoid setup() {\n  // put your setup code here, to run once:\n  esc.attach(ESC_PIN);\n  Serial.begin(9600);\n}\n\n/**\n\tLoops for ever until the Arduino is turned off. Waits for input on the serial communication channel and writes this to the ESC\n*/\nvoid loop() {\n  if(Serial.available()){\n    int value = Serial.parseInt();\n    Serial.print(\"Sending value: \");\n    Serial.println(value);\n    esc.writeMicroseconds(value);\n  }\n}\n", "line": 44, "slice": ["#include <Servo.h>", "#define ESC_PIN 10", "Servo esc;", "void setup() {", "  esc.attach(ESC_PIN);", "  Serial.begin(9600);", "}", "void loop() {", "  if(Serial.available()){", "    int value = Serial.parseInt();", "    esc.writeMicroseconds(value);", "  }", "}"]}
{"code": "#include <Wire.h> // Enable this line if using Arduino Uno, Mega, etc.\n#include <Adafruit_GFX.h>\n#include \"Adafruit_LEDBackpack.h\"\n\nAdafruit_7segment matrix = Adafruit_7segment();\n\n\nvoid setup() {\n  // put your setup code here, to run once:\n #ifndef __AVR_ATtiny85__\n  Serial.begin(9600);\n  Serial.println(\"7 Segment Backpack Test\");\n#endif\n  matrix.begin(0x70);\n\n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  \n  matrix.print(500, DEC);\n  matrix.writeDisplay();\n}\n", "line": 22, "slice": ["#include <Adafruit_GFX.h>", "#include \"Adafruit_LEDBackpack.h\"", "", "Adafruit_7segment matrix = Adafruit_7segment();", "", "void setup() {", "  matrix.begin(0x70);", "}", "", "void loop() {", "  matrix.print(500, DEC);", "  matrix.writeDisplay();", "}"]}
{"code": "#ifdef MD\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  iAm = \"mama-duck\";\n  empty.whoAmI = \"mama-duck\";\n  setupDuck();\n\n  setupDisplay();\n  setupLoRa();\n  setupPortal();\n\n  Serial.println(\"Mama Online\");\n  u8x8.drawString(0, 1, \"Mama Online\");\n}\n\nvoid loop()\n{\n  // \u26a0\ufe0f Parses Civilian Requests into Data Structure\n  readData();\n  if (offline.fromCiv == 1 && offline.phone != NULL && offline.phone != \"\")\n  {\n    Serial.println(\"Start Send\");\n    sendPayload(offline);\n    Serial.print(\"Sending Wifi Data from Mama\\n\");\n    offline = empty;\n    offline.fromCiv = 0;\n  }\n\n  receive(LoRa.parsePacket());\n  //  strstr(offline.path.toCharArray, empty.duckID) != NULL\n  if (offline.fromCiv == 0 && offline.phone != NULL && offline.phone != \"\" && offline.path.indexOf(empty.duckID) < 0) {\n    offline.path = offline.path + \",\" + empty.duckID;\n    sendPayload(offline);\n    Serial.print(\"I'm here\");\n    delay(random(0,2500));\n    sendPayload(offline);\n    offline = empty;\n  }\n\n  // Sends Duck Stat every 30 minutes\n  sendDuckStat(offline);\n}\n\n#endif\n", "line": 27, "slice": ["void setup()", "{", "  empty.whoAmI = \"mama-duck\";", "}", "", "void loop()", "{", "  readData();", "  if (offline.fromCiv == 1 && offline.phone != NULL && offline.phone != \"\")", "  {", "    offline = empty;", "  }", "", "  if (offline.fromCiv == 0 && offline.phone != NULL && offline.phone != \"\" && offline.path.indexOf(empty.duckID) < 0) {", "    offline.path = offline.path + \",\" + empty.duckID;", "    offline = empty;", "  }", "}"]}
{"code": "#ifdef ENABLE_MPU\n\n#include \"MPU6050.h\"\n\nMPU6050 accelgyro;\nint16_t ax, ay, az;\nint16_t gx, gy, gz;\nint16_t accelgyro_temp;\n\nvoid mpu_start () {\n  accelgyro.initialize();\n  Serial.print(F(\"<MPU_START=\"));\n  Serial.print(accelgyro.testConnection());\n  Serial.println(F(\">\"));\n}\n\nvoid mpu_cmd (uint8_t Setting) {\n  switch (Setting) {\n    case 0://get acelgyro\n      accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);\n      Serial.print(F(\"<MPU_AG=\")); Serial.print(ax);\n      Serial.print(F(\",\")); Serial.print(ay);\n      Serial.print(F(\",\")); Serial.print(az);\n      Serial.print(F(\",\")); Serial.print(gx);\n      Serial.print(F(\",\")); Serial.print(gy);\n      Serial.print(F(\",\")); Serial.print(gz); \n      Serial.println(F(\">\"));\n      break;\n    case 1://get temp\n      accelgyro_temp = accelgyro.getTemperature()/340 + 36.53;\n      Serial.print(F(\"<MPU_T=\")); Serial.print(accelgyro_temp); Serial.println(F(\">\"));\n      break;\n  }\n}\n\n\n#endif\r\n", "line": 12, "slice": ["#include \"MPU6050.h\"", "", "MPU6050 accelgyro;", "int16_t ax, ay, az;", "int16_t gx, gy, gz;", "", "void mpu_cmd (uint8_t Setting) {", "  switch (Setting) {", "    case 0://get acelgyro", "      accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);", "      Serial.print(F(\"<MPU_AG=\")); Serial.print(ax);", "      Serial.print(F(\",\")); Serial.print(ay);", "      Serial.print(F(\",\")); Serial.print(az);", "      Serial.print(F(\",\")); Serial.print(gx);", "      Serial.print(F(\",\")); Serial.print(gy);", "      Serial.print(F(\",\")); Serial.print(gz); ", "      Serial.println(F(\">\"));", "      break;", "  }", "}"]}
{"code": "#include <HaLakeKitFirst.h>\n#include <SoftwareSerial.h>\n\n//#define DEBUG_MODE\n\nHaLakeKitFirst kitFirst(&Serial1);\nSoftwareSerial someSerial1(2,3);\nSoftwareSerial someSerial2(4,5);\nSoftwareSerial someSerial3(7,8);\n\nString kitStr;\nString strToSend;\n\nvoid setup() {\n  kitFirst.begin();\n  someSerial1.begin(HALAKEKITFIRST_SERIAL_SPEED);\n  someSerial2.begin(HALAKEKITFIRST_SERIAL_SPEED);\n  someSerial3.begin(HALAKEKITFIRST_SERIAL_SPEED);\n#ifdef DEBUG_MODE\n  while (!Serial);\n  Serial.begin(115200);\n#endif\n}\n\nvoid loop() {\n  if (kitFirst.receive()) {\n    kitStr = kitFirst.getReceivedString();\n    if (kitStr.length() > 0) {\n      strToSend = kitStr + \"\\n\";\n      someSerial1.print(strToSend);\n      someSerial2.print(strToSend);\n      someSerial3.print(strToSend);\n#ifdef DEBUG_MODE\n      Serial.print(strToSend);\n#endif\n    }\n  }\n  delay(10);\n}\n\n\n", "line": 30, "slice": ["#include <HaLakeKitFirst.h>", "#include <SoftwareSerial.h>", "", "HaLakeKitFirst kitFirst(&Serial1);", "SoftwareSerial someSerial1(2,3);", "SoftwareSerial someSerial2(4,5);", "SoftwareSerial someSerial3(7,8);", "", "String kitStr;", "String strToSend;", "", "void setup() {", "  kitFirst.begin();", "  someSerial1.begin(HALAKEKITFIRST_SERIAL_SPEED);", "  someSerial2.begin(HALAKEKITFIRST_SERIAL_SPEED);", "  someSerial3.begin(HALAKEKITFIRST_SERIAL_SPEED);", "}", "", "void loop() {", "  if (kitFirst.receive()) {", "    kitStr = kitFirst.getReceivedString();", "    if (kitStr.length() > 0) {", "      strToSend = kitStr + \"\\n\";", "      someSerial1.print(strToSend);", "      someSerial2.print(strToSend);", "      someSerial3.print(strToSend);", "    }", "  }", "}"]}
{"code": "void mqttreconnect() {\n  // Loop until we're reconnected\n  while (!client.connected()) {\n    Serial.println(\"Attempting MQTT connection...\");\n    // Attempt to connect\n    if (client.connect(appname, MQTT_USERNAME, MQTT_PASSWORD)) {\n      #ifdef DEBUG\n        snprintf (msg, 150, \"Connected to Mqtt broker as %s\", appname);\n        Serial.print(\"Publish message: \");\n        Serial.println(msg);\n        client.publish(mqtt_value_topic, msg);\n        \n      #endif\n      client.subscribe(mqtt_tempin_topic);\n      client.subscribe(mqtt_time_topic);\n      int con = client.subscribe(mqtt_indoorsensor_topic);\n      //Serial.println(con);  // 1 if connection is succesfull\n      //client.subscribe(mqtt_ha_topic);\n      #ifdef DEBUG\n        Serial.print(\"Subscribed to: \");\n//        Serial.print(mqtt_tempin_topic);\n        Serial.print(\",  \");        \n        Serial.println(mqtt_time_topic);\n        Serial.println(mqtt_indoorsensor_topic);\n        //Serial.println(mqtt_ha_topic);        \n      #endif\n      \n      \n    } else {\n      Serial.print(\"Mqtt connection failed, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" try again in 5 seconds\");\n      // Wait 5 seconds before retrying\n      delay(5000);\n    }\n  }\n}\n", "line": 9, "slice": ["void mqttreconnect() {", "  while (!client.connected()) {", "    if (client.connect(appname, MQTT_USERNAME, MQTT_PASSWORD)) {", "      client.subscribe(mqtt_tempin_topic);", "      client.subscribe(mqtt_time_topic);", "      int con = client.subscribe(mqtt_indoorsensor_topic);", "    } else {", "      delay(5000);", "    }", "  }", "}"]}
{"code": "/*\n * Get values from SHT2x & LM75 sensor and battery voltage\n */\n\nvoid getValues()\n{\n  // Vext einschalten\n  digitalWrite(VEXT, HIGH);\n  delay(50);\n  \n  // Read SHT2x values\n  float SHT2x_temp = SHT2x.GetTemperature();\n  extmp = (int16_t) (SHT2x_temp * 100 + 0.5);      // external Temperature as word\n  float SHT2x_humi = SHT2x.GetHumidity();\n  exhum = (uint16_t) (SHT2x_humi * 10 + 0.5);      // external Humidity as word\n  #ifdef DEBUG\n    Serial.print(\"SHT2x Temperature = \"); Serial.print(SHT2x_temp); Serial.println(\" \u00b0C\");\n    Serial.println(extmp,HEX);\n    Serial.print(\"SHT2x Humidity    = \"); Serial.print(SHT2x_humi); Serial.println(\" %RH\");\n    Serial.println(exhum,HEX);\n  #endif\n\n  // Read LM75 value\n  float LM75_temp  = LM75.readTemperatureC();\n  itmp = (int16_t) (LM75_temp * 100 + 0.5);      // internal Temperature as word\n  #ifdef DEBUG\n    Serial.print(\"LM75 Temperature  = \"); Serial.print(LM75_temp); Serial.println(\" \u00b0C\");\n    Serial.println(itmp,HEX);\n  #endif\n\n  // Vext ausschalten\n  digitalWrite(VEXT, LOW);\n\n  // Read battery voltage\n  LadA = digitalRead(CHRG);  // Liest den Inputpin\n  unsigned int sensorValue = analogRead(A7);\n  float voltage = sensorValue * (3.3 / 1024.0)*2;\n  volt = (uint16_t) (voltage * 1000 + 0.5);  // Battery voltage in mV as word\n  volt = volt | 0x8000;\n  #ifdef DEBUG  \n    Serial.print(\"Battery Voltage   = \"); Serial.print(voltage); Serial.println(\" V\");\n    Serial.print(\"Loading: \");\n    if (LadA) Serial.println(\"No\"); \n    else      Serial.println(\"Yes\");\n    Serial.println(volt,HEX);\n  #endif\n}\n", "line": 17, "slice": ["// Read battery voltage", "LadA = digitalRead(CHRG);  // Liest den Inputpin", "unsigned int sensorValue = analogRead(A7);", "float voltage = sensorValue * (3.3 / 1024.0)*2;", "volt = (uint16_t) (voltage * 1000 + 0.5);  // Battery voltage in mV as word", "volt = volt | 0x8000;"]}
{"code": "#include \"para_preset.h\"\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial.println (\"\\n//---------Program Begin----------//\");\n  setupWiFi();\n  Serial.println(\"WiFi connected\");\n  setupUdp();\n  Serial.println(\"UDP connected\");\n}\n\nvoid loop() {\n  int packetSize = Udp.parsePacket();\n  if (packetSize) {\n#ifdef DEBUG_VERBOS\n    Serial.print(\"Received packet of size \");\n    Serial.println(packetSize);\n    Serial.print(\"From \");\n    Serial.print(Udp.remoteIP());\n    Serial.print(\", port \");\n    Serial.println(Udp.remotePort());\n#endif //DEBUG_VERBOS\n    // read the packet into packetBuffer\n    int len = Udp.read(packetBuffer, 255);\n    if (len > 0) {\n      packetBuffer[len] = 0;\n    }\n    Serial.print(\"message received:\\t[\");\n    Serial.print((char*)packetBuffer);\n    Serial.println(\"]\");\n    Udp.beginPacket(ESP_remoteIP, ESP_remotePORT);\n    //     Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());\n    Udp.write(ReplyBuffer, 13);\n    Udp.write(packetBuffer, packetSize);\n    Udp.write(']');\n    Udp.endPacket();\n  }\n}\n", "line": 17, "slice": ["#include \"para_preset.h\"", "", "void setup()", "{", "  setupUdp();", "}", "", "void loop() {", "  int packetSize = Udp.parsePacket();", "  if (packetSize) {", "    int len = Udp.read(packetBuffer, 255);", "    if (len > 0) {", "      packetBuffer[len] = 0;", "    }", "    Udp.beginPacket(ESP_remoteIP, ESP_remotePORT);", "    Udp.write(ReplyBuffer, 13);", "    Udp.write(packetBuffer, packetSize);", "    Udp.write(']');", "    Udp.endPacket();", "  }", "}"]}
{"code": "#include \"Parameters.h\"\n#include \"Reader.h\"\n#include \"Display.h\"\n#include \"Valve.h\"\n\n// #define SERIAL_DEBUG 0\n\nvoid setup() {\n  #ifdef SERIAL_DEBUG\n    Serial.begin(9600);\n    Serial.println(\"Starting...\");\n  #endif\n  Display::init();\n  Valve::init();\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(13, !digitalRead(13));  // activity indicator\n  \n  float targetPsi = getTargetPressureDelta();\n  float measuredPsi = getPressureMeasuredDelta();\n  float offPsi = targetPsi - measuredPsi;\n\n  float valveOpening = Valve::getOpening();\n\n  #ifndef SERIAL_DEBUG\n    Display::showPressureSelection(measuredPsi, targetPsi);\n    Display::showValveOpening(valveOpening, 0.f);\n    Display::submit();\n  #endif\n\n  #ifdef SERIAL_DEBUG\n    Serial.print(\"Off by: \");\n    Serial.print(offPsi, 2);\n    Serial.println(\" psi\");\n  #endif\n\n  // motor movement\n  if (abs(offPsi) > toleratedPsiDelta) {\n    Valve::move(offPsi < 0);  // open or close depending on inequality\n  }\n  else {\n    Valve::stop();\n  }\n  Valve::setSlow(abs(offPsi) < lowSpeedPsiDelta); // control speed\n}\n", "line": 34, "slice": ["#include \"Parameters.h\"", "#include \"Reader.h\"", "#include \"Valve.h\"", "", "float targetPsi = getTargetPressureDelta();", "float measuredPsi = getPressureMeasuredDelta();", "float offPsi = targetPsi - measuredPsi;", "", "if (abs(offPsi) > toleratedPsiDelta) {", "    Valve::move(offPsi < 0);  // open or close depending on inequality", "}", "else {", "    Valve::stop();", "}", "Valve::setSlow(abs(offPsi) < lowSpeedPsiDelta); // control speed"]}
{"code": "#include <Arduino.h>\n#include <pas-co2-serial-ino.hpp>\n\n/**\n * Select the serial interface:\n * - I2C (TwoWire)\n * - UART (HardwareSerial)\n * By default the I2C interfaces is selected. \n * Compile with -DINO_HW_SERIAL to select the UART interface.\n */\n#ifdef INO_HW_SERIAL\nHardwareSerial * bus = (HardwareSerial*) pltf->uart;\n#else\nTwoWire * bus = (TwoWire*) pltf->i2c;\n#endif\n\nPASCO2SerialIno cotwo(bus);\n\nDiag_t diagnosis;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"pas co2 serial initialized\");\n  \n  Error_t err = cotwo.getDiagnosis(diagnosis);\n  if(pasco2::OK != err)\n  {\n    Serial.print(\"error: \");\n    Serial.println(err);\n  }\n\n  Serial.println(\"Diagnosis flags (1) true, (0) false : \\n\");\n  Serial.print(\"sensor ready              : \");\n  Serial.println(diagnosis.sensorRdy);\n  Serial.print(\"pwm pin enabled           : \");\n  Serial.println(diagnosis.pwmPinEnabled);\n  Serial.print(\"temperature ouf of range  : \");\n  Serial.println(diagnosis.outOfRangeTempError);\n  Serial.print(\"ir emitter v out of range : \");\n  Serial.println(diagnosis.outOfRange12VError);\n  Serial.print(\"communication error       : \");\n  Serial.println(diagnosis.commError);\n\n}\n\nvoid loop()\n{\n\n}", "line": 29, "slice": ["#include <Arduino.h>", "#include <pas-co2-serial-ino.hpp>", "", "#ifdef INO_HW_SERIAL", "HardwareSerial * bus = (HardwareSerial*) pltf->uart;", "#else", "TwoWire * bus = (TwoWire*) pltf->i2c;", "#endif", "", "PASCO2SerialIno cotwo(bus);", "", "Diag_t diagnosis;", "", "void setup()", "{", "  Error_t err = cotwo.getDiagnosis(diagnosis);", "  if(pasco2::OK != err)", "  {", "    Serial.print(\"error: \");", "    Serial.println(err);", "  }", "", "  Serial.print(\"temperature ouf of range  : \");", "  Serial.println(diagnosis.outOfRangeTempError);", "}"]}
{"code": "#ifndef _DEMO_UDF_INO_\r\n#define _DEMO_UDF_INO_\r\n\r\nvoid demoUDF() \r\n{\r\n  showDemoText(TN_UDF);\r\n  char msg[6] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x00};\r\n  myOLED.setFont(OLED_font6x8);\r\n  myOLED.printFlashMsg(0,0, tname[TN_UDF]);\r\n  myOLED.setFont(CN16x16, false);\r\n  for (int i=2; i < 7; i += 2) myOLED.print((i-2) * 10, i, msg);\r\n  OLEDshow();\r\n  delay(3000);\r\n}\r\n\r\n#endif", "line": 11, "slice": ["void demoUDF() ", "{", "  char msg[6] = {0x10, 0x11, 0x12, 0x13, 0x14, 0x00};", "  for (int i=2; i < 7; i += 2) myOLED.print((i-2) * 10, i, msg);", "}"]}
{"code": "#ifdef ENABLE_ADS\n\n#include <Adafruit_ADS1015.h>\n\n Adafruit_ADS1115 ads;  /* Use this for the 16-bit version */\n\nvoid ads_start(void) \n{\n  // The ADC input range (or gain) can be changed via the following\n  // functions, but be careful never to exceed VDD +0.3V max, or to\n  // exceed the upper and lower limits if you adjust the input range!\n  // Setting these values incorrectly may destroy your ADC!\n  //                                                                ADS1015  ADS1115\n  //                                                                -------  -------\n  // ads.setGain(GAIN_TWOTHIRDS);  // 2/3x gain +/- 6.144V  1 bit = 3mV      0.1875mV (default)\n  // ads.setGain(GAIN_ONE);        // 1x gain   +/- 4.096V  1 bit = 2mV      0.125mV\n  // ads.setGain(GAIN_TWO);        // 2x gain   +/- 2.048V  1 bit = 1mV      0.0625mV\n  // ads.setGain(GAIN_FOUR);       // 4x gain   +/- 1.024V  1 bit = 0.5mV    0.03125mV\n  // ads.setGain(GAIN_EIGHT);      // 8x gain   +/- 0.512V  1 bit = 0.25mV   0.015625mV\n  // ads.setGain(GAIN_SIXTEEN);    // 16x gain  +/- 0.256V  1 bit = 0.125mV  0.0078125mV\n  \n  ads.begin();\n  //ads.setGain(GAIN_TWOTHIRDS);\n}\n\nvoid ads_read() {\n  int16_t adc0, adc1, adc2, adc3;\n\n  adc0 = ads.readADC_SingleEnded(0);\n  adc1 = ads.readADC_SingleEnded(1);\n  adc2 = ads.readADC_SingleEnded(2);\n  adc3 = ads.readADC_SingleEnded(3);\n  Serial.print(F(\"<ADS_READ1=\")); Serial.print(adc0);\n  Serial.print(F(\"><ADS_READ2=\")); Serial.print(adc1);\n  Serial.print(F(\"><ADS_READ3=\")); Serial.print(adc2);\n  Serial.print(F(\"><ADS_READ4=\")); Serial.print(adc3);\n  Serial.println(F(\">\"));\n  \n}\n\n\n\n#endif\r\n", "line": 33, "slice": ["#include <Adafruit_ADS1015.h>", "", " Adafruit_ADS1115 ads;  /* Use this for the 16-bit version */", "", "void ads_start(void) ", "{", "  ads.begin();", "}", "", "void ads_read() {", "  int16_t adc0, adc1, adc2, adc3;", "", "  adc0 = ads.readADC_SingleEnded(0);", "  adc1 = ads.readADC_SingleEnded(1);", "  adc2 = ads.readADC_SingleEnded(2);", "  adc3 = ads.readADC_SingleEnded(3);", "  Serial.print(F(\"<ADS_READ1=\")); Serial.print(adc0);", "  Serial.print(F(\"><ADS_READ2=\")); Serial.print(adc1);", "  Serial.print(F(\"><ADS_READ3=\")); Serial.print(adc2);", "  Serial.print(F(\"><ADS_READ4=\")); Serial.print(adc3);", "  Serial.println(F(\">\"));", "}"]}
{"code": "#include <sfud.h>\n\n#define SFUD_DEMO_TEST_BUFFER_SIZE                     1024\nstatic uint8_t sfud_demo_test_buf[SFUD_DEMO_TEST_BUFFER_SIZE] = {0};\nstatic void sfud_demo(uint32_t addr, size_t size, uint8_t *data);\n\t\n#define SERIAL Serial\n\nvoid setup()\n{\n    SERIAL.begin(115200);\n    while(!SERIAL) {};\n    while(!(sfud_init() == SFUD_SUCCESS));\n    #ifdef SFUD_USING_QSPI\n    sfud_qspi_fast_read_enable(sfud_get_device(SFUD_W25Q32_DEVICE_INDEX), 2);\n    #endif\n    const sfud_flash *flash = sfud_get_device_table() + 0;\n    uint32_t addr = 0;\n    size_t size = sizeof(sfud_demo_test_buf);\n    uint8_t result = sfud_read(flash, addr, size, sfud_demo_test_buf);\n    if (result == SFUD_SUCCESS) {\n        SERIAL.println(\"Read the flash data success.\");\n        SERIAL.println(\"Offset (h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\r\\n\");\n        for (int i = 0; i < size; i++) {\n            if (i % 16 == 0) {\n                SERIAL.print(\"0x\");\n                SERIAL.print(addr + i,HEX);\n                SERIAL.print(\"\\t\");\n            }\n            SERIAL.print(sfud_demo_test_buf[i],HEX);\n            SERIAL.print(\"\\t\");\n            if (((i + 1) % 16 == 0) || i == size - 1) {\n                SERIAL.println(\"\");\n            }\n        }\n        SERIAL.println(\" \");\n    } else {\n        SERIAL.println(\"Read the flash data failed.\");\n    }\n}\n\nvoid loop()\n{     \n}", "line": 26, "slice": ["#define SFUD_DEMO_TEST_BUFFER_SIZE                     1024", "static uint8_t sfud_demo_test_buf[SFUD_DEMO_TEST_BUFFER_SIZE] = {0};", "#define SERIAL Serial", "void setup()", "{", "    SERIAL.begin(115200);", "    while(!SERIAL) {};", "    while(!(sfud_init() == SFUD_SUCCESS));", "    const sfud_flash *flash = sfud_get_device_table() + 0;", "    uint32_t addr = 0;", "    size_t size = sizeof(sfud_demo_test_buf);", "    uint8_t result = sfud_read(flash, addr, size, sfud_demo_test_buf);", "    if (result == SFUD_SUCCESS) {", "        SERIAL.println(\"Read the flash data success.\");", "        SERIAL.println(\"Offset (h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\\r\\n\");", "        for (int i = 0; i < size; i++) {", "            if (i % 16 == 0) {", "                SERIAL.print(\"0x\");", "                SERIAL.print(addr + i,HEX);", "                SERIAL.print(\"\\t\");", "            }", "            SERIAL.print(sfud_demo_test_buf[i],HEX);", "            SERIAL.print(\"\\t\");", "            if (((i + 1) % 16 == 0) || i == size - 1) {", "                SERIAL.println(\"\");", "            }", "        }", "        SERIAL.println(\" \");", "    } else {", "        SERIAL.println(\"Read the flash data failed.\");", "    }", "}"]}
{"code": "\r\ntypedef uint8_t Pins;\r\ntypedef char buffer;\r\nPins Pir_pin = 2;\r\nbuffer buff[50];\r\nbool check_for_movement() {\r\n  return digitalRead(Pir_pin);\r\n}\r\nvoid setup() {\r\n  pinMode(Pir_pin, INPUT);\r\n  Serial.begin(9600);\r\n}\r\nchar* getHighorLow(bool state1) {\r\n  if (state1) {\r\n    return \"movement detected\";\r\n  }\r\n  else {\r\n    return \"movement not detected\";\r\n  }\r\n}\r\nvoid loop() {\r\n  sprintf(buff, \"%s \\n\", getHighorLow(check_for_movement()));\r\n                  Serial.print(buff);\r\n                  delay(500);\r\n}\r\n", "line": 23, "slice": ["typedef uint8_t Pins;", "Pins Pir_pin = 2;", "bool check_for_movement() {", "  return digitalRead(Pir_pin);", "}", "char* getHighorLow(bool state1) {", "  if (state1) {", "    return \"movement detected\";", "  }", "  else {", "    return \"movement not detected\";", "  }", "}", "void loop() {", "  sprintf(buff, \"%s \\n\", getHighorLow(check_for_movement()));", "}"]}
{"code": "// Search pins uasable for endstop-interupts\n// Compile with the same settings you'd use with Marlin.\n\n#if defined(ARDUINO_AVR_MEGA2560) || defined(ARDUINO_AVR_MEGA)\n    #undef  digitalPinToPCICR\n    #define digitalPinToPCICR(p)    ( (((p) >= 10) && ((p) <= 15)) || \\\n                                    (((p) >= 50) && ((p) <= 53)) || \\\n                                    (((p) >= 62) && ((p) <= 69)) ? (&PCICR) : ((uint8_t *)0) )\n#endif\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"PINs causing interrups are:\");\n  for(int i=2; i<NUM_DIGITAL_PINS; i++){\n    if( digitalPinToPCICR(i) != NULL || (int)digitalPinToInterrupt(i) != -1 ) {\n      for (int j= 0; j<NUM_ANALOG_INPUTS; j++){\n        if(analogInputToDigitalPin(j) == i) {\n          Serial.print(\"A\");\n          Serial.print(j);\n          Serial.print(\" = \");\n        }\n      }\n      Serial.print(\"D\");\n      Serial.println(i);\n    }\n  }\n  Serial.println(\"Arduino pin numbering!\");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n}\n", "line": 18, "slice": ["#if defined(ARDUINO_AVR_MEGA2560) || defined(ARDUINO_AVR_MEGA)", "    #undef  digitalPinToPCICR", "    #define digitalPinToPCICR(p)    ( (((p) >= 10) && ((p) <= 15)) || \\", "                                    (((p) >= 50) && ((p) <= 53)) || \\", "                                    (((p) >= 62) && ((p) <= 69)) ? (&PCICR) : ((uint8_t *)0) )", "#endif", "", "void setup() {", "  for(int i=2; i<NUM_DIGITAL_PINS; i++){", "    if( digitalPinToPCICR(i) != NULL || (int)digitalPinToInterrupt(i) != -1 ) {", "      for (int j= 0; j<NUM_ANALOG_INPUTS; j++){", "        if(analogInputToDigitalPin(j) == i) {", "          Serial.print(\"A\");", "          Serial.print(j);", "          Serial.print(\" = \");", "        }", "      }", "      Serial.print(\"D\");", "      Serial.println(i);", "    }", "  }", "}"]}
{"code": "The `minimum` argument allows you to specify the minimum value for a parameter. This meaning changes based on the `type` and whether or not the `multi` flag is enabled. If the `multi` flag is enabled, then minimum is referring to the list length minimum. Otherwise, if `type` is integer, it will compare the value of the parameter to the minimum. Otherwise if the `type` is a string, it will ensure the length of the string is within bounds.\n\n[source,python]\n.Minimum argument example\n----\n@parameter(key=\"foo\", type=\"String\", minimum=1)\n@parameter(key=\"bar\", type=\"Integer\", minimum=1)\n@parameter(key=\"bazs\", type=\"String\", minimum=1)\ndef do_something(self, foo, bar, bazs):\n    # guarantees that foo is at least 1 character\n    # guarantees that bar is no less than 1\n    # guarantees that bazs is no less than 1 item long\n    print(foo)\n    print(bar)\n    print(bazs)\n----\n", "line": 13, "slice": ["@parameter(key=\"foo\", type=\"String\", minimum=1)", "def do_something(self, foo, bar, bazs):", "    print(foo)"]}
{"code": "The `optional` field allows you to specify whether or not the parameter is optional or required. The default depends on if there is a default value in the method definition.\n\n[source,python]\n.Optional argument example\n----\n@parameter(key=\"foo\", optional=True, nullable=True))\ndef do_something(self, foo):\n    # By default, foo would not be optional but\n    # it is specified in the param so it's assumed\n    # the developer will handle the None case.\n    if foo is None:\n        print(\"foo is empty!\")\n    else:\n        print(foo)\n----\n\nIf a default is passed in, then optional will be set to True by default.\n\nTIP: If you specify that something is optional, then it must also be nullable if no default is specified.\n", "line": 12, "slice": ["The `optional` field allows you to specify whether or not the parameter is optional or required. The default depends on if there is a default value in the method definition.", "", "[source,python]", ".Optional argument example", "----", "@parameter(key=\"foo\", optional=True, nullable=True))", "def do_something(self, foo):", "    # By default, foo would not be optional but", "    # it is specified in the param so it's assumed", "    # the developer will handle the None case.", "    if foo is None:", "        print(\"foo is empty!\")", "    else:", "        print(foo)", "----", "", "If a default is passed in, then optional will be set to True by default."]}
{"code": "# Benchmarking\n\nThis week I've been developing a simple benchmark to test how much time the actual implementation of indexing and querying the database was taking. Firstly, I downloaded all the unthresholded images available at the momment in Neurovault (5015) to test the benchmark with real data. I made use of the code from link:http://code.activestate.com/recipes/577896-benchmark-code-with-the-with-statement/[this post] to retrieve the time each sentence/function was taking. All the results reported in this post depend, obviously, on the machine they are being executed. This is the Class used for the benchmark:\n\n`import gc\nimport timeit\nclass Timer:\n     def __init__(self, timer=None, disable_gc=False, verbose=True):\n         if timer is None:\n             timer = timeit.default_timer\n         self.timer = timer\n         self.disable_gc = disable_gc\n         self.verbose = verbose\n         self.start = self.end = self.interval = None\n     def __enter__(self):\n         if self.disable_gc:\n             self.gc_state = gc.isenabled()\n             gc.disable()\n         self.start = self.timer()\n         return self\n     def __exit__(self, *args):\n         self.end = self.timer()\n         if self.disable_gc and self.gc_state:\n             gc.enable()\n         self.interval = self.end - self.start\n         if self.verbose:\n             print('time taken: %f seconds' % self.interval)`        \n\n \nI made a pair of plots to represent the time that actual implementation takes. I have tested both functions with the server performing no task and several tasks. The first one shows the amount of time that the indexing takes. As the actual implementation is a one to one (paired) calculation, each time an Image is added the comparison value has to be calculated for every one of the pairs, making it computationally quite expensive to escalate (70 seconds for an indexing operation with a 5000 image database is expensive to maintain).\n\nimage:https://cloud.githubusercontent.com/assets/6176948/15671549/a8a5b350-272b-11e6-94f3-1742dc2d05f6.png[]\n\nIn the other hand, the query benchmark resulted in a very efficient result: \n \nimage:https://cloud.githubusercontent.com/assets/6176948/15717964/880133aa-2829-11e6-9b46-ec7b68c04579.png[]\n\nFractions of a second for a big amount of images is a quite good results. This second benchmark was done in a machine with an SSD unit, compared to the first one made over a normal HD. I know that these are not comparable measures, but these figures allow us to understand which are the magnitudes we are dealing with and to see how the functions escalate with real data. \n\nOur goal for this summer is to beat the indexing times with a big margin and to try to approximate the good results of the queries.\n\nTo sum up, this week I coded some benchmarks to test how much time does with the actual implementation take to index and query the database. Then, I integrated them in a single command that can be executed from the Neurovault's shell.\nFor the next week I will validate the benchmark results with the mentor and try to set up a proper feature extraction protocol.\n\n", "line": 27, "slice": ["`import gc", "import timeit", "class Timer:", "     def __init__(self, timer=None, disable_gc=False, verbose=True):", "         if timer is None:", "             timer = timeit.default_timer", "         self.timer = timer", "         self.disable_gc = disable_gc", "         self.verbose = verbose", "         self.start = self.end = self.interval = None", "     def __enter__(self):", "         if self.disable_gc:", "             self.gc_state = gc.isenabled()", "             gc.disable()", "         self.start = self.timer()", "         return self", "     def __exit__(self, *args):", "         self.end = self.timer()", "         if self.disable_gc and self.gc_state:", "             gc.enable()", "         self.interval = self.end - self.start", "         if self.verbose:", "             print('time taken: %f seconds' % self.interval)`"]}
{"code": "The `model` argument allows you to specify some structure for a complicated object. Have a look at the following for an example of how to use the `model` field.\n\n[source,python]\n.Model argument example\n----\nfrom brewtils.models import Parameter\nclass Person(object):\n\n  name = Parameter(key=\"name\",\n                   type=\"String\",\n                   description=\"Person's name\")\n  age = Parameter(key=\"age\",\n                  type=\"Integer\",\n                  description=\"Person's age\")\n\nclass ExampleClient(object):\n\n    @parameter(key=\"person\", model=Person)\n    def greet(self, person):\n        print(\"Hello %s\" % person.name)\n----\n\nNOTE: It is assumed that if you have a model, that the type is \"Dictionary\"\n", "line": 20, "slice": ["from brewtils.models import Parameter", "class Person(object):", "", "  name = Parameter(key=\"name\",", "                   type=\"String\",", "                   description=\"Person's name\")", "", "class ExampleClient(object):", "", "    @parameter(key=\"person\", model=Person)", "    def greet(self, person):", "        print(\"Hello %s\" % person.name)"]}
{"code": "[source,python]\n.plugin.py\n----\nfrom brewtils import command, system, Plugin\n\n\n@system\nclass HelloWorldClient(object):\n\n    @command\n    def hello_world(self):\n        greeting = \"Hello, World!\"\n\n        print(greeting)\n\n        return greeting\n\n\ndef main():\n    client = HelloWorldClient()\n\n    plugin = Plugin(\n        client,\n        name='hello-world',\n        version='1.0.0',\n        description='My First Plugin',\n        bg_host=\"<HOST>\",\n        bg_port=\"<PORT>\",\n        ssl_enabled=<SSL_ENABLED>,\n    )\n    plugin.run()\n\n\nif __name__ == \"__main__\":\n    main()\n----\n\nTo review what's happening here: we added an import `Plugin` at the top of our file and created a standard main method. In that method we created a `HelloWorldClient` object and a `Plugin` object. Notice that when we create the `Plugin` we pass it the client and some additional parameters. Don't worry too much about the additional paramters - we'll cover them later.\n", "line": 14, "slice": ["[source,python]", ".plugin.py", "----", "from brewtils import command, system, Plugin", "", "", "@system", "class HelloWorldClient(object):", "", "    @command", "    def hello_world(self):", "        greeting = \"Hello, World!\"", "", "        print(greeting)", "", "        return greeting", "", "", "def main():", "    client = HelloWorldClient()", "", "    plugin = Plugin(", "        client,", "        name='hello-world',", "        version='1.0.0',", "        description='My First Plugin',", "        bg_host=\"<HOST>\",", "        bg_port=\"<PORT>\",", "        ssl_enabled=<SSL_ENABLED>,", "    )", "", "", "if __name__ == \"__main__\":", "    main()", "----"]}
{"code": "The `multi` field let's Beer Garden know that the parameter should be a list. Most of the other fields stay the same and continue to describe the individual items in the list.\n\n[source,python]\n.Multi argument example\n----\n@parameter(key=\"list_of_strings\", multi=True, type=\"String\")\ndef do_something(self, list_of_strings):\n    for s in list_of_strings:\n        print(s)\n----\n\nTIP: Some of the fields do change meaning when you've specified that multi\nis true. See the below table for a more detailed description.\n\n.Multi Changes These Arguments\n[options=\"header\"]\n|===\n|Argument | How is it changed?\n|choices | Choices specify the only valid values, no value can be repeated.\n|maximum | Specifies Maximum length of the list\n|minimum | Specifies Minimum length of the list\n|===\n", "line": 9, "slice": ["@parameter(key=\"list_of_strings\", multi=True, type=\"String\")", "def do_something(self, list_of_strings):", "    for s in list_of_strings:", "        print(s)"]}
{"code": "\n== Starlark\n\n[source,python]\n----\ndef fizz_buzz(n):\n  \"\"\"Print Fizz Buzz numbers from 1 to n.\"\"\"\n  for i in range(1, n + 1):\n    s = \"\"\n    if i % 3 == 0:\n      s += \"Fizz\"\n    if i % 5 == 0:\n      s += \"Buzz\"\n    print(s if s else i)\n\nfizz_buzz(20)\n----\n\n[.notes]\n--\n* Les variables globales sont immutables\n* Les `for` et `if` utilisables que dans des fonctions\n* Recursion impossible\n* Modifier une collection pendant une it\u00e9ration\n* Les `class` et `import` non support\u00e9s (`struct` et `load`).\n* Les `string` sont entre double quotes\n* ...\n\n--\n\n// === Diff\u00e9rence avec Python\n\n// [%step]\n\n\n// [.notes]\n// --\n// --\n\n// [.hidden-title]\n// === Diff\u00e9rence avec Python\n\n// [.fullscreen]\n// [source,python]\n// include::starlark-file.adoc[]\n", "line": 14, "slice": ["[source,python]", "----", "def fizz_buzz(n):", "  for i in range(1, n + 1):", "    s = \"\"", "    if i % 3 == 0:", "      s += \"Fizz\"", "    if i % 5 == 0:", "      s += \"Buzz\"", "    print(s if s else i)", "", "fizz_buzz(20)", "----"]}
{"code": "The `default` field allows you to specify the default value for a parameter if it is not given by a user. If there is a default value in the method definition then it will use that.\n\n[source,python]\n.Default argument example\n----\n@parameter(key=\"foo\")\ndef do_something(self, foo=\"bar\"):\n  print(foo)\n----\n\nIn the above case, if someone utilizes this command but does not pass Beer Garden the `foo` parameter, then Beer Garden will default it to `bar`. Below is another example of how to use the default argument.\n\n[source,python]\n.Default argument example\n----\n@parameter(key=\"foo\", default=\"bar\"))\ndef do_something(self, foo):\n    print(foo)\n----\n\nThese are functionally equivalent for Beer Garden.\n", "line": 8, "slice": ["The `default` field allows you to specify the default value for a parameter if it is not given by a user. If there is a default value in the method definition then it will use that.", "", "[source,python]", ".Default argument example", "----", "@parameter(key=\"foo\")", "def do_something(self, foo=\"bar\"):", "  print(foo)", "----", "", "In the above case, if someone utilizes this command but does not pass Beer Garden the `foo` parameter, then Beer Garden will default it to `bar`."]}
{"code": "== Sensors\n\nThere is a xref:build-hat.adoc#device-compatibility[large range of sensors] that work with the Build HAT.\n\n=== Working with Sensors\n\nConnect a Colour sensor to port B on the Build HAT, and a Force sensor to port C.\n\nNOTE: If you\u2019re not intending to drive a motor, then you don\u2019t need an external power supply and you can use a standard USB power supply for your Raspberry Pi.\n\nCreate another new program:\n\n[source,python,linenums]\n----\nfrom signal import pause\nfrom buildhat import ForceSensor, ColorSensor\n\nbutton = ForceSensor('C')\ncs = ColorSensor('B')\n\ndef handle_pressed():\n    cs.on()\n    print(c.get_color())\n\ndef handle_released():\n    cs.off()\n----\n\nRun it and hold a coloured object (LEGO\u00ae elements are ideal) in front of the colour sensor and press the Force sensor plunger. The sensor\u2019s LED should switch on and the name of the closest colour should be displayed in the thonny REPL. \n", "line": 23, "slice": ["[source,python,linenums]", "----", "from signal import pause", "from buildhat import ForceSensor, ColorSensor", "", "button = ForceSensor('C')", "cs = ColorSensor('B')", "", "def handle_pressed():", "    cs.on()", "    print(c.get_color())", "", "def handle_released():", "    cs.off()", "----", "", "Run it and hold a coloured object (LEGO\u00ae elements are ideal) in front of the colour sensor and press the Force sensor plunger. The sensor\u2019s LED should switch on and the name of the closest colour should be displayed in the thonny REPL."]}
{"code": "// Module included in the following assemblies\n// /functions/dev_guide/develop-python.adoc\n\n// [id=\"invoking-python\"]\n// = Invoking Python functions\n\nPython functions can be invoked with a simple HTTP request. When an incoming request is received, functions are invoked with a `context` object as the first parameter.\n\n== Context objects\n\nFunctions are invoked by providing a `context` object as the first parameter. This object is a Python class with two attributes.\n\n* The `request` attribute will always be present, and contains the Flask `request` object.\n* The second attribute, `cloud_event`, will be populated if the incoming request is a `CloudEvent`.\n\nDevelopers may access any `CloudEvent` data from the context object.\n\n.Example context object\n[source,python]\n----\ndef main(context: Context):\n    \"\"\"\n    The context parameter contains the Flask request object and any\n    CloudEvent received with the request.\n    \"\"\"\n    print(f\"Method: {context.request.method}\")\n    print(f\"Event data {context.cloud_event.data})\n    # ... business logic here\n----\n", "line": 26, "slice": ["Python functions can be invoked with a simple HTTP request. When an incoming request is received, functions are invoked with a `context` object as the first parameter.", "", "Functions are invoked by providing a `context` object as the first parameter. This object is a Python class with two attributes.", "", "* The `request` attribute will always be present, and contains the Flask `request` object.", "* The second attribute, `cloud_event`, will be populated if the incoming request is a `CloudEvent`.", "", ".Example context object", "[source,python]", "----", "def main(context: Context):", "    \"\"\"", "    The context parameter contains the Flask request object and any", "    CloudEvent received with the request.", "    \"\"\"", "    print(f\"Method: {context.request.method}\")", "    print(f\"Event data {context.cloud_event.data})", "    # ... business logic here", "----"]}
{"code": "= Glossary\n\n== Magic\nSufficiently advanced technology, beyond the understanding of the observer producing a sense of wonder.\n\nHello, I am random noise in the middle of this beautiful Glossary. (Really astonishing !)\n\n== PHP\nAn atrocious language, invented for the sole purpose of inflicting pain and suffering amongst the proframming wizards of this world.\n\n== Clojure\nLisp re-invented for hipsters.\n\n== Go\nGo Go Google [Wow](https://www.google.com)\n\nFantastic, I love code too ! :\n\n```py\n\ndef f(x):\n    return x * 4\n\n# Wow this is some really awesome code\n# totally mind blowing\n# but we don't care, it shouldn't be in our glossary !\nprint(f(9))\n```\n\n== Gitbook\n\nAwesome project. Really amazing, I'm really at a loss for words ...\n", "line": 27, "slice": ["== Magic", "Sufficiently advanced technology, beyond the understanding of the observer producing a sense of wonder.", "", "== PHP", "An atrocious language, invented for the sole purpose of inflicting pain and suffering amongst the proframming wizards of this world.", "", "== Clojure", "Lisp re-invented for hipsters.", "", "== Go", "Go Go Google [Wow](https://www.google.com)", "", "== Gitbook", "", "Awesome project. Really amazing, I'm really at a loss for words ..."]}
{"code": "The `maximum` argument allows you to specify the maximum value for a parameter. This meaning changes based on the `type` and whether or not the `multi` flag is enabled. If the `multi` flag is enabled, then maximum is referring to the list length maximum. Otherwise, if `type` is integer, it will compare the value of the parameter to the maximum. Otherwise if the `type` is a string, it will ensure the length of the string is within bounds.\n\n[source,python]\n.Maximum argument example\n----\n@parameter(key=\"foo\", type=\"String\", maximum=1)\n@parameter(key=\"bar\", type=\"Integer\", maximum=1)\n@parameter(key=\"bazs\", type=\"String\", maximum=1)\ndef do_something(self, foo, bar, bazs):\n    # guarantees that foo is 1 character at most\n    # guarantees that bar is no more than 1\n    # guarantees that bazs is no more than 1 item long\n    print(foo)\n    print(bar)\n    print(bazs)\n----\n", "line": 13, "slice": ["The `maximum` argument allows you to specify the maximum value for a parameter. This meaning changes based on the `type` and whether or not the `multi` flag is enabled. If the `multi` flag is enabled, then maximum is referring to the list length maximum. Otherwise, if `type` is integer, it will compare the value of the parameter to the maximum. Otherwise if the `type` is a string, it will ensure the length of the string is within bounds.", "", "[source,python]", ".Maximum argument example", "----", "@parameter(key=\"foo\", type=\"String\", maximum=1)", "@parameter(key=\"bar\", type=\"Integer\", maximum=1)", "@parameter(key=\"bazs\", type=\"String\", maximum=1)", "def do_something(self, foo, bar, bazs):", "    print(foo)", "    print(bar)", "    print(bazs)", "----"]}
{"code": "[source,python]\n.+__main__.py+\n----\nfrom brewtils.decorators import system, parameter\nfrom brewtils.plugin import RemotePlugin\n\n@system\nclass MyClient(object):\n\n    @parameter(key=\"message\", type=\"String\")\n    def do_something(self, message):\n        print(message)\n        return message\n\n\nif __name__ == \"__main__\":\n    client = MyClient()\n    plugin = RemotePlugin(client, name=\"my-plugin\",\n                          version=\"0.0.1.dev0\",\n                          bg_host='brew-view',\n                          bg_port=2337, ssl_enabled=False)\n    plugin.run()\n----\n", "line": 12, "slice": ["from brewtils.plugin import RemotePlugin", "", "class MyClient(object):", "", "    def do_something(self, message):", "        print(message)", "        return message", "", "if __name__ == \"__main__\":", "    client = MyClient()", "    plugin = RemotePlugin(client, name=\"my-plugin\",", "                          version=\"0.0.1.dev0\",", "                          bg_host='brew-view',", "                          bg_port=2337, ssl_enabled=False)", "    plugin.run()"]}
{"code": "= Concurrency \n\n== Race conditions\nAs two threads can read and write to the same location the value depends on the order of the reads and writes.\n\n=== OOP Concurrency\nObjects have no concurrency coordination leading to nondeterministic results. Multiple threads reading and writing the the same location (Object, PLOP).\n\nWARNING: One increment could be lost. If both Threads run simultaneously, both will read Count of 0 and update to 1 so one increment will be missed. \n\n[source, python]\n----\nclass Counter:\n    def __init__(self):\n        self.count = 0\n\n    def Increment():\n        self.counter += 1\n\nmyCount = new Counter()\n\na = threading.Thread(myCount.Increment());\nb = threading.Thread(myCount.Increment());\n\na.start();\nb.start();\na.join();\nb.join();\n\nprint(myCount.Count) # 1 or 2 ??\n----\n\n=== Mutual Exclusion (Mutex)\nMake your program single threaded.\n\n=== Deadlocks \nMake your program single threaded.\n\n== Clojure Concurrency\nClojure adds concurrency models to handle updating state.\n\n* atom\n** reference type like the epochal time model below \n* refs\n** transactions - all or nothing\n* core.async \n\nimage::time_model.jpg[Epochal Time Model, 640, 400]  ", "line": 30, "slice": ["[source, python]", "----", "class Counter:", "    def __init__(self):", "        self.count = 0", "", "    def Increment():", "        self.counter += 1", "", "myCount = new Counter()", "", "a = threading.Thread(myCount.Increment());", "b = threading.Thread(myCount.Increment());", "", "a.start();", "b.start();", "a.join();", "b.join();", "", "print(myCount.Count) # 1 or 2 ??", "----"]}
{"code": "[source,python]\n.plugin.py\n----\nfrom brewtils import command, system\n\n@system # <1>\nclass HelloWorldClient(object):\n\n    @command <2>\n    def hello_world(self):\n        greeting = \"Hello, World!\"\n\n        print(greeting)\n\n        return greeting\n----\n<1> The `@system` decorator marks this class as a Beer Garden plugin.\n<2> The `@command` decorator marks this method as a Command that's part of the enclosing System.\n", "line": 13, "slice": ["[source,python]", ".plugin.py", "----", "from brewtils import command, system", "", "@system # <1>", "class HelloWorldClient(object):", "", "    @command <2>", "    def hello_world(self):", "        greeting = \"Hello, World!\"", "", "        print(greeting)", "----"]}
{"code": "// Module included in the following assemblies\n//\n// * serverless/functions/serverless-developing-python-functions.adoc\n\n:_content-type: CONCEPT\n[id=\"serverless-invoking-python-functions_{context}\"]\n= About invoking Python functions\n\nPython functions can be invoked with a simple HTTP request. When an incoming request is received, functions are invoked with a `context` object as the first parameter. The `context` object is a Python class with two attributes:\n\n* The `request` attribute is always present, and contains the Flask `request` object.\n* The second attribute, `cloud_event`, is populated if the incoming request is a `CloudEvent` object.\n\nDevelopers can access any `CloudEvent` data from the context object.\n\n.Example context object\n[source,python]\n----\ndef main(context: Context):\n    \"\"\"\n    The context parameter contains the Flask request object and any\n    CloudEvent received with the request.\n    \"\"\"\n    print(f\"Method: {context.request.method}\")\n    print(f\"Event data {context.cloud_event.data}\")\n    # ... business logic here\n----\n", "line": 24, "slice": ["Python functions can be invoked with a simple HTTP request. When an incoming request is received, functions are invoked with a `context` object as the first parameter. The `context` object is a Python class with two attributes:", "", "* The `request` attribute is always present, and contains the Flask `request` object.", "* The second attribute, `cloud_event`, is populated if the incoming request is a `CloudEvent` object.", "", "Developers can access any `CloudEvent` data from the context object.", "", ".Example context object", "[source,python]", "----", "def main(context: Context):", "    \"\"\"", "    The context parameter contains the Flask request object and any", "    CloudEvent received with the request.", "    \"\"\"", "    print(f\"Method: {context.request.method}\")", "    print(f\"Event data {context.cloud_event.data}\")", "    # ... business logic here", "----"]}
{"code": "[source,python]\n.+__main__.py+\n----\nfrom brewtils import system, parameter, Plugin\n\n\n@system\nclass HelloClient(object):\n\n    @parameter(key=\"message\", type=\"String\", default=\"Hello, World!\")\n    def say_hello(self, message):\n        print(message)\n        \n        return message\n\n\nif __name__ == \"__main__\":\n    plugin = Plugin(\n        name=\"hello-world\",\n        version=\"0.0.1.dev0\",\n        bg_host='localhost',\n        bg_port=80,\n        ssl_enabled=False,\n    )\n    plugin.client = HelloClient()\n    plugin.run()\n----\n", "line": 12, "slice": ["from brewtils import system, parameter, Plugin", "", "@system", "class HelloClient(object):", "", "    @parameter(key=\"message\", type=\"String\", default=\"Hello, World!\")", "    def say_hello(self, message):", "        print(message)", "        ", "        return message", "", "if __name__ == \"__main__\":", "    plugin = Plugin(", "        name=\"hello-world\",", "        version=\"0.0.1.dev0\",", "        bg_host='localhost',", "        bg_port=80,", "        ssl_enabled=False,", "    )", "    plugin.client = HelloClient()"]}
{"code": "== Day 04\n\nThis solution is written in python.\n\nRun using:\n$ python solution.py\n\nThe central idea is to read in the whole input as one string\n(yes for larger inputs this is a no-go because of memory-usage...)\nand to extract the passports using simple String.split-functions\nfor validation (star2), we make use of the standard regular expression-library re.\n\n```python\n    with open(input_filename, 'r') as input:\n        all_passports = input.read()\n        passports = re.split('\\n\\n', all_passports)\n        for chunk in passports:\n            passport = re.split('\\\\s', chunk)\n            all_fields_values = [(x.split(':')[0], x.split(':')[1]) for x in filter(lambda x: x!='', passport)]\n            fields = list(map(lambda x: x[0], all_fields_values))\n```\n\n=== First Star\n\nFor the first star, we only have to check if all required fields are present:\n```python\ndef is_valid_star1(fields):\n    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']\n    return all([x in fields for x in required_fields])\n```\n\n=== Second Star\nFor the second star, we check in addition\nwhether the stated requirements on passports are satisfied.\nThis checking optimistically tries to access a field\nin a passport (the whole block is surrounded by a try...except\nand if a field is not present, the passport is invalid).\nAll the checks are fairly easy, the only case that cost\nme significant time to debug was the checking of the passport-ID.\nIt is very important that the number is *at most* 9 digits.\nSo \"[0-9]{9}\" will also wrongly match a 10-digit pid --\nhence we have to make sure that we see a newline after the pid:\n```python\n[...]\n        if not re.match('[0-9]{9}$', fields_with_values['pid']):\n            print('pid invalid')\n            return False\n[...]\n```", "line": 46, "slice": ["```python", "    with open(input_filename, 'r') as input:", "        all_passports = input.read()", "        passports = re.split('\\n\\n', all_passports)", "        for chunk in passports:", "            passport = re.split('\\\\s', chunk)", "            all_fields_values = [(x.split(':')[0], x.split(':')[1]) for x in filter(lambda x: x!='', passport)]", "            fields = list(map(lambda x: x[0], all_fields_values))", "```", "```python", "[...]", "        if not re.match('[0-9]{9}$', fields_with_values['pid']):", "            print('pid invalid')", "            return False", "[...]", "```"]}
{"code": "// Test declaring a variable as at a hard-coded address\n// mainmem-page hard-coded address parameter\n  // Commodore 64 PRG executable file\n.file [name=\"address-6.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(__start)\n  .label SCREEN = $400\n  .label idx = $3000\n.segment Code\n__start: {\n    // volatile char __address(0x3000) idx\n    lda #0\n    sta idx\n    jsr main\n    rts\n}\nmain: {\n    // print('c')\n    lda #'c'\n    sta.z print.ch\n    jsr print\n    // print('m')\n    lda #'m'\n    sta.z print.ch\n    jsr print\n    // print('l')\n    lda #'l'\n    sta.z print.ch\n    jsr print\n    // }\n    rts\n}\n// void print(__zp(2) volatile char ch)\nprint: {\n    .label ch = 2\n    // asm\n    ldx idx\n    lda ch\n    sta SCREEN,x\n    inc idx\n    // }\n    rts\n}\n", "line": 22, "slice": [".label idx = $3000", "lda #0", "sta idx", "jsr main", "main: {", "lda #'c'", "sta.z print.ch", "jsr print", "lda #'m'", "sta.z print.ch", "jsr print", "lda #'l'", "sta.z print.ch", "jsr print", "}", "print: {", ".label ch = 2", "ldx idx", "lda ch", "sta SCREEN,x", "inc idx", "}"]}
{"code": "// Tests optimizing derefs of *(ptr+b) to ptr[b]\n  // Commodore 64 PRG executable file\n.file [name=\"deref-to-derefidx.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(main)\n  .label SCREEN = $400\n.segment Code\nmain: {\n    // print(msg1)\n    ldx #0\n    lda #<msg1\n    sta.z print.m\n    lda #>msg1\n    sta.z print.m+1\n    jsr print\n    // print(msg2)\n    lda #<msg2\n    sta.z print.m\n    lda #>msg2\n    sta.z print.m+1\n    jsr print\n    // }\n    rts\n}\n// void print(__zp(2) char *m)\nprint: {\n    .label m = 2\n    // SCREEN[idx++] = *(m+2)\n    ldy #2\n    lda (m),y\n    sta SCREEN,x\n    // SCREEN[idx++] = *(m+2);\n    inx\n    // }\n    rts\n}\n.segment Data\n  msg1: .byte 'a', 'b', 'c', 'd'\n  msg2: .byte '1', '2', '3', '4'\n", "line": 13, "slice": [".segment Code", "main: {", "    ldx #0", "    lda #<msg1", "    sta.z print.m", "    lda #>msg1", "    sta.z print.m+1", "    jsr print", "    lda #<msg2", "    sta.z print.m", "    lda #>msg2", "    sta.z print.m+1", "    jsr print", "    rts", "}", "print: {", "    .label m = 2", "    ldy #2", "    lda (m),y", "    sta SCREEN,x", "    inx", "    rts", "}"]}
{"code": "// Demonstrates Library Constructor Functionality\n// #pragma constructor_for() declares named constructors for other symbols\n  // Commodore 64 PRG executable file\n.file [name=\"library-constructor-1.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(__start)\n  .label SCREEN = $400\n  .label my_value = 2\n.segment Code\n__start: {\n    // volatile char my_value\n    lda #0\n    sta.z my_value\n    // #pragma constructor_for(my_init, print)\n    jsr my_init\n    jsr main\n    rts\n}\nmy_init: {\n    // my_value = '*'\n    lda #'*'\n    sta.z my_value\n    // }\n    rts\n}\nmain: {\n    // print()\n    jsr print\n    // }\n    rts\n}\nprint: {\n    // *SCREEN = my_value\n    lda.z my_value\n    sta SCREEN\n    // }\n    rts\n}\n", "line": 31, "slice": [".segment Basic", ":BasicUpstart(__start)", "  .label SCREEN = $400", "  .label my_value = 2", ".segment Code", "__start: {", "    lda #0", "    sta.z my_value", "    jsr my_init", "    jsr main", "}", "my_init: {", "    lda #'*'", "    sta.z my_value", "    rts", "}", "main: {", "    jsr print", "    rts", "}", "print: {", "    lda.z my_value", "    sta SCREEN", "    rts", "}"]}
{"code": "// Illustrates problem with passing an inline struct value as a parameter\n  // Commodore 64 PRG executable file\n.file [name=\"problem-struct-inline-parameter-1.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(main)\n  .label SCREEN = $400\n.segment Code\nmain: {\n    // print('c', { '-', '-' } )\n    jsr print\n    // }\n    rts\n}\n// void print(char c, char fmt_prefix, char fmt_postfix)\nprint: {\n    .const c = 'c'\n    .const fmt_prefix = '-'\n    .const fmt_postfix = '-'\n    // SCREEN[idx++] = fmt.prefix\n    lda #fmt_prefix\n    sta SCREEN\n    // SCREEN[idx++] = c\n    lda #c\n    sta SCREEN+1\n    // SCREEN[idx++] = fmt.postfix\n    lda #fmt_postfix\n    sta SCREEN+2\n    // }\n    rts\n}\n", "line": 13, "slice": [".segment Code", "main: {", "    jsr print", "    rts", "}", "print: {", "    .const c = 'c'", "    .const fmt_prefix = '-'", "    .const fmt_postfix = '-'", "    lda #fmt_prefix", "    sta SCREEN", "    lda #c", "    sta SCREEN+1", "    lda #fmt_postfix", "    sta SCREEN+2", "    rts", "}"]}
{"code": "// Minimal struct - passing struct value parameter\n  // Commodore 64 PRG executable file\n.file [name=\"struct-3.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(main)\n  .label SCREEN = $400\n.segment Code\nmain: {\n    .label p1_y = 4\n    // print(p1)\n    ldx #0\n    lda #1\n    jsr print\n    // print(p1)\n    lda #2\n    jsr print\n    // }\n    rts\n}\n// void print(__register(A) char p_x, char p_y)\nprint: {\n    // SCREEN[idx++] = p.x\n    sta SCREEN,x\n    // SCREEN[idx++] = p.x;\n    inx\n    // SCREEN[idx++] = p.y\n    lda #main.p1_y\n    sta SCREEN,x\n    // SCREEN[idx++] = p.y;\n    inx\n    // }\n    rts\n}\n", "line": 14, "slice": [".segment Code", "main: {", "    .label p1_y = 4", "    ldx #0", "    lda #1", "    jsr print", "    lda #2", "    jsr print", "    rts", "}", "print: {", "    sta SCREEN,x", "    inx", "    lda #main.p1_y", "    sta SCREEN,x", "    inx", "    rts", "}"]}
{"code": "// Test declaring a variable as at a hard-coded register\n// hard-coded register parameter\n  // Commodore 64 PRG executable file\n.file [name=\"register-0.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(__start)\n  .label SCREEN = $400\n  .label idx = 3\n.segment Code\n__start: {\n    // volatile char __address(0x03) idx\n    lda #0\n    sta.z idx\n    jsr main\n    rts\n}\nmain: {\n    // print('c')\n    lda #'c'\n    sta.z print.ch\n    jsr print\n    // print('m')\n    lda #'m'\n    sta.z print.ch\n    jsr print\n    // print('l')\n    lda #'l'\n    sta.z print.ch\n    jsr print\n    // }\n    rts\n}\n// void print(__zp(2) volatile char ch)\nprint: {\n    .label ch = 2\n    // kickasm\n    // Force usage of ch\n    \n    // asm\n    ldx idx\n    sta SCREEN,x\n    inc idx\n    // }\n    rts\n}\n", "line": 22, "slice": [".segment Basic", ":BasicUpstart(__start)", "  .label SCREEN = $400", "  .label idx = 3", ".segment Code", "__start: {", "    lda #0", "    sta.z idx", "    jsr main", "    rts", "}", "main: {", "    lda #'l'", "    sta.z print.ch", "    jsr print", "    rts", "}", "print: {", "    .label ch = 2", "    ldx idx", "    sta SCREEN,x", "    inc idx", "    rts", "}"]}
{"code": "  // Commodore 64 PRG executable file\n.file [name=\"var-register.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(main)\n.segment Code\nmain: {\n    .label x = 2\n    lda #0\n    sta.z x\n  __b1:\n    ldx #0\n  __b2:\n    ldy #0\n  __b3:\n    // byte val1 = a+x\n    tya\n    clc\n    adc.z x\n    // print(y, val1)\n    jsr print\n    // for( byte a: 0..100 )\n    iny\n    cpy #$65\n    bne __b3\n    // for( byte y: 0..100 )\n    inx\n    cpx #$65\n    bne __b2\n    // for( byte x: 0..100 )\n    inc.z x\n    lda #$65\n    cmp.z x\n    bne __b1\n    // }\n    rts\n}\n// void print(__register(X) char idx, __register(A) char val)\nprint: {\n    .label SCREEN = $400\n    // SCREEN[idx] = val\n    sta SCREEN,x\n    // }\n    rts\n}\n", "line": 23, "slice": [".segment Code", "main: {", "    .label x = 2", "    lda #0", "    sta.z x", "  __b1:", "    ldx #0", "  __b2:", "    ldy #0", "  __b3:", "    tya", "    clc", "    adc.z x", "    jsr print", "    iny", "    cpy #$65", "    bne __b3", "    inx", "    cpx #$65", "    bne __b2", "    inc.z x", "    lda #$65", "    cmp.z x", "    bne __b1", "    rts", "}", "print: {", "    .label SCREEN = $400", "    sta SCREEN,x", "    rts", "}"]}
{"code": "// Test that void-parameter works top specify function takes no parameters\n// Output is \"...\" in the top left corner of the screen\n  // Commodore 64 PRG executable file\n.file [name=\"void-parameter.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(main)\n  .label SCREEN = $400\n.segment Code\nmain: {\n    // print()\n    ldx #0\n    jsr print\n    // print()\n    jsr print\n    // print()\n    jsr print\n    // }\n    rts\n}\nprint: {\n    // SCREEN[idx++] = '.'\n    lda #'.'\n    sta SCREEN,x\n    // SCREEN[idx++] = '.';\n    inx\n    // }\n    rts\n}\n", "line": 14, "slice": [".segmentdef Program [segments=\"Basic, Code, Data\"]", ".segmentdef Basic [start=$0801]", ".segmentdef Code [start=$80d]", ".segmentdef Data [startAfter=\"Code\"]", ".segment Basic", ":BasicUpstart(main)", "  .label SCREEN = $400", ".segment Code", "main: {", "    ldx #0", "    jsr print", "    jsr print", "    jsr print", "    rts", "}", "print: {", "    lda #'.'", "    sta SCREEN,x", "    inx", "    rts", "}"]}
{"code": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Problem 1:\n;;   Write an assembly language program to add up the numbers from 1 to 15\n;;   (inclusive) and output the result to Port B (Points 15).\n.include \"m328Pdef.inc\"\n\ninit:\n    ;; set up aliases\n    .def    count=r16\n    .def    limit=r17\n    .def    sum=r18\nmain:\n    ldi     count,1         ;; count = 1\n    ldi     limit,16        ;; limit = 15\n    clr     sum             ;; sum = 0\n    ser     r19             ;; r19 = 0xff\n    out     DDRB, r19       ;; set PORTB for output\nloop:\n    cp      count,limit     ;; diff = count - limit\n    brge    end             ;; if (count >= limit) { goto end } else {\n    add     sum,count       ;;     sum += count\n    inc     count           ;;     count += 1 }\n    rjmp    loop            ;; goto loop\nend:\n    out     PORTB, sum      ;; print(sum)\n    ret\n", "line": 25, "slice": [".include \"m328Pdef.inc\"", "", "init:", "    .def    count=r16", "    .def    limit=r17", "    .def    sum=r18", "main:", "    ldi     count,1", "    ldi     limit,16", "    clr     sum", "    ser     r19", "    out     DDRB, r19", "loop:", "    cp      count,limit", "    brge    end", "    add     sum,count", "    inc     count", "    rjmp    loop", "end:", "    out     PORTB, sum", "    ret"]}
{"code": "// Tests assigning a literal word pointer\n  // Commodore 64 PRG executable file\n.file [name=\"literal-word-pointer-1.prg\", type=\"prg\", segments=\"Program\"]\n.segmentdef Program [segments=\"Basic, Code, Data\"]\n.segmentdef Basic [start=$0801]\n.segmentdef Code [start=$80d]\n.segmentdef Data [startAfter=\"Code\"]\n.segment Basic\n:BasicUpstart(main)\n.segment Code\nmain: {\n    // print(\"qwe\")\n    jsr print\n    // }\n    rts\n  .segment Data\n    str: .text \"qwe\"\n    .byte 0\n}\n.segment Code\n// void print(char *str)\nprint: {\n    // *(word*)0x80 = (word)str\n    lda #<main.str\n    sta.z $80\n    lda #>main.str\n    sta.z $80+1\n    // }\n    rts\n}\n", "line": 12, "slice": [".segment Code", "main: {", "    jsr print", "    rts", "  .segment Data", "    str: .text \"qwe\"", "    .byte 0", "}", ".segment Code", "print: {", "    lda #<main.str", "    sta.z $80", "    lda #>main.str", "    sta.z $80+1", "    rts", "}"]}
{"code": "staload \"./pattern.sats\"\nstaload \"./skeleton.sats\"\nstaload \"./string.sats\"\n\nviewtypedef Rule = @{\n\tlevel = int,\n\tprecedence = int,\n\tname = String,\n\tpattern = Pattern,\n\tskeleton = Skeleton,\n\tkind = int // whether the rule is \"=>\" or \"=>>\"\n}\n\nfn rule_is_valid(!Rule): bool\nfn rule_copy(!Rule): Rule\nfn rule_print(!Rule): void\nfn rule_free(Rule): void\n\noverload gcopy with rule_copy\noverload gprint with rule_print\noverload gfree with rule_free\n", "line": 16, "slice": ["staload \"./pattern.sats\"", "staload \"./skeleton.sats\"", "staload \"./string.sats\"", "", "viewtypedef Rule = @{", "\tlevel = int,", "\tprecedence = int,", "\tname = String,", "\tpattern = Pattern,", "\tskeleton = Skeleton,", "\tkind = int // whether the rule is \"=>\" or \"=>>\"", "}", "", "fn rule_copy(!Rule): Rule", "overload gcopy with rule_copy"]}
{"code": "staload \"./string.sats\"\n\ndataviewtype Pat =\n\t| pat_symbol of String\t// w+\n\t| pat_atom of String\t// ?w+\n\t| pat_mult of String\t// *w+\n\t| pat_bal of String\t\t// =w+\n\t| pat_under\t\t\t\t// _\n\t| pat_ellip\t\t\t\t// ...\n\nviewtypedef pattern(n: int) = list_vt(Pat, n)\nviewtypedef Pattern = [n: nat] pattern(n)\n\nfn pat_from_string(String): Pat\nfn pat_print(!Pat): void\nfn pat_copy(!Pat): Pat\nfn pat_free(&Pat >> Pat?):<!wrt> void\nfn pat_free'(Pat): void\n\n// This is not the actual length but a relative length to discard phrases that may not match\nfn pattern_length(!Pattern): [n: nat] int(n)\nfn pattern_print(!Pattern): void\nfn pattern_copy {n: nat} (!pattern(n)): pattern(n)\nfn pattern_free(Pattern): void\n\noverload gprint with pat_print\noverload gcopy with pat_copy\n\noverload gprint with pattern_print\noverload gfree with pattern_free\n", "line": 15, "slice": ["staload \"./string.sats\"", "", "dataviewtype Pat =", "\t| pat_symbol of String\t// w+", "\t| pat_atom of String\t// ?w+", "\t| pat_mult of String\t// *w+", "\t| pat_bal of String\t\t// =w+", "\t| pat_under\t\t\t\t// _", "\t| pat_ellip\t\t\t\t// ...", "", "viewtypedef pattern(n: int) = list_vt(Pat, n)", "viewtypedef Pattern = [n: nat] pattern(n)", "", "fn pat_from_string(String): Pat", "fn pat_print(!Pat): void", "fn pat_copy(!Pat): Pat", "fn pat_free(&Pat >> Pat?):<!wrt> void", "fn pat_free'(Pat): void", "", "fn pattern_length(!Pattern): [n: nat] int(n)", "fn pattern_print(!Pattern): void", "fn pattern_copy {n: nat} (!pattern(n)): pattern(n)", "fn pattern_free(Pattern): void", "", "overload gprint with pat_print", "overload gcopy with pat_copy", "", "overload gprint with pattern_print", "overload gfree with pattern_free"]}
{"code": "staload \"./string.sats\"\n\ndataviewtype Ske =\n\t| ske_symbol of String\t// w+\n\t| ske_hole of String\t// :w+\n\t| ske_reduce of String\t// %w+\n\nviewtypedef skeleton(n: int) = list_vt(Ske, n)\nviewtypedef Skeleton = [n: nat] skeleton(n)\n\nfn ske_from_string(String): Ske\nfn ske_print(!Ske): void\nfn ske_copy(!Ske): Ske\nfn ske_free(&Ske >> Ske?):<!wrt> void\n\nfn skeleton_print(!Skeleton): void\nfn skeleton_copy(!Skeleton): Skeleton\nfn skeleton_free(Skeleton): void\n\noverload gprint with ske_print\noverload gfree with ske_free\n\noverload gprint with skeleton_print\noverload gfree with skeleton_free\n", "line": 12, "slice": ["staload \"./string.sats\"", "", "dataviewtype Ske =", "\t| ske_symbol of String\t// w+", "\t| ske_hole of String\t// :w+", "\t| ske_reduce of String\t// %w+", "", "viewtypedef skeleton(n: int) = list_vt(Ske, n)", "viewtypedef Skeleton = [n: nat] skeleton(n)", "", "fn ske_from_string(String): Ske", "fn ske_print(!Ske): void", "fn ske_copy(!Ske): Ske", "fn ske_free(&Ske >> Ske?):<!wrt> void", "", "fn skeleton_print(!Skeleton): void", "fn skeleton_copy(!Skeleton): Skeleton", "fn skeleton_free(Skeleton): void", "", "overload gprint with ske_print", "overload gfree with ske_free", "", "overload gprint with skeleton_print", "overload gfree with skeleton_free"]}
{"code": "#include \"share/atspre_define.hats\"\n#include \"share/atspre_staload.hats\"\n\nfn square(x: double): double = \n  x * x\n\nval cube = lam (x: double): double => x * x * x\n\nfn area_of_ring\n  (R: double, r: double): double =\n  3.14159 * (square(R) - square(r))\n\nfn sqrsum1(x: int, y: int): int = \n  x * x + y * y\n\ntypedef int2 = @(int, int)\n\nfn sqrsum2\n  (xy: int2): int = \n  xy.0 * xy.0 + xy.1 * xy.1\n\nimplement main0 () = {\n  val res1 = square(10.0)\n  val _ = print(res1)\n  val _ = print(\"\\n\")\n\n  val res2 = cube(10.0)\n  val _ = print(res2)\n  val _ = print(\"\\n\")\n\n  val area = area_of_ring(R, r) where {\n    val R = 20.0 \n    val r = 10.0\n  }\n\n  val _ = print(area)\n  val _ = print(\"\\n\")\n\n  val s1  = sqrsum1(3, 4)\n  val s2 = sqrsum2(@(3, 4))\n  val _ = print(s1)\n  val _ = print(\"\\n\")\n  val _ = print(s2)\n  val _ = print(\"\\n\")\n}", "line": 24, "slice": ["fn square(x: double): double = ", "  x * x", "", "fn area_of_ring", "  (R: double, r: double): double =", "  3.14159 * (square(R) - square(r))", "", "implement main0 () = {", "  val area = area_of_ring(R, r) where {", "    val R = 20.0 ", "    val r = 10.0", "  }", "", "  val _ = print(area)", "  val _ = print(\"\\n\")", "}"]}
{"code": "staload \"./string.sats\"\n\nviewtypedef phrase(n: int) = list_vt(String, n)\nviewtypedef Phrase = [n: nat] phrase(n)\n\nfn phrase_new(): phrase(0)\nfn phrase_copy {n: nat} (!phrase(n)): phrase(n)\nfn phrase_equal(!Phrase, !Phrase): bool\nfn phrase_print(!Phrase): void\nfn phrase_free(Phrase): void\n\nfn ocurrences(!Phrase, !String): int\n\noverload = with phrase_equal\noverload gcopy with phrase_copy\noverload gprint with phrase_print\noverload gfree with phrase_free\n", "line": 9, "slice": ["staload \"./string.sats\"", "", "viewtypedef phrase(n: int) = list_vt(String, n)", "viewtypedef Phrase = [n: nat] phrase(n)", "", "fn phrase_new(): phrase(0)", "fn phrase_copy {n: nat} (!phrase(n)): phrase(n)", "fn phrase_equal(!Phrase, !Phrase): bool", "fn phrase_print(!Phrase): void", "fn phrase_free(Phrase): void", "", "fn ocurrences(!Phrase, !String): int", "", "overload = with phrase_equal", "overload gcopy with phrase_copy", "overload gprint with phrase_print", "overload gfree with phrase_free"]}
{"code": "viewtypedef strnptr11(n: int) = [l: agz] strnptr(l, n)\nviewtypedef Strnptr11 = [n: nat | n > 0] strnptr11(n)\nviewtypedef String = Strnptr11\n\nfn string_new {n: nat | n > 0} (string(n)): String\nfn string_copy(!String): String\nfn string_compare(!String, !String): int\nfn string_equal(!String, !String): bool\n// For comparison with stack allocated strings\nfn string_compare_stack {n: nat | n > 0} (!String, string(n)): int\nfn string_equal_stack {n: nat | n > 0} (!String, string(n)): bool\nfn string_print(!String): void\nfn string_cut_head {n: int | n > 0} (s: !strnptr11(n)): void\nfn string_free(String):<!wrt> void\n\noverload gcopy with string_copy\noverload compare with string_compare\noverload = with string_equal\noverload compare with string_compare_stack\noverload = with string_equal_stack\noverload gprint with string_print\noverload gfree with string_free\n", "line": 12, "slice": ["viewtypedef strnptr11(n: int) = [l: agz] strnptr(l, n)", "viewtypedef Strnptr11 = [n: nat | n > 0] strnptr11(n)", "viewtypedef String = Strnptr11", "fn string_new {n: nat | n > 0} (string(n)): String", "fn string_copy(!String): String", "overload gcopy with string_copy"]}
{"code": "(* ****** ****** *)\n//\n// chip8-base.dats\n// Implementation of basic functions to work with bytes and words.\n//\n(* ****** ****** *)\n\n#ifndef CHIP8_MAIN\n#include \"./../staloadall.hats\"\n#endif\n\n(* ****** ****** *)\n\nimplement print_byte(b) = fprint(stdout_ref, b)\nimplement print_word(w) = fprint(stdout_ref, w)\n\n(* ****** ****** *)\n\nimplement fprint_byte(out, b) = $extfcall(void, \"fprintf\", out, \"B(%02x)\", b)\nimplement fprint_word(out, w) = $extfcall(void, \"fprintf\", out, \"W(%04x)\", w)\n\n(* End of [chip8-base.dats] *)", "line": 14, "slice": ["#ifndef CHIP8_MAIN", "#include \"./../staloadall.hats\"", "#endif", "", "implement print_word(w) = fprint(stdout_ref, w)", "", "implement fprint_word(out, w) = $extfcall(void, \"fprintf\", out, \"W(%04x)\", w)"]}
{"code": "# Convert a bmake Makefile to a gmake Makefile\n\nBEGIN { print(\"# *** AUTOGENERATED FILE -- DO NOT EDIT ***\\n\\n\"); }\n\n# Special variables with different names\n{ gsub(\"\\\\${>}\", \"${^}\", $0); }\n\n# Change cross-references (mostly .include's)\n{ gsub(\"Makefile\", \"GNUmakefile\", $0); }\n\n# Meta-directives\n/^.include/ { gsub(\"\\\"\", \"\", $2); printf(\"include %s\\n\", $2); next; }\n/^.ifdef/ { gsub(\"\\\"\", \"\", $2); printf(\"ifdef %s\\n\", $2); next; }\n/^.ifndef/ { gsub(\"\\\"\", \"\", $2); printf(\"ifndef %s\\n\", $2); next; }\n/^.else/ { print(\"else\\n\"); next; }\n/^.endif/ { print(\"endif\\n\"); next; }\n\n# Else, don't molest it\n{ print($0); }\n", "line": 3, "slice": ["# Convert a bmake Makefile to a gmake Makefile", "", "BEGIN { print(\"# *** AUTOGENERATED FILE -- DO NOT EDIT ***\\n\\n\"); }", "", "# Special variables with different names", "{ gsub(\"\\\\${>}\", \"${^}\", $0); }"]}
{"code": "#!/usr/bin/gawk -f\nBEGIN {\n  sectionregex=\"[ +[a-zA-Z0-9]+ +]\";\n}\n{\n  if (match($0, sectionregex)) {\n    section=$0;\n    if (section==\"[ moleculetype ]\") flag=\"true\"\n    if (section==\"[ system ]\") flag=\"false\"\n  }\n  \n  if (section==\"[ moleculetype ]\" && NF>1) {\n    if (!match($0, \"^;.+\") && !match($0, sectionregex)) {\n      name=$1\n    }\n  }\n\n  \n  if (flag==\"true\") print $0\n}\nEND {\n  print(\"; Include position restraint file\")\n  printf(\"#ifdef POSRES_%s\\n\", name)\n  printf(\"#include \\\"posre_%s.itp\\\"\\n\", name)\n  print(\"#endif\")\n}\n", "line": 22, "slice": ["#!/usr/bin/gawk -f", "BEGIN {", "  sectionregex=\"[ +[a-zA-Z0-9]+ +]\";", "}", "{", "  if (match($0, sectionregex)) {", "    section=$0;", "    if (section==\"[ moleculetype ]\") flag=\"true\"", "  }", "  ", "  if (section==\"[ moleculetype ]\" && NF>1) {", "    if (!match($0, \"^;.+\") && !match($0, sectionregex)) {", "      name=$1", "    }", "  }", "", "  ", "  if (flag==\"true\") print $0", "}", "END {", "  printf(\"#ifdef POSRES_%s\\n\", name)", "  printf(\"#include \\\"posre_%s.itp\\\"\\n\", name)", "}"]}
{"code": "def main\n\tprint(\"hello world\")\n\tlet fn = \\(a:int, n:int) -> int\n\t\tcount = 0\n\t\tresult = 1\n\t\twhile count < n\n\t\t\tresult *= a\n\t\t\tresult %= 65537\n\t\t\t++count\n\t\treturn result\n\tzip(fn, [3, 5, 2, 16, 256, 4292], [5, 27, 8, 997, 1002, 12082]).print()\n\t\n\tlet a = 0;\n\tlet s = \\() {\n\t\ta = 8; return 9\n\t} ()\n", "line": 2, "slice": ["def main", "\tprint(\"hello world\")", "\tlet fn = \\(a:int, n:int) -> int", "\t\tcount = 0", "\t\tresult = 1", "\t\twhile count < n", "\t\t\tresult *= a", "\t\t\tresult %= 65537", "\t\t\t++count", "\t\treturn result", "\tzip(fn, [3, 5, 2, 16, 256, 4292], [5, 27, 8, 997, 1002, 12082]).print()"]}
{"code": "import System\nimport System.Diagnostics\n\nclass Person:\n\t[property(Name)]\n\t_name as string\n\t\ndef use(p as (Person)):\n\tDebug.Assert(5 == len(p))\n\t\ndef run():\n\tfor i in range(100000):\n\t\ta = (\n\t\t\t\tPerson(Name: \"a name\"),\n\t\t\t\tPerson(Name: \"a name\"),\n\t\t\t\tPerson(Name: \"a name\"),\n\t\t\t\tPerson(Name: \"a name\"),\n\t\t\t\tPerson(Name: \"a name\"))\n\tuse(a)\n\n\t\nstart = date.Now\n\nfor i in range(10):\n\trun()\n\t\nprint(\"elapsed: ${date.Now-start}\")\n\t\n\t\n", "line": 27, "slice": ["import System", "import System.Diagnostics", "", "class Person:", "\t[property(Name)]", "\t_name as string", "\t", "def use(p as (Person)):", "\tDebug.Assert(5 == len(p))", "\t", "def run():", "\tfor i in range(100000):", "\t\ta = (", "\t\t\t\tPerson(Name: \"a name\"),", "\t\t\t\tPerson(Name: \"a name\"),", "\t\t\t\tPerson(Name: \"a name\"),", "\t\t\t\tPerson(Name: \"a name\"),", "\t\t\t\tPerson(Name: \"a name\"))", "\tuse(a)", "", "for i in range(10):", "\trun()"]}
{"code": "\"\"\"\n1 - clicked!\n2 - clicked!\n\n\"\"\"\nimport BooCompiler.Tests\n\nclass Handler:\n\t\n\tpublic State\n\t\t\n\tdef clicked(sender, args as System.EventArgs):\n\t\tprint(\"${State} - clicked!\")\n\nhandler = Handler(State: 1)\n\nc = Clickable()\nc.Click += handler.clicked\nc.RaiseClick()\nc.Click -= handler.clicked\n\nhandler.State = 2\nc.Click += handler.clicked\nc.RaiseClick()\n", "line": 13, "slice": ["\"\"\"", "import BooCompiler.Tests", "", "class Handler:", "\t", "\tpublic State", "\t\t", "\tdef clicked(sender, args as System.EventArgs):", "\t\tprint(\"${State} - clicked!\")", "", "handler = Handler(State: 1)", "", "c = Clickable()", "c.Click += handler.clicked", "c.RaiseClick()", "", "handler.State = 2", "c.Click += handler.clicked", "\"\"\""]}
{"code": "#UNSUPPORTED: Meta programming not supported yet\r\n\"\"\"\r\nbefore\r\ntest\r\nafter\r\n\"\"\"\r\nimport Boo.Lang.Compiler.Ast\r\nimport Boo.Lang.Compiler.MetaProgramming\r\n\r\n[meta]\r\ndef code(e as BlockExpression):\r\n\treturn CodeSerializer().Serialize(e.Body)\r\n\r\nmodule = [|\r\n\timport Boo.Lang.Compiler.Ast\r\n\t\r\n\t[meta] def surround(e as BlockExpression):\r\n\t\treturn code:\r\n\t\t\tprint(\"before\")\r\n\t\t\t// that's how you escape a splice inside a quasi-quotation\r\n\t\t\t$(SpliceExpression([| e.Body |]))\r\n\t\t\tprint(\"after\")\r\n|]\r\n\r\nsurroundAssembly = compile(module, System.Reflection.Assembly.GetExecutingAssembly(), typeof(Node).Assembly)\r\n\r\ntypeDef = [|\r\n\tclass Test:\r\n\t\tdef Run():\r\n\t\t\tsurround:\r\n\t\t\t\tprint \"test\"\r\n|]\r\n\r\ntype = compile(typeDef, surroundAssembly)\r\n(type() as duck).Run()\r\n", "line": 19, "slice": ["import Boo.Lang.Compiler.Ast", "import Boo.Lang.Compiler.MetaProgramming", "", "[meta]", "def code(e as BlockExpression):", "\treturn CodeSerializer().Serialize(e.Body)", "", "module = [|", "\timport Boo.Lang.Compiler.Ast", "\t", "\t[meta] def surround(e as BlockExpression):", "\t\treturn code:", "\t\t\tprint(\"before\")", "\t\t\t// that's how you escape a splice inside a quasi-quotation", "\t\t\t$(SpliceExpression([| e.Body |]))", "\t\t\tprint(\"after\")", "|]", "", "surroundAssembly = compile(module, System.Reflection.Assembly.GetExecutingAssembly(), typeof(Node).Assembly)", "", "typeDef = [|", "\tclass Test:", "\t\tdef Run():", "\t\t\tsurround:", "\t\t\t\tprint \"test\"", "|]", "", "type = compile(typeDef, surroundAssembly)", "(type() as duck).Run()"]}
{"code": "\"\"\"\nAll\nA class\n\"\"\"\nimport System\n\n[AttributeUsage(AttributeTargets.All)]\nclass DocumentationAttribute(Attribute):\n\t\n\t[getter(Text)]\n\t_text as string\n\t\n\tdef constructor([required]text as string):\n\t\t_text = text\n\t\t\n[Documentation(\"A class\")]\nclass TargetClass:\n\tpass\n\t\n\nusage as AttributeUsageAttribute = Attribute.GetCustomAttribute(DocumentationAttribute, AttributeUsageAttribute)\nprint(usage.ValidOn)\n\nattribute as DocumentationAttribute = Attribute.GetCustomAttribute(TargetClass, DocumentationAttribute)\nprint(attribute.Text)\n", "line": 22, "slice": ["\"\"\"", "All", "A class", "\"\"\"", "import System", "", "[AttributeUsage(AttributeTargets.All)]", "class DocumentationAttribute(Attribute):", "\t", "\t[getter(Text)]", "\t_text as string", "\t", "\tdef constructor([required]text as string):", "\t\t_text = text", "\t\t", "[Documentation(\"A class\")]", "class TargetClass:", "\tpass", "\t", "", "attribute as DocumentationAttribute = Attribute.GetCustomAttribute(TargetClass, DocumentationAttribute)"]}
{"code": "\"\"\"\nMakeItUpper:foo:FOO\nMakeItLower:BaR:bar\n\"\"\"\n\ndef upper(s as string):\n\treturn s.toUpperCase()\n\t\ndef lower(s as string):\n\treturn s.toLowerCase()\n\t\ndef invoke(fn as ICallable, arg):\n\treturn fn(arg)\n\t\ncommandMap = {\n\t\t\t\t\"MakeItUpper\" : upper,\n\t\t\t\t\"MakeItLower\" : lower\n\t\t\t}\n\t\t\t\ntext = \"\"\"\nMakeItUpper foo FOO\nMakeItLower BaR bar\n\"\"\"\n\nfor line in text.split(/\\n/):\n\tcontinue unless len(line)\t\n\t\n\tcommand, arg, expected = line.split(/\\s+/)\n\tassert expected == invoke(commandMap[command], arg)\n\t\n\tprint(\"${command}:${arg}:${expected}\")\n", "line": 31, "slice": ["\"\"\"", "MakeItUpper:foo:FOO", "MakeItLower:BaR:bar", "\"\"\"", "", "def upper(s as string):", "\treturn s.toUpperCase()", "\t", "def lower(s as string):", "\treturn s.toLowerCase()", "\t", "def invoke(fn as ICallable, arg):", "\treturn fn(arg)", "\t", "commandMap = {", "\t\t\t\t\"MakeItUpper\" : upper,", "\t\t\t\t\"MakeItLower\" : lower", "\t\t\t}", "\t\t\t", "text = \"\"\"", "MakeItUpper foo FOO", "MakeItLower BaR bar", "\"\"\"", "", "for line in text.split(/\\n/):", "\tcontinue unless len(line)\t", "\t", "\tcommand, arg, expected = line.split(/\\s+/)", "\tassert expected == invoke(commandMap[command], arg)"]}
{"code": "\ufeff#region license\n// Copyright (c) 2004, Rodrigo B. de Oliveira (rbo@acm.org)\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n//     * Redistributions of source code must retain the above copyright notice,\n//     this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright notice,\n//     this list of conditions and the following disclaimer in the documentation\n//     and/or other materials provided with the distribution.\n//     * Neither the name of Rodrigo B. de Oliveira nor the names of its\n//     contributors may be used to endorse or promote products derived from this\n//     software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#endregion\n\nimport System.IO\n\ndef RemoveNotice(fname, notice):\n\tcontents = File.ReadAllText(fname)\n\tnewContents = contents.Replace(notice, \"\")\n\tif contents != newContents:\n\t\tprint(fname)\n\t\tFile.WriteAllText(fname, newContents)\n\ndef ScanDirectory(name as string, notice as string):\n\tfor fname in Directory.GetFiles(name, \"*.cs\"):\n\t\tRemoveNotice(fname, notice)\n\tfor fname in Directory.GetFiles(name, \"*.boo\"):\n\t\tRemoveNotice(fname, notice)\n\tfor dir in Directory.GetDirectories(name):\n\t\tScanDirectory(dir, notice)\n\nnotice = File.ReadAllText(argv[0])\nScanDirectory(\".\", notice)\n", "line": 35, "slice": ["import System.IO", "", "def RemoveNotice(fname, notice):", "\tcontents = File.ReadAllText(fname)", "\tnewContents = contents.Replace(notice, \"\")", "\tif contents != newContents:", "\t\tprint(fname)", "\t\tFile.WriteAllText(fname, newContents)", "", "def ScanDirectory(name as string, notice as string):", "\tfor fname in Directory.GetFiles(name, \"*.cs\"):", "\t\tRemoveNotice(fname, notice)", "\tfor fname in Directory.GetFiles(name, \"*.boo\"):", "\t\tRemoveNotice(fname, notice)", "\tfor dir in Directory.GetDirectories(name):", "\t\tScanDirectory(dir, notice)", "", "notice = File.ReadAllText(argv[0])", "ScanDirectory(\".\", notice)"]}
{"code": "\"\"\"\n0\n1\n0, 8, 16, 24\n\"\"\"\nclass Generator:\n\t\n\t\n\t[property(B)]\n\t_b = 5\n\t\n\tdef run(begin as int, end as int):\n\t\ta = 0\n\t\tyield { return a }\n\t\tyield { --begin; return ++a }\n\t\tyield { a = _b; return { return (a+_b)*i for i in range(begin, end) } }\n\t\tassert 5 == a\n\t\ng = Generator()\nfor f in g.run(1, 4):\n\titem = f()\t\n\tif item isa callable:\n\t\tg.B = 3\n\t\tprint(join(cast(callable, item)(), \", \"))\n\telse:\n\t\tprint(item)\n", "line": 24, "slice": ["\"\"\"", "class Generator:", "\t", "\t", "\t[property(B)]", "\t_b = 5", "\t", "\tdef run(begin as int, end as int):", "\t\ta = 0", "\t\tyield { a = _b; return { return (a+_b)*i for i in range(begin, end) } }", "\t", "g = Generator()", "for f in g.run(1, 4):", "\titem = f()\t", "\tif item isa callable:", "\t\tg.B = 3", "\t\tprint(join(cast(callable, item)(), \", \"))", "\"\"\""]}
{"code": "\"\"\"\r\nDerivedClass\r\n\"\"\"\r\nimport System\r\nimport System.Xml.Serialization from System.Xml\r\nimport BooCompiler.Tests.SupportingClasses from BooCompiler.Tests\r\n\r\nclass C:\r\n\t[XmlInclude(DerivedClass)]\t\r\n\tdef GetItem() as BaseClass:\r\n\t\tpass\r\n\r\nGetItem = typeof(C).GetMethod(\"GetItem\")\r\nxmlinc as XmlIncludeAttribute = Attribute.GetCustomAttribute(GetItem, XmlIncludeAttribute)\r\nprint(xmlinc.Type.Name)\r\n", "line": 15, "slice": ["\"\"\"", "DerivedClass", "\"\"\"", "import System", "import System.Xml.Serialization from System.Xml", "import BooCompiler.Tests.SupportingClasses from BooCompiler.Tests", "", "class C:", "\t[XmlInclude(DerivedClass)]\t", "\tdef GetItem() as BaseClass:", "\t\tpass", "", "GetItem = typeof(C).GetMethod(\"GetItem\")", "xmlinc as XmlIncludeAttribute = Attribute.GetCustomAttribute(GetItem, XmlIncludeAttribute)"]}
{"code": "\"\"\"\nbutton = Button()\nbutton.Click += { print('clicked!') }\nif button:\n\tbutton.Click += { print('yes, it was!') }\n\tif 3 > 2:\n\t\tbutton.Click += { sender | print(\"\\${sender} clicked!\") }\n\"\"\"\nbutton = Button()\nbutton.Click += def:\n\tprint(\"clicked!\")\nif button:\n\tbutton.Click += def ():\n\t\tprint(\"yes, it was!\")\n\tif 3 > 2:\n\t\tbutton.Click += def (sender):\n\t\t\tprint(\"${sender} clicked!\")\n\n", "line": 3, "slice": ["button = Button()", "button.Click += def:", "\tprint(\"clicked!\")", "if button:", "\tbutton.Click += def ():", "\t\tprint(\"yes, it was!\")", "\tif 3 > 2:", "\t\tbutton.Click += def (sender):", "\t\t\tprint(\"${sender} clicked!\")"]}
{"code": "\"\"\"\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Slice_property_intModule(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\tl = ['foo']\n\t\tl.set_Item(0, 'bar')\n\t\tBoo.Lang.Builtins.print(l.get_Item(0))\n\n\tprivate def constructor():\n\t\tsuper()\n\"\"\"\nl = [\"foo\"]\nl[0] = \"bar\"\nprint(l.get_Item(0))\n", "line": 8, "slice": ["[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]", "public final transient class Slice_property_intModule(object):", "", "\tprivate static def Main(argv as (string)) as void:", "\t\tl = ['foo']", "\t\tl.set_Item(0, 'bar')", "\t\tBoo.Lang.Builtins.print(l.get_Item(0))", "", "l = [\"foo\"]", "l[0] = \"bar\"", "print(l[0])"]}
{"code": "\"\"\"\nnamespace Foo.Bar\n\nimport System\n\ndef foo():\n\tprint('bar')\n\nfoo()\nfoo()\n\"\"\"\nnamespace Foo.Bar\n\nimport System\n\ndef foo():\n\tprint('bar')\nend\n\nfoo()\nfoo()\n", "line": 7, "slice": ["namespace Foo.Bar", "", "def foo():", "\tprint('bar')", "", "foo()"]}
{"code": "\"\"\"\n1, 2, 3\n\"\"\"\nimport Boo.Lang.Runtime\n\nclass My:\n\t[Extension]\n\tstatic def print(a as System.Array):\n\t\tprint join(a, ', ')\n\t\t\t\ntry:\n\tRuntimeServices.RegisterExtensions(My)\n\t\n\ta as duck = (1, 2, 3)\t\n\ta.print()\nensure:\n\tRuntimeServices.UnRegisterExtensions(My)\n", "line": 8, "slice": ["\"\"\"", "import Boo.Lang.Runtime", "", "class My:", "\t[Extension]", "\tstatic def print(a as System.Array):", "\t\tprint join(a, ', ')", "\t\t\t", "try:", "\tRuntimeServices.RegisterExtensions(My)", "\t", "\ta as duck = (1, 2, 3)\t", "\ta.print()", "ensure:", "\tRuntimeServices.UnRegisterExtensions(My)", "\"\"\""]}
{"code": "def applyDelegate(delegate as System.Delegate, iterator):\n\tfor item in iterator:\n\t\tdelegate.DynamicInvoke((item,))\n\t\t\ndef applyCallable(fn as ICallable, iterator):\n\tfor item in iterator:\n\t\tfn(item)\n\t\t\ndef timeit(name, fn as ICallable):\n\tstart = date.Now\n\tfn(foo, range(5000000))\n\tprint(\"${name} took ${date.Now-start}\")\n\t\t\ndef foo(item):\n\tpass\n\t\ntimeit(\"Delegate.DynamicInvoke\", applyDelegate)\ntimeit(\"ICallable.Call\", applyCallable)\n\t\n", "line": 12, "slice": ["def applyDelegate(delegate as System.Delegate, iterator):", "\tfor item in iterator:", "\t\tdelegate.DynamicInvoke((item,))", "\t\t", "def timeit(name, fn as ICallable):", "\tstart = date.Now", "\tfn(foo, range(5000000))", "\tprint(\"${name} took ${date.Now-start}\")", "\t", "def foo(item):", "\tpass", "\t", "timeit(\"Delegate.DynamicInvoke\", applyDelegate)"]}
{"code": "#IGNORE: Interfaces not supported yet\r\n\"\"\"\r\n1\r\n2\r\n3\r\n\"\"\"\r\nimport System.Collections\r\n\r\ninterface IEnumerable2(IEnumerable):\r\n\tpass\r\n\r\nclass Enumerable(IEnumerable2):\r\n\r\n\tdef GetEnumerator() as IEnumerator:\r\n\t\treturn (1, 2, 3).GetEnumerator()\r\n\r\ndef printall(foo as IEnumerable2):\t\r\n\tfor item in foo:\r\n\t\tprint(item)\r\n\r\ne = Enumerable()\r\nprintall(e)\r\n\t\r\n\r\n", "line": 19, "slice": ["import System.Collections", "", "interface IEnumerable2(IEnumerable):", "\tpass", "", "class Enumerable(IEnumerable2):", "", "\tdef GetEnumerator() as IEnumerator:", "\t\treturn (1, 2, 3).GetEnumerator()", "", "def printall(foo as IEnumerable2):\t", "\tfor item in foo:", "\t\tprint(item)", "", "e = Enumerable()", "printall(e)"]}
{"code": "\"\"\"\r\nbefore\r\nafter\r\nend\r\n\"\"\"\r\nf = def ():\r\n\tprint('before')\r\n\tgoto exit\r\n\tprint('skipped')\r\n\t:exit\r\n\tprint('after')\r\n\r\nf()\r\ngoto exit\r\nprint('skipped')\r\n:exit\r\nprint(\"end\")\r\n\r\n", "line": 7, "slice": ["\"\"\"", "f = def ():", "\tprint('before')", "\tgoto exit", "\t:exit", "\tprint('after')", "", "f()", "goto exit", ":exit", "print(\"end\")", "\"\"\""]}
{"code": "\"\"\"\nstarting - byrefdelegate.BeginInvoke\nexecuting\ncalled back\ndone\n2 True\nstarting - normal run.BeginInvoke\nexecuting\ncalled back\ndone\n2 True\n\"\"\"\n\nimport System\nimport System.Threading\n\ncallable byrefdelegate(ref x as int)\n\ndef run(ref x as int):\n    print(\"executing\")\n    ++x\n\nx = 1\nprint(\"starting - byrefdelegate.BeginInvoke\")\nc = run as byrefdelegate\nresult = c.BeginInvoke(x, { print(\"called back\") }, null)\nThread.Sleep(50ms)\nc.EndInvoke(x, result)\nprint(\"done\")\nprint x, x==2\n\nx = 1\nprint(\"starting - normal run.BeginInvoke\")\nresult2 = run.BeginInvoke(x, { print(\"called back\") }, null)\nThread.Sleep(50ms)\nrun.EndInvoke(x, result2)\nprint(\"done\")\nprint x, x==2\n\n", "line": 20, "slice": ["\"\"\"", "callable byrefdelegate(ref x as int)", "", "def run(ref x as int):", "    print(\"executing\")", "    ++x", "", "x = 1", "print(\"starting - byrefdelegate.BeginInvoke\")", "c = run as byrefdelegate", "result = c.BeginInvoke(x, { print(\"called back\") }, null)", "Thread.Sleep(50ms)", "c.EndInvoke(x, result)", "print(\"done\")", "print x, x==2", "\"\"\""]}
{"code": "#UNSUPPORTED: BeginInvoke not supported\r\n\"\"\"\r\nstarted\r\nexecuting\r\ndone\r\n\"\"\"\r\nimport System\r\n\t\r\ndef run(message):\r\n\tprint(message)\r\n\treturn 42\r\n\t\r\nprint(\"started\")\r\n\r\nresult = run.BeginInvoke(\"executing\", null, null)\r\nassert 42 == run.EndInvoke(result)\r\n\r\nprint(\"done\")\r\n", "line": 10, "slice": ["import System", "\t", "def run(message):", "\tprint(message)", "\treturn 42", "\t", "print(\"started\")", "", "result = run.BeginInvoke(\"executing\", null, null)"]}
{"code": "\"\"\"\r\n0*2 = 0\r\n1*2 = 2\r\n2*2 = 4\r\n\"\"\"\r\ndef each(items, action as callable(object)):\r\n\tfor item in items:\r\n\t\taction(item)\r\n\r\ndef map(items, func as callable(object) as object):\r\n\treturn func(item) for item in items\r\n\t\r\neach(map(range(3), { item as int | return item, item*2 })) do (pair):\r\n\tx, y = pair\r\n\tprint(\"${x}*2 = ${y}\")\r\n\t\r\n", "line": 15, "slice": ["\"\"\"", "def each(items, action as callable(object)):", "\tfor item in items:", "\t\taction(item)", "", "def map(items, func as callable(object) as object):", "\treturn func(item) for item in items", "\t", "each(map(range(3), { item as int | return item, item*2 })) do (pair):", "\tx, y = pair", "\tprint(\"${x}*2 = ${y}\")", "\"\"\""]}
{"code": "\"\"\"\nMakeItUpper:foo:FOO\nMakeItLower:BaR:bar\n\"\"\"\nimport NUnit.Framework\n\ndef upper(s as string):\n\treturn s.ToUpper()\n\t\ndef lower(s as string):\n\treturn s.ToLower()\n\t\ndef invoke(fn as ICallable, arg):\n\treturn fn(arg)\n\t\ncommandMap = {\n\t\t\t\t\"MakeItUpper\" : upper,\n\t\t\t\t\"MakeItLower\" : lower\n\t\t\t}\n\t\t\t\ntext = \"\"\"\nMakeItUpper foo FOO\nMakeItLower BaR bar\n\"\"\"\n\nfor line in /\\n/.Split(text):\n\tcontinue unless len(line.Trim())\t\n\t\n\tcommand, arg, expected = /\\s+/.Split(line)\t\n\tAssert.AreEqual(expected, invoke(commandMap[command], arg))\n\t\n\tprint(\"${command}:${arg}:${expected}\")\n", "line": 32, "slice": ["\"\"\"", "MakeItUpper:foo:FOO", "MakeItLower:BaR:bar", "\"\"\"", "import NUnit.Framework", "", "def upper(s as string):", "\treturn s.ToUpper()", "\t", "def lower(s as string):", "\treturn s.ToLower()", "\t", "def invoke(fn as ICallable, arg):", "\treturn fn(arg)", "\t", "commandMap = {", "\t\t\t\t\"MakeItUpper\" : upper,", "\t\t\t\t\"MakeItLower\" : lower", "\t\t\t}", "\t\t\t", "text = \"\"\"", "MakeItUpper foo FOO", "MakeItLower BaR bar", "\"\"\"", "", "for line in /\\n/.Split(text):", "\tcontinue unless len(line.Trim())\t", "\t", "\tcommand, arg, expected = /\\s+/.Split(line)\t", "\tAssert.AreEqual(expected, invoke(commandMap[command], arg))"]}
{"code": "\"\"\"\ndef odds(l):\n\tfor i in l:\n\t\tyield i if (0 != (i % 2))\n\ndef d(i):\n\treturn (i * 2)\n\ndef map(fn, enumerable):\n\tfor item in enumerable:\n\t\tyield fn(item)\n\nfor odd in map(d, odds([1, 2, 3, 4, 5])):\n\tprint(odd)\n\"\"\"\ndef odds(l):\n\tfor i in l:\n\t\tyield i if (0 != (i % 2))\n\tend\nend\n\ndef d(i):\n\treturn (i * 2)\nend\n\ndef map(fn, enumerable):\n\tfor item in enumerable:\n\t\tyield fn(item)\n\tend\nend\n\nfor odd in map(d, odds([1, 2, 3, 4, 5])):\n\tprint(odd)\nend\n", "line": 14, "slice": ["\"\"\"", "def odds(l):", "\tfor i in l:", "\t\tyield i if (0 != (i % 2))", "", "def d(i):", "\treturn (i * 2)", "", "def map(fn, enumerable):", "\tfor item in enumerable:", "\t\tyield fn(item)", "", "for odd in map(d, odds([1, 2, 3, 4, 5])):", "\tprint(odd)", "\"\"\""]}
{"code": "\"\"\"\nfoo street, 50\n\"\"\"\nclass Address:\n\t\n\t[getter(Street)]\n\t_street as string\n\t\n\t[getter(Number)]\n\t_number as int\n\t\n\tdef constructor(street as string, number as int):\n\t\t_street = street\n\t\t_number = number\n\t\t\n\toverride def ToString():\n\t\treturn \"${_street}, ${_number}\"\n\t\t\nclass Customer:\n\n\t[getter(Addresses)]\n\t_addresses = []\t\n\t\n\t[getter(Name)]\n\t_name as string\n\t\n\tdef constructor([required] name as string):\n\t\t_name = name\n\t\t\t\nc = Customer(\"Homer Simpson\")\nc.Addresses.Add(Address(\"foo street\", 50))\n\nprint(c.Addresses[0])\n", "line": 33, "slice": ["\"\"\"", "foo street, 50", "\"\"\"", "class Address:", "\t", "\t[getter(Street)]", "\t_street as string", "\t", "\t[getter(Number)]", "\t_number as int", "\t", "\tdef constructor(street as string, number as int):", "\t\t_street = street", "\t\t_number = number", "\t\t", "\toverride def ToString():", "\t\treturn \"${_street}, ${_number}\"", "\t\t", "class Customer:", "", "\t[getter(Addresses)]", "\t_addresses = []\t", "\t", "\tdef constructor([required] name as string):", "\t\t_name = name", "\t\t\t", "c = Customer(\"Homer Simpson\")", "c.Addresses.Add(Address(\"foo street\", 50))"]}
{"code": "\"\"\"\r\nJohn Cleese\r\n\"\"\"\r\nimport java.lang\r\n\r\nclass Named:\r\n\tpublic name as string\r\n\tdef constructor(name as string):\r\n\t\tself.name = name\r\n\t\t\r\nclass Person(Named):\r\n\tdef constructor(name as string):\r\n\t\tsuper(name)\r\n\t\t\r\nclass Printer:\r\n\tdef print(line as string):\r\n\t\tSystem.out.println(line)\r\n\r\nfunnyGuy = Person(\"John Cleese\")\r\nPrinter().print(funnyGuy.name)", "line": 16, "slice": ["\"\"\"", "John Cleese", "\"\"\"", "import java.lang", "", "class Named:", "\tpublic name as string", "\tdef constructor(name as string):", "\t\tself.name = name", "\t\t", "class Person(Named):", "\tdef constructor(name as string):", "\t\tsuper(name)", "", "funnyGuy = Person(\"John Cleese\")", "Printer().print(funnyGuy.name)"]}
{"code": "\"\"\"\nhomer\n\n\"\"\"\nclass Person:\n\t\n\t_fname as string\n\t\n\tdef constructor(fname as string):\n\t\t_fname = fname\n\t\t\n\tFirstName:\n\t\tget:\n\t\t\treturn _fname\n\t\t\nhomer = Person(\"homer\")\nprint(homer.FirstName)\n", "line": 17, "slice": ["\"\"\"", "class Person:", "\t", "\t_fname as string", "\t", "\tdef constructor(fname as string):", "\t\t_fname = fname", "\t\t", "\tFirstName:", "\t\tget:", "\t\t\treturn _fname", "\t\t", "homer = Person(\"homer\")", "print(homer.FirstName)", "\"\"\""]}
{"code": "\"\"\"\r\nint: 3\r\nstring: foo\r\n\"\"\"\r\n\r\ndef pprint(value as int):\r\n\tprint \"int:\", value\r\n\r\n\t\r\ndef pprint(value as string):\r\n\tprint \"string:\", value\r\n\r\npprint(3)\r\npprint(\"foo\")\r\n\t\r\n", "line": 6, "slice": ["\"\"\"", "def pprint(value as int):", "\tprint \"int:\", value", "", "pprint(3)", "\"\"\""]}
{"code": "\"\"\"\ndo: 0\ndo: 1\ndo: 2\nclosure: 0\nclosure: 1\nclosure: 2\ninline: 0\ninline: 1\ninline: 2\nblock: 0\nblock: 1\nblock: 2\n\"\"\"\ncallable Action(item)\n\ndef each(items, action as Action):\n     for item in items:\n          action(item)\n\na = def (item):\n    print(\"do: ${item}\")\n\nb = { item | print(\"closure: ${item}\") }\n\neach(range(3), a)\neach(range(3), b)\neach(range(3), { item | print(\"inline: ${item}\") })\n\neach(range(3)) do (item):\n     print(\"block: ${item}\")\n\n\n", "line": 22, "slice": ["\"\"\"", "callable Action(item)", "", "def each(items, action as Action):", "     for item in items:", "          action(item)", "", "each(range(3)) do (item):", "     print(\"block: ${item}\")", "\"\"\""]}
{"code": "\"\"\"\nFOO\nfoo\n\"\"\"\ndef ToUpper(s as string):\n\treturn s.ToUpper()\n\t\ndef ToLower(s as string):\n\treturn s.ToLower()\n\ndef Select(upper as bool):\t\n\treturn ToUpper if upper\n\treturn ToLower\n\na = \"Foo\"\nprint(Select(true)(a))\nprint(Select(false)(a))\n", "line": 16, "slice": ["\"\"\"", "def ToUpper(s as string):", "\treturn s.ToUpper()", "\t", "def ToLower(s as string):", "\treturn s.ToLower()", "", "def Select(upper as bool):\t", "\treturn ToUpper if upper", "\treturn ToLower", "", "a = \"Foo\"", "print(Select(true)(a))", "print(Select(false)(a))", "\"\"\""]}
{"code": "\"\"\"\ncollection: foo bar\nenumerable: 0 1 2\nobject: baz bag\n\"\"\"\nimport System.Collections\n\ndef use(obj):\n\tprint(\"object: \" + join(obj))\n\ndef use(collection as ICollection):\n\tprint(\"collection: \" + join(collection))\n\ndef use(enumerable as IEnumerable):\n\tprint(\"enumerable: \" + join(enumerable))\n\nuse([\"foo\", \"bar\"])\nuse(range(3))\nuse(cast(object, [\"baz\", \"bag\"]))\n", "line": 9, "slice": ["\"\"\"", "import System.Collections", "", "def use(collection as ICollection):", "\tprint(\"collection: \" + join(collection))", "", "use([\"foo\", \"bar\"])", "\"\"\""]}
{"code": "\"\"\"\nWARNING: albatross!\n\"\"\"\nenum LogMessageLevel:\n\tINFO     = 0\n\tWARNING  = 1\n\tERROR    = 2\n\nclass FileLogService:\n\t\n\tdef log(msg as string):\n\t\"\"\"\n\tLoga mensagem com nivel de verbosidade WARNING\n\t\"\"\"\n\t\tlog(LogMessageLevel.WARNING, msg)\n\n\tdef log(logMessageLevel as LogMessageLevel, [required] msg as string):\n\t\"\"\"\n\tLoga mensagem com o nivel de log especificado.\n\t\"\"\"\n\t\tprint(\"${logMessageLevel}: ${msg}\")\n\nFileLogService().log(\"albatross!\")\n", "line": 21, "slice": ["enum LogMessageLevel:", "\tWARNING  = 1", "", "class FileLogService:", "\t", "\tdef log(msg as string):", "\t\tlog(LogMessageLevel.WARNING, msg)", "", "\tdef log(logMessageLevel as LogMessageLevel, [required] msg as string):", "\t\tprint(\"${logMessageLevel}: ${msg}\")", "", "FileLogService().log(\"albatross!\")"]}
{"code": "\"\"\"\n: foo!\n: bar!\nspam!\nbefore\nend.\n\"\"\"\nclass Foo:\n\n\tpublic bar = def (msg):\n\t\tprint(\"${prefix}${msg}\")\n\t\n\tprefix = \": \"\n\t\nf = Foo()\nf.bar(\"foo!\")\nf.bar(\"bar!\")\n\nf.bar = def (msg):\n\tprint(msg)\n\t\nf.bar(\"spam!\")\n\nf.bar = def (msg):\n\tpass\n\t\nprint(\"before\")\nf.bar(\"eggs!\")\nprint(\"end.\")\n", "line": 11, "slice": ["\"\"\"", "class Foo:", "", "\tpublic bar = def (msg):", "\t\tprint(\"${prefix}${msg}\")", "\t", "\tprefix = \": \"", "\t", "f = Foo()", "f.bar(\"foo!\")", "f.bar(\"bar!\")", "", "f.bar = def (msg):", "\tprint(msg)", "\t", "f.bar(\"spam!\")", "", "f.bar = def (msg):", "\tpass", "\t", "f.bar(\"eggs!\")", "\"\"\""]}
{"code": "\"\"\"\nEric\nTerry\nJohn\n\"\"\"\nclass Person:\n\t\n\t[getter(Name)]\n\t_name as string\n\t\n\tdef constructor(name as string):\n\t\t_name = name\n\t\t\n\tstatic def create(name):\n\t\treturn Person(name)\n\nfor p as Person in map([\"Eric\", \"Terry\", \"John\"], Person.create):\n\tprint(p.Name)\n\n", "line": 18, "slice": ["\"\"\"", "class Person:", "\t", "\t[getter(Name)]", "\t_name as string", "\t", "\tdef constructor(name as string):", "\t\t_name = name", "\t\t", "\tstatic def create(name):", "\t\treturn Person(name)", "", "for p as Person in map([\"Eric\", \"Terry\", \"John\"], Person.create):", "\tprint(p.Name)", "\"\"\""]}
{"code": "\"\"\"\r\nclicked from app!\r\n\"\"\"\r\nfrom BooJs.Tests.Support import Clickable\r\n\r\nclass App:\r\n\r\n\t_clickable as Clickable\r\n\t\r\n\tdef constructor():\r\n\t\t_clickable = Clickable(Click: clicked)\r\n\t\t\r\n\tprivate def clicked(sender):\r\n\t\tprint(\"clicked from app!\")\r\n\t\t\r\n\tdef Run():\r\n\t\t_clickable.RaiseClick()\r\n\t\t\r\nApp().Run()\r\n\t\t\r\n", "line": 14, "slice": ["\"\"\"", "from BooJs.Tests.Support import Clickable", "", "class App:", "", "\t_clickable as Clickable", "\t", "\tdef constructor():", "\t\t_clickable = Clickable(Click: clicked)", "\t\t", "\tprivate def clicked(sender):", "\t\tprint(\"clicked from app!\")", "\t\t", "\tdef Run():", "\t\t_clickable.RaiseClick()", "\t\t", "App().Run()", "\"\"\""]}
{"code": "\"\"\"\n-Testing...\n\"\"\"\ncallable OutputHandler(message as string)\n\nclass Printer:\n\t\n\t_prefix as string\n\t\n\tdef constructor(prefix):\n\t\tself._prefix = prefix\n\t\t\n\tdef print(message as string):\n\t\tSystem.Console.WriteLine(\"${_prefix}${message}\")\n\t\nhandler as OutputHandler\nhandler = Printer(\"-\").print\nhandler(\"Testing...\")\n", "line": 13, "slice": ["\"\"\"", "callable OutputHandler(message as string)", "", "class Printer:", "\t", "\t_prefix as string", "\t", "\tdef constructor(prefix):", "\t\tself._prefix = prefix", "\t\t", "\tdef print(message as string):", "\t\tSystem.Console.WriteLine(\"${_prefix}${message}\")", "\t", "handler as OutputHandler", "handler = Printer(\"-\").print", "handler(\"Testing...\")", "\"\"\""]}
{"code": "\"\"\"\nstarted\nexecuting\ndone\n\"\"\"\nimport System\n\t\ndef run(message):\n\tprint(message)\n\treturn 42\n\t\nprint(\"started\")\n\nresult = run.BeginInvoke(\"executing\", null, null)\nassert 42 == run.EndInvoke(result)\n\nprint(\"done\")\n", "line": 9, "slice": ["import System", "\t", "def run(message):", "\tprint(message)", "\treturn 42", "\t", "result = run.BeginInvoke(\"executing\", null, null)", "assert 42 == run.EndInvoke(result)"]}
{"code": "\"\"\"\n1\n3\n5\n2\n4\n6\n\"\"\"\n\n\ndef odds(begin, until):\n\treturn i for i in range(begin, until) if i % 2\n\t\ndef evens(begin, until):\n\treturn i for i in range(begin, until) unless i % 2\n\t\nfor expected, actual in zip((1, 3, 5), odds(1, 6)):\n\tprint(actual)\n\tassert expected == actual\n\t\nfor expected, actual in zip((2, 4, 6), evens(1, 7)):\n\tprint(actual)\n\tassert expected == actual\n\t\n\n", "line": 18, "slice": ["\"\"\"", "def odds(begin, until):", "\treturn i for i in range(begin, until) if i % 2", "\t", "for expected, actual in zip((1, 3, 5), odds(1, 6)):", "\tprint(actual)", "\tassert expected == actual", "\"\"\""]}
{"code": "#IGNORE: .Net stdlib not supported\r\n\"\"\"\r\ncollection: foo bar\r\nenumerable: 0 1 2\r\nobject: baz bag\r\n\"\"\"\r\nimport System.Collections\r\n\r\ndef use(obj):\r\n\tprint(\"object: \" + join(obj))\r\n\r\ndef use(collection as ICollection):\r\n\tprint(\"collection: \" + join(collection))\r\n\r\ndef use(enumerable as IEnumerable):\r\n\tprint(\"enumerable: \" + join(enumerable))\r\n\r\nuse([\"foo\", \"bar\"])\r\nuse(range(3))\r\nuse(cast(object, [\"baz\", \"bag\"]))\r\n", "line": 10, "slice": ["import System.Collections", "", "def use(collection as ICollection):", "\tprint(\"collection: \" + join(collection))", "", "use([\"foo\", \"bar\"])"]}
{"code": "\"\"\"\nBCE0081-5.boo(12,13): BCE0081: A raise statement with no arguments is not allowed outside an exception handler.\n\"\"\"\nprint('start')\n\ntry:\n\traise \"an exception\"\nexcept:\n\tprint('exception')\n\ta = def ():\n\t\ttry:\n\t\t\traise\n\t\texcept:\n\t\t\traise\nprint('end')\n\n", "line": 4, "slice": ["\"\"\"", "print('start')", "", "try:", "\traise \"an exception\"", "except:", "\tprint('exception')", "\ta = def ():", "\t\ttry:", "\t\t\traise", "\t\texcept:", "\t\t\traise", "\"\"\""]}
{"code": "\"\"\"\n3\n7\n11\n\"\"\"\nimport NUnit.Framework\n\ndef sumPairs(pairs):\n\treturn i+j for i as int, j as int in pairs\n\t\npairs = ((1, 2), (3, 4), (5, 6))\nexpected = 3, 7, 11\n\nfor e, a in zip(expected, sumPairs(pairs)):\n\tprint(a)\n\tAssert.AreEqual(e, a)\n\n", "line": 15, "slice": ["\"\"\"", "import NUnit.Framework", "", "def sumPairs(pairs):", "\treturn i+j for i as int, j as int in pairs", "\t", "pairs = ((1, 2), (3, 4), (5, 6))", "", "for e, a in zip(expected, sumPairs(pairs)):", "\tprint(a)", "\tAssert.AreEqual(e, a)", "\"\"\""]}
{"code": "\"\"\"\nHello World\n\"\"\"\nclass Action:\n\tcb as callable = null\n\tdef constructor(callback):\n\t\tcb = callback\n\tdef run():\n\t\tcb()\n\nclass A:\n\t[property(Go)]\n\taction = Action() def():\n\t\tprint(\"Hello World\")\n\na = A()\na.Go.run()", "line": 14, "slice": ["\"\"\"", "class Action:", "\tcb as callable = null", "\tdef constructor(callback):", "\t\tcb = callback", "\tdef run():", "\t\tcb()", "", "class A:", "\t[property(Go)]", "\taction = Action() def():", "\t\tprint(\"Hello World\")", "", "a = A()", "a.Go.run()", "\"\"\""]}
{"code": "\"\"\"\r\nAll\r\nA class\r\n\"\"\"\r\nimport System\r\n\r\n[AttributeUsage(AttributeTargets.All)]\r\nclass DocumentationAttribute(Attribute):\r\n\t\r\n\t[getter(Text)]\r\n\t_text as string\r\n\t\r\n\tdef constructor([required]text as string):\r\n\t\t_text = text\r\n\t\t\r\n[Documentation(\"A class\")]\r\nclass TargetClass:\r\n\tpass\r\n\t\r\n\r\nusage as AttributeUsageAttribute = Attribute.GetCustomAttribute(DocumentationAttribute, AttributeUsageAttribute)\r\nprint(usage.ValidOn)\r\n\r\nattribute as DocumentationAttribute = Attribute.GetCustomAttribute(TargetClass, DocumentationAttribute)\r\nprint(attribute.Text)\r\n", "line": 22, "slice": ["\"\"\"", "import System", "", "[AttributeUsage(AttributeTargets.All)]", "class DocumentationAttribute(Attribute):", "\t", "\t[getter(Text)]", "\t_text as string", "\t", "\tdef constructor([required]text as string):", "\t\t_text = text", "\t\t", "[Documentation(\"A class\")]", "class TargetClass:", "\tpass", "\t", "", "attribute as DocumentationAttribute = Attribute.GetCustomAttribute(TargetClass, DocumentationAttribute)", "print(attribute.Text)", "\"\"\""]}
{"code": "\"\"\"\n1\n0\n2\n0\n\"\"\"\nclass Table:\n\t_table = ((0, 0), (0,0))\n\t\n\tRow(index as int):\n\t\tget:\n\t\t\treturn _table[index]\n\t\n\tdef SetValue(row as int, col as int, value as int):\n\t\t_table[row][col] = value\n\t\t\nt = Table()\nt.SetValue(0, 0, 1)\nt.SetValue(1, 0, 2)\n\nprint(t.Row[0][0])\nprint(t.Row[0][1])\nprint(t.Row[1][0])\nprint(t.Row[1][1])\n\n\t\t\n\t\t\n", "line": 21, "slice": ["\"\"\"", "class Table:", "\t_table = ((0, 0), (0,0))", "\t", "\tRow(index as int):", "\t\tget:", "\t\t\treturn _table[index]", "\t", "\tdef SetValue(row as int, col as int, value as int):", "\t\t_table[row][col] = value", "\t\t", "t = Table()", "t.SetValue(0, 0, 1)", "t.SetValue(1, 0, 2)", "", "print(t.Row[1][0])", "\"\"\""]}
{"code": "#IGNORE: Interfaces not supported yet\r\n\"\"\"\r\nTrue\r\nFalse\r\n\"\"\"\r\ninterface IFlag:\r\n\tValue as bool:\r\n\t\tget\r\n\t\tset\r\n\t\t\r\nclass Flag(IFlag):\r\n\t[property(Value)]\r\n\t_value as bool\r\n\t\r\ndef printFlag(flag as IFlag):\r\n\tprint(flag.Value)\r\n\t\r\nf = Flag(Value: true)\r\nprintFlag(f)\r\nf.Value = false\r\nprintFlag(f)\r\n", "line": 16, "slice": ["interface IFlag:", "\tValue as bool:", "\t\tget", "\t\tset", "\t\t", "class Flag(IFlag):", "\t[property(Value)]", "\t_value as bool", "\t", "def printFlag(flag as IFlag):", "\tprint(flag.Value)", "\t", "f = Flag(Value: true)", "printFlag(f)", "f.Value = false", "printFlag(f)"]}
{"code": "\"\"\"\nbefore generator\nafter generator\nbefore iteration\ngen\n0\n1\nafter iteration\n\"\"\"\ndef gen():\n\tprint(\"gen\")\n\treturn range(2)\n\t\nprint(\"before generator\")\na = i for i in gen()\nprint(\"after generator\")\n\nprint(\"before iteration\")\nfor i in a:\n\tprint(i)\nprint(\"after iteration\")\n", "line": 11, "slice": ["\"\"\"", "def gen():", "\tprint(\"gen\")", "\treturn range(2)", "\t", "print(\"before generator\")", "a = i for i in gen()", "print(\"before iteration\")", "for i in a:", "\tprint(i)", "\"\"\""]}
{"code": "\"\"\"\nOuter+Inner.Dispose\n\"\"\"\nimport NUnit.Framework\n\nclass Outer:\n\tclass Inner(System.IDisposable):\n\t\tdef Dispose():\n\t\t\tprint(\"${GetType()}.Dispose\")\n\ntypes = typeof(Outer).GetNestedTypes()\nAssert.AreEqual(1, len(types))\n\nAssert.AreSame(Outer.Inner, types[0])\nAssert.IsTrue(types[0] is Outer.Inner)\nAssert.IsTrue(typeof(Outer.Inner).IsNestedPublic)\n\nusing inner=Outer.Inner():\n\tpass\n", "line": 9, "slice": ["class Outer:", "\tclass Inner(System.IDisposable):", "\t\tdef Dispose():", "\t\t\tprint(\"${GetType()}.Dispose\")", "", "using inner=Outer.Inner():", "\tpass"]}
{"code": "\"\"\"\nbefore\nGetEnumerator\nMoveNext\nDispose\nafter\n\"\"\"\nimport System\nimport System.Collections\n\nclass Enumerable(IEnumerable):\n\n\tclass Enumerator(IEnumerator, IDisposable):\n\t\n\t\tdef Dispose():\n\t\t\tprint(\"Dispose\")\n\t\n\t\tdef Reset():\n\t\t\tprint(\"Reset\")\n\t\n\t\tdef MoveNext() as bool:\n\t\t\tprint(\"MoveNext\")\n\t\t\treturn false\n\t\n\t\tCurrent:\n\t\t\tget:\n\t\t\t\tprint(\"Current\")\n\t\t\t\treturn null\n\n\tdef GetEnumerator() as IEnumerator:\n\t\tprint(\"GetEnumerator\")\n\t\treturn Enumerator()\n\t\t\nprint(\"before\")\nfor i in Enumerable():\n\tprint(i)\nprint(\"after\")\n", "line": 16, "slice": ["\"\"\"", "import System", "import System.Collections", "", "class Enumerable(IEnumerable):", "", "\tclass Enumerator(IEnumerator, IDisposable):", "\t", "\t\tdef Dispose():", "\t\t\tprint(\"Dispose\")", "\t", "\t\tdef MoveNext() as bool:", "\t\t\tprint(\"MoveNext\")", "\t\t\treturn false", "\t", "\t\tCurrent:", "\t\t\tget:", "\t\t\t\tprint(\"Current\")", "\t\t\t\treturn null", "", "\tdef GetEnumerator() as IEnumerator:", "\t\tprint(\"GetEnumerator\")", "\t\treturn Enumerator()", "\t\t", "for i in Enumerable():", "\tprint(i)", "\"\"\""]}
{"code": "#IGNORE: Interfaces not supported yet\r\n\r\n\"\"\"\r\nbefore\r\nDispose(True)\r\nafter\r\nDispose(False)\r\n\"\"\"\r\nimport System\r\n\r\nclass Disposable(IDisposable):\r\n\tdef Dispose():\r\n\t\tDispose(true)\r\n\t\t\r\n\tdef Dispose(flag as bool):\r\n\t\tprint(\"Dispose(${flag})\")\r\n\t\t\r\nprint(\"before\")\r\nusing d=Disposable():\r\n\tpass\r\nprint(\"after\")\t\r\nd.Dispose(false)\r\n", "line": 16, "slice": ["import System", "", "class Disposable(IDisposable):", "\tdef Dispose():", "\t\tDispose(true)", "\t\t", "\tdef Dispose(flag as bool):", "\t\tprint(\"Dispose(${flag})\")", "\t\t", "using d=Disposable():", "\tpass", "d.Dispose(false)"]}
{"code": "\"\"\"\nClick!\n\"\"\"\nclass Clickable:\n\n\tevent Click as ClickHandler\n\n\tcallable ClickHandler(sender as object, args)\n\n\tprotected def RaiseClick():\n\t\tself.Click(self, System.EventArgs.Empty)\n\nclass Clickable2(Clickable):\n\tdef DoRaiseClick():\n\t\tRaiseClick()\n\nc = Clickable2()\nc.Click += { print(\"Click!\") }\nc.DoRaiseClick()\n", "line": 18, "slice": ["\"\"\"", "class Clickable:", "", "\tevent Click as ClickHandler", "", "\tcallable ClickHandler(sender as object, args)", "", "\tprotected def RaiseClick():", "\t\tself.Click(self, System.EventArgs.Empty)", "", "class Clickable2(Clickable):", "\tdef DoRaiseClick():", "\t\tRaiseClick()", "", "c = Clickable2()", "c.Click += { print(\"Click!\") }", "c.DoRaiseClick()", "\"\"\""]}
{"code": "\"\"\"\nclass Action:\n\n\tcb\n\n\tdef constructor(callback):\n\t\tcb = callback\n\nclass A:\n\n\t[property(Go)]\n\taction = Action({ print('Hello World') })\n\"\"\"\nclass Action:\n\n\tcb\n\n\tdef constructor(callback):\n\t\tcb = callback\n\tend\nend\n\nclass A:\n\n\t[property(Go)]\n\taction = Action({ print('Hello World') })\nend\n\n", "line": 12, "slice": ["\"\"\"", "class Action:", "", "\tcb", "", "\tdef constructor(callback):", "\t\tcb = callback", "", "class A:", "", "\t[property(Go)]", "\taction = Action({ print('Hello World') })", "\"\"\""]}
{"code": "\"\"\"\n0*2 = 0\n1*2 = 2\n2*2 = 4\n\"\"\"\ndef each(items, action as callable(object)):\n\tfor item in items:\n\t\taction(item)\n\ndef map(items, function as callable(object) as object):\n\treturn function(item) for item in items\n\t\neach(map(range(3), { item as int | return item, item*2 })) do (pair):\n\tx, y = pair\n\tprint(\"${x}*2 = ${y}\")\n\t\n", "line": 15, "slice": ["\"\"\"", "def each(items, action as callable(object)):", "\tfor item in items:", "\t\taction(item)", "", "def map(items, function as callable(object) as object):", "\treturn function(item) for item in items", "\t", "each(map(range(3), { item as int | return item, item*2 })) do (pair):", "\tx, y = pair", "\tprint(\"${x}*2 = ${y}\")", "\"\"\""]}
{"code": "\"\"\"\nBar1.get_Count\n1\nBar1.Zeng\nBar2.get_Count\n2\nBar2.Zeng\n\"\"\"\ninterface IFoo:\n\tCount as int:\n\t\tget\n\t\t\ninterface IBar(IFoo):\n\tdef Zeng()\n\t\nclass Bar1(IBar):\n\tCount as int:\n\t\tget:\n\t\t\tprint(\"Bar1.get_Count\")\n\t\t\treturn 1\n\tdef Zeng():\n\t\tprint(\"Bar1.Zeng\")\n\t\t\nclass Bar2(IBar):\n\tCount as int:\n\t\tget:\n\t\t\tprint(\"Bar2.get_Count\")\n\t\t\treturn 2\n\tdef Zeng():\n\t\tprint(\"Bar2.Zeng\")\n\t\t\ndef use(bar as IBar):\n\tprint(bar.Count)\n\tbar.Zeng()\n\t\nuse(Bar1())\nuse(Bar2())\n", "line": 19, "slice": ["\"\"\"", "interface IFoo:", "\tCount as int:", "\t\tget", "\t\t", "interface IBar(IFoo):", "\tdef Zeng()", "\t", "class Bar1(IBar):", "\tCount as int:", "\t\tget:", "\t\t\tprint(\"Bar1.get_Count\")", "\t\t\treturn 1", "\tdef Zeng():", "\t\tprint(\"Bar1.Zeng\")", "\t\t", "def use(bar as IBar):", "\tprint(bar.Count)", "\tbar.Zeng()", "\t", "use(Bar1())", "\"\"\""]}
{"code": "\"\"\"\n42\n42 42\n\"\"\"\nclass Foo:\n\tpublic value as int\n\tdef operation():\n\t\treturn value\n\nwith Foo():\n\t.value = 42\n\ta = .value\n\tb = .operation()\n\tprint(.value)\n\tprint a, b\n\n", "line": 14, "slice": ["\"\"\"", "class Foo:", "\tpublic value as int", "\tdef operation():", "\t\treturn value", "", "with Foo():", "\t.value = 42", "\ta = .value", "\tb = .operation()", "\tprint(.value)", "\"\"\""]}
{"code": "\"\"\"\nstatic constructor called\n0\n1\n2\n\"\"\"\nclass Person:\n\n\tpublic static InstanceCount as int\n\t\n\tdef constructor():\n\t\t++InstanceCount\n\t\t\n\tstatic def constructor():\n\t\tprint(\"static constructor called\")\n\n\t\t\nprint(Person.InstanceCount)\np = Person()\nprint(Person.InstanceCount)\np = Person()\nprint(Person.InstanceCount)\n", "line": 15, "slice": ["class Person:", "", "\tpublic static InstanceCount as int", "\t", "\tdef constructor():", "\t\t++InstanceCount", "\t\t", "\tstatic def constructor():", "\t\tprint(\"static constructor called\")", "", "p = Person()", "p = Person()"]}
{"code": "#IGNORE: BUG - Base type reference should take into account imported namespace mapping\r\n\"\"\"\r\nA.Method0\r\nBaseClass.Method1\r\n\"\"\"\r\n\r\nfrom BooJs.Tests.Support import DerivedClass\r\n\r\nclass A(DerivedClass):\r\n\tdef Method0():\r\n\t\tprint(\"A.Method0\") #overriden method\t\r\n\t\r\n\t\t\r\na = A()\r\na.Method2() # see DerivedClass.Method2 for details\r\n", "line": 11, "slice": ["from BooJs.Tests.Support import DerivedClass", "", "class A(DerivedClass):", "\tdef Method0():", "\t\tprint(\"A.Method0\") #overriden method\t", "", "a = A()", "a.Method2() # see DerivedClass.Method2 for details"]}
{"code": "\"\"\"\n1\n2\n3\n\"\"\"\nimport NUnit.Framework\n\ndef onetwothree():\n\tyield 1\n\tyield 2\n\tyield 3\n\t\nfor expected, actual in zip(range(1, 4), onetwothree()):\n\tprint(actual)\n\tAssert.AreEqual(expected, actual)\n", "line": 14, "slice": ["\"\"\"", "import NUnit.Framework", "", "def onetwothree():", "\tyield 1", "\tyield 2", "\tyield 3", "\t", "for expected, actual in zip(range(1, 4), onetwothree()):", "\tprint(actual)", "\tAssert.AreEqual(expected, actual)", "\"\"\""]}
{"code": "\"\"\"\nclicked!\nyes, it was!\n[object Object] clicked!\n\"\"\"\nfrom BooJs.Tests.Support import Clickable\n\nbutton = Clickable()\nbutton.Click += def:\n\tprint(\"clicked!\")\n\nbutton.Click += def ():\n\tprint(\"yes, it was!\")\n\t\nbutton.Click += def (sender):\n\tprint(\"$sender clicked!\")\n\nbutton.RaiseClick()", "line": 10, "slice": ["from BooJs.Tests.Support import Clickable", "", "button = Clickable()", "", "button.Click += def:", "\tprint(\"clicked!\")", "", "button.Click += def ():", "\tprint(\"yes, it was!\")", "\t", "button.Click += def (sender):", "\tprint(\"$sender clicked!\")", "", "button.RaiseClick()"]}
{"code": "#IGNORE: BUG - Base type reference should take into account imported namespace mapping\r\n\"\"\"\r\nBaseClass.Method0\r\nA.Method0\r\nBaseClass.Method0\r\n\r\n\"\"\"\r\nfrom BooJs.Tests.Support import BaseClass\r\n\r\nclass A(BaseClass):\r\n\tdef Method0():\r\n\t\tsuper()\r\n\t\tprint(\"A.Method0\") #overriden method\r\n\t\tsuper() #base class method\r\n\t\t\r\nb as BaseClass = A()\r\nb.Method0()\r\n\r\n", "line": 13, "slice": ["from BooJs.Tests.Support import BaseClass", "", "class A(BaseClass):", "\tdef Method0():", "\t\tsuper()", "\t\tprint(\"A.Method0\") #overriden method", "\t\tsuper() #base class method", "\t\t", "b as BaseClass = A()", "b.Method0()"]}
{"code": "\"\"\"\nimport System.Collections\n\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Slice_propertyModule(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\th = Hashtable()\n\t\th.set_Item('foo', 'bar')\n\t\tBoo.Lang.Builtins.print(h.get_Item('foo'))\n\n\tprivate def constructor():\n\t\tsuper()\n\"\"\"\nimport System.Collections\n\nh = Hashtable()\nh[\"foo\"] = \"bar\"\nprint(h[\"foo\"])\n", "line": 10, "slice": ["import System.Collections", "", "h = Hashtable()", "h[\"foo\"] = \"bar\"", "print(h[\"foo\"])"]}
{"code": "\"\"\"\ndef odds(l):\n\tfor i in l:\n\t\tyield i if (0 != (i % 2))\n\ndef d(i):\n\treturn (i * 2)\n\ndef map(fn, enumerable):\n\tfor item in enumerable:\n\t\tyield fn(item)\n\nfor odd in map(d, odds([1, 2, 3, 4, 5])):\n\tprint(odd)\n\"\"\"\ndef odds(l):\n\tfor i in l:\n\t\tyield i if 0 != i % 2\n\t\t\ndef d(i):\n\treturn i*2\n\t\ndef map(fn, enumerable):\n\tfor item in enumerable:\n\t\tyield fn(item)\n\t\t\nfor odd in map(d, odds([1, 2, 3, 4, 5])):\n\tprint(odd)\n", "line": 14, "slice": ["\"\"\"", "def odds(l):", "\tfor i in l:", "\t\tyield i if (0 != (i % 2))", "", "def d(i):", "\treturn (i * 2)", "", "def map(fn, enumerable):", "\tfor item in enumerable:", "\t\tyield fn(item)", "", "for odd in map(d, odds([1, 2, 3, 4, 5])):", "\tprint(odd)", "\"\"\""]}
{"code": "import MessagePack\nimport System.Collections.Generic\nimport System.Data\nimport Mono.Data.Sqlite\nimport AdventureBot\n\npublic static class Program:\n    private LogEnabled as bool\n\n    private def Log[of T](obj as T, comment as string) as T:\n        if LogEnabled:\n            print(string.Format(\"[{0}] {1} // {2}\", obj.GetType().FullName, obj, comment))\n        return obj\n\n    public def Main(args as (string)):\n        dbPath = Log(System.IO.Path.GetFullPath(args[0]), \"dbPath\")\n        LogEnabled = args.Length > 1\n\n        dbConn = SqliteConnection(string.Format(\"Data Source = {0}\", dbPath))  # v6\n        dbConn.Open()\n\n        cmd = dbConn.CreateCommand()\n        cmd.CommandText = \"ALTER TABLE users ADD COLUMN var_lastMessage DATETIME\"\n        cmd.ExecuteNonQuery()\n\n        updateCmd = dbConn.CreateCommand()\n        updateCmd.Parameters.Add(\"@date\", DbType.DateTime).Value = System.DateTime.MinValue\n        updateCmd.CommandText = 'UPDATE users SET var_lastMessage = @date'\n        updateCmd.ExecuteNonQuery()\n\npublic def Main(args as (string)):\n    # Entry point\n    Program.Main(args)\n", "line": 12, "slice": ["import Mono.Data.Sqlite", "", "public static class Program:", "    private LogEnabled as bool", "", "    private def Log[of T](obj as T, comment as string) as T:", "        if LogEnabled:", "            print(string.Format(\"[{0}] {1} // {2}\", obj.GetType().FullName, obj, comment))", "        return obj", "", "    public def Main(args as (string)):", "        dbPath = Log(System.IO.Path.GetFullPath(args[0]), \"dbPath\")", "        LogEnabled = args.Length > 1", "", "        dbConn = SqliteConnection(string.Format(\"Data Source = {0}\", dbPath))  # v6", "        dbConn.Open()", "", "        cmd = dbConn.CreateCommand()", "        cmd.CommandText = \"ALTER TABLE users ADD COLUMN var_lastMessage DATETIME\"", "        cmd.ExecuteNonQuery()", "", "        updateCmd = dbConn.CreateCommand()", "        updateCmd.Parameters.Add(\"@date\", DbType.DateTime).Value = System.DateTime.MinValue", "        updateCmd.CommandText = 'UPDATE users SET var_lastMessage = @date'", "        updateCmd.ExecuteNonQuery()", "", "public def Main(args as (string)):", "    # Entry point", "    Program.Main(args)"]}
{"code": "\"\"\"\nnamespace Math\n\ndef square(x as int) as int:\n\treturn (x * x)\n\ndef add(x as int, y as int) as int:\n\tprint(string.Format('x = {0}, y = {1}', x, y))\n\treturn (x + y)\n\"\"\"\nnamespace Math\n\ndef square(x as int) as int:\n\treturn (x * x)\nend\n\ndef add(x as int, y as int) as int:\n\tprint(string.Format('x = {0}, y = {1}', x, y))\n\treturn (x + y)\nend\n\n", "line": 8, "slice": ["\"\"\"", "namespace Math", "", "def add(x as int, y as int) as int:", "\tprint(string.Format('x = {0}, y = {1}', x, y))", "\treturn (x + y)", "\"\"\""]}
{"code": "\"\"\"\nbefore\nevaluated\nafter\nbefore\nevaluated\nevaluated\nafter\n\"\"\"\nimport NUnit.Framework\n\ndef fun(value):\n\tprint('evaluated')\n\treturn value\n\t\na = null and true\nAssert.IsNull(a)\n\nb = true and 3\nAssert.AreSame(int, b.GetType())\nAssert.AreEqual(3, b)\n\nprint(\"before\")\nc = fun(false) and fun(true)\nprint(\"after\")\nAssert.IsFalse(c)\n\nprint(\"before\")\nd = fun(true) and fun(null)\nprint(\"after\")\nAssert.IsNull(d)\n\ne = 0 and false\nAssert.AreEqual(0, e)\n", "line": 13, "slice": ["\"\"\"", "import NUnit.Framework", "", "def fun(value):", "\tprint('evaluated')", "\treturn value", "\t", "print(\"before\")", "d = fun(true) and fun(null)", "print(\"after\")", "Assert.IsNull(d)", "\"\"\""]}
{"code": "\"\"\"\nint: 3\nstring: foo\n\"\"\"\nimport System.Console\n\ndef print(value as int):\n\tWrite(\"int: \")\n\tWriteLine(value)\n\n\t\ndef print(value as string):\n\tWrite(\"string: \")\n\tWriteLine(value)\n\nprint(3)\nprint(\"foo\")\n\t\n", "line": 7, "slice": ["\"\"\"", "import System.Console", "", "def print(value as int):", "\tWrite(\"int: \")", "\tWriteLine(value)", "", "print(3)", "\"\"\""]}
{"code": "\"\"\"\n1\n3\n5\n2\n4\n6\n\"\"\"\n\n\ndef odds(begin, end):\n\treturn i for i in range(begin, end) if i % 2\n\t\ndef evens(begin, end):\n\treturn i for i in range(begin, end) unless i % 2\n\n\t\nfor expected, actual in zip((1, 3, 5), odds(1, 6)):\n\tprint(actual)\n\tassert expected == actual\n\t\nfor expected, actual in zip((2, 4, 6), evens(1, 7)):\n\tprint(actual)\n\tassert expected == actual\n\t\n", "line": 19, "slice": ["\"\"\"", "def odds(begin, end):", "\treturn i for i in range(begin, end) if i % 2", "\t", "for expected, actual in zip((1, 3, 5), odds(1, 6)):", "\tprint(actual)", "\tassert expected == actual", "\"\"\""]}
{"code": "\"\"\"\n0\n1\n2\n\"\"\"\nclass Person:\n\n\tpublic static InstanceCount as int\n\t\n\tdef constructor():\n\t\t++InstanceCount\n\n\t\t\nprint(Person.InstanceCount)\np = Person()\nprint(Person.InstanceCount)\np = Person()\nprint(Person.InstanceCount)\n", "line": 14, "slice": ["\"\"\"", "class Person:", "", "\tpublic static InstanceCount as int", "\t", "\tdef constructor():", "\t\t++InstanceCount", "", "\t\t", "print(Person.InstanceCount)", "p = Person()", "print(Person.InstanceCount)", "p = Person()", "print(Person.InstanceCount)", "\"\"\""]}
{"code": "\"\"\"\r\n1 - clicked!\r\n2 - clicked!\r\n\"\"\"\r\nimport BooJs.Tests.Support\r\n\r\nclass Handler:\r\n\t\r\n\tpublic State = null\r\n\t\t\r\n\tdef clicked(sender):\r\n\t\tprint(\"${State} - clicked!\")\r\n\r\nhandler = Handler(State: 1)\r\n\r\nc = Clickable()\r\nc.Click += handler.clicked\r\nc.RaiseClick()\r\nc.Click -= handler.clicked\r\n\r\nhandler.State = 2\r\nc.Click += handler.clicked\r\nc.RaiseClick()\r\n", "line": 12, "slice": ["import BooJs.Tests.Support", "", "class Handler:", "\t", "\tpublic State = null", "\t\t", "\tdef clicked(sender):", "\t\tprint(\"${State} - clicked!\")", "", "handler = Handler(State: 1)", "", "c = Clickable()", "c.Click += handler.clicked", "", "handler.State = 2", "c.Click += handler.clicked", "c.RaiseClick()"]}
{"code": "\"\"\"\nElvin Jones\n\"\"\"\nclass Person:\n\n\t_id as string\n\t_name as string\n\n\tdef constructor(id as string, name as string):\n\t\t_id = id\n\t\t_name = name\n\n\tID as string:\n\t\tget:\n\t\t\treturn _id\n\n\tName as string:\n\t\tget:\n\t\t\treturn _name\n\t\tset:\n\t\t\t_name = value\n\nc = Person(\"elvin\", \"Elvin Jones\")\nprint(c.Name)\n", "line": 24, "slice": ["\"\"\"", "Elvin Jones", "\"\"\"", "class Person:", "", "\t_id as string", "\t_name as string", "", "\tdef constructor(id as string, name as string):", "\t\t_id = id", "\t\t_name = name", "", "\tName as string:", "\t\tget:", "\t\t\treturn _name", "\t\tset:", "\t\t\t_name = value", "", "c = Person(\"elvin\", \"Elvin Jones\")"]}
{"code": "#UNSUPPORTED: Threads not supported\r\n\"\"\"\r\nbefore assignment...\r\nbefore invocation...\r\nfoo!\r\ndone.\r\n\"\"\"\r\nimport System.Threading\r\n\r\ndef foo():\r\n\tprint(\"foo!\")\r\n\t\r\nfunction as ThreadStart\r\nprint(\"before assignment...\")\r\nfunction = foo\r\nprint(\"before invocation...\")\r\nfunction()\r\nprint(\"done.\")\r\n", "line": 11, "slice": ["import System.Threading", "", "def foo():", "\tprint(\"foo!\")", "\t", "function as ThreadStart", "function = foo", "function()"]}
{"code": "\"\"\"\n4\n\"\"\"\nclass Integer:\n\t_value as int\n\t\n\tdef constructor(value as int):\n\t\t_value = value\n\t\n\tValue:\n\t\tget:\n\t\t\treturn _value\n\t\tset:\n\t\t\t_value = value\n\n\toverride def ToString():\n\t\treturn _value.ToString()\n\ni = Integer(3)\nprint(++i.Value)\n", "line": 20, "slice": ["\"\"\"", "class Integer:", "\t_value as int", "\t", "\tdef constructor(value as int):", "\t\t_value = value", "\t", "\tValue:", "\t\tget:", "\t\t\treturn _value", "\t\tset:", "\t\t\t_value = value", "", "i = Integer(3)", "print(++i.Value)", "\"\"\""]}
{"code": "\"\"\"\nBaseClass.Method0\nA.Method0\nBaseClass.Method0\n\n\"\"\"\nimport BooCompiler.Tests from BooCompiler.Tests\n\nclass A(BaseClass):\n\tdef Method0():\n\t\tsuper()\n\t\tprint(\"A.Method0\") #overriden method\n\t\tsuper() #base class method\n\t\t\nb as BaseClass = A()\nb.Method0()\n\n", "line": 12, "slice": ["\"\"\"", "class A(BaseClass):", "\tdef Method0():", "\t\tsuper()", "\t\tprint(\"A.Method0\") #overriden method", "\t\tsuper() #base class method", "\t\t", "b as BaseClass = A()", "b.Method0()", "\"\"\""]}
{"code": "\"\"\"\r\ndo: 0\r\ndo: 1\r\ndo: 2\r\nclosure: 0\r\nclosure: 1\r\nclosure: 2\r\ninline: 0\r\ninline: 1\r\ninline: 2\r\nblock: 0\r\nblock: 1\r\nblock: 2\r\n\"\"\"\r\ncallable Action(item)\r\n\r\ndef each(items, action as Action):\r\n     for item in items:\r\n          action(item)\r\n\r\na = def (item):\r\n    print(\"do: ${item}\")\r\n\r\nb = { item | print(\"closure: ${item}\") }\r\n\r\neach(range(3), a)\r\neach(range(3), b)\r\neach(range(3), { item | print(\"inline: ${item}\") })\r\n\r\neach(range(3)) do (item):\r\n     print(\"block: ${item}\")\r\n\r\n\r\n", "line": 22, "slice": ["\"\"\"", "callable Action(item)", "", "def each(items, action as Action):", "     for item in items:", "          action(item)", "", "each(range(3)) do (item):", "     print(\"block: ${item}\")", "\"\"\""]}
{"code": "\"\"\"\nbefore\nDispose(True)\nafter\nDispose(False)\n\"\"\"\nimport System\n\nclass Disposable(IDisposable):\n\tdef Dispose():\n\t\tDispose(true)\n\t\t\n\tdef Dispose(flag as bool):\n\t\tprint(\"Dispose(${flag})\")\n\t\t\nprint(\"before\")\nusing d=Disposable():\n\tpass\nprint(\"after\")\t\nd.Dispose(false)\n", "line": 14, "slice": ["import System", "", "class Disposable(IDisposable):", "\tdef Dispose():", "\t\tDispose(true)", "\t\t", "\tdef Dispose(flag as bool):", "\t\tprint(\"Dispose(${flag})\")", "\t\t", "using d=Disposable():", "\tpass", "d.Dispose(false)"]}
{"code": "\"\"\"\nA.constructor\nA.constructor\nB.constructor\nC.constructor\nA.constructor\nA.constructor\nB.constructor\nD.constructor\n\"\"\"\nclass A:\n\tdef constructor():\n\t\tprint(\"A.constructor\")\n\t\t\nclass B(A):\n\tdef constructor():\n\t\tsuper()\n\t\tprint(\"B.constructor\")\n\t\t\nclass C(A):\n\tdef constructor():\n\t\tprint(\"C.constructor\")\n\t\tsuper()\n\t\t\nclass D(B):\n\tdef constructor():\n\t\tprint(\"D.constructor\")\n\t\t\nA()\nB()\nC()\nD()\n", "line": 13, "slice": ["\"\"\"", "class A:", "\tdef constructor():", "\t\tprint(\"A.constructor\")", "\t\t", "class B(A):", "\tdef constructor():", "\t\tsuper()", "\t\tprint(\"B.constructor\")", "\t\t", "class D(B):", "\tdef constructor():", "\t\tprint(\"D.constructor\")", "\t\t", "B()", "D()", "\"\"\""]}
{"code": "\"\"\"\nstarted\nexecuting\ncallback\ndone\n\"\"\"\nimport System\n\ndef callback(result as IAsyncResult):\n\tprint(\"callback\")\n\t\ndef run():\n\tprint(\"executing\")\n\t\nprint(\"started\")\n\nresult = run.BeginInvoke(callback, null)\nSystem.Threading.Thread.Sleep(50ms)\nrun.EndInvoke(result)\n\nprint(\"done\")\n", "line": 10, "slice": ["\"\"\"", "import System", "", "def callback(result as IAsyncResult):", "\tprint(\"callback\")", "\t", "def run():", "\tprint(\"executing\")", "\t", "print(\"started\")", "", "result = run.BeginInvoke(callback, null)", "System.Threading.Thread.Sleep(50ms)", "run.EndInvoke(result)", "\"\"\""]}
{"code": "\"\"\"\nstarted\nexecuting\ncalled back\ndone\n\"\"\"\nimport System\n\t\ndef run(message):\n\tprint(message)\n\treturn 42\n\t\nprint(\"started\")\n\n# BeginInvoke is overloaded\n# in this example we call the version\n# that takes only the callback after the method's parameters\nresult = run.BeginInvoke(\"executing\", { print(\"called back\") }, null)\nSystem.Threading.Thread.Sleep(50ms)\nassert 42 == run.EndInvoke(result)\n\nprint(\"done\")\n", "line": 10, "slice": ["\"\"\"", "import System", "\t", "def run(message):", "\tprint(message)", "\treturn 42", "\t", "print(\"started\")", "", "result = run.BeginInvoke(\"executing\", { print(\"called back\") }, null)", "System.Threading.Thread.Sleep(50ms)", "assert 42 == run.EndInvoke(result)", "\"\"\""]}
{"code": "\"\"\"\nHello World\n\"\"\"\nclass Action:\n\tcb\n\tdef constructor(callback):\n\t\tcb = callback\n\t\t\n\tdef go():\n\t\tcast(callable, cb)()\n\t\t\nclass A:\n\taction = Action({ print(\"Hello World\"); })\n\t\n\tdef go():\n\t\taction.go()\n\t\t\nA().go()\n\t\n\n\n\n\n", "line": 13, "slice": ["\"\"\"", "Hello World", "\"\"\"", "class Action:", "\tcb", "\tdef constructor(callback):", "\t\tcb = callback", "\t\t", "\tdef go():", "\t\tcast(callable, cb)()", "\t\t", "class A:", "\taction = Action({ print(\"Hello World\"); })", "\t", "\tdef go():", "\t\taction.go()", "\t\t", "A().go()"]}
{"code": "\"\"\"\r\nadded\r\nclicked!\r\nremoved\r\nadded\r\nclicked!\r\nremoved\r\n\"\"\"\r\nimport BooCompiler.Tests.SupportingClasses from BooCompiler.Tests\r\n\r\nclass Application:\r\n\t\r\n\tdef Run():\t\t\r\n\t\tc = Clickable()\r\n\t\t\r\n\t\tfor i in range(2):\t\t\t\r\n\t\t\tc.Click += clicked\r\n\t\t\tprint(\"added\")\r\n\t\t\r\n\t\t\tc.RaiseClick()\r\n\t\t\r\n\t\t\tc.Click -= clicked\r\n\t\t\tprint(\"removed\")\r\n\t\t\t\r\n\t\t\tc.RaiseClick()\r\n\t\t\r\n\tdef clicked(sender, args as System.EventArgs):\r\n\t\tprint(\"clicked!\")\r\n\t\t\r\nApplication().Run()\r\n", "line": 18, "slice": ["\"\"\"", "import BooCompiler.Tests.SupportingClasses from BooCompiler.Tests", "", "class Application:", "\t", "\tdef Run():\t\t", "\t\tc = Clickable()", "\t\t", "\t\tfor i in range(2):\t\t\t", "\t\t\tc.Click += clicked", "\t\t\tprint(\"added\")", "\t\t", "\t\t\tc.RaiseClick()", "\t\t", "\t\t\tc.Click -= clicked", "\t\t\tprint(\"removed\")", "\t\t\t", "\tdef clicked(sender, args as System.EventArgs):", "\t\tprint(\"clicked!\")", "\t\t", "Application().Run()", "\"\"\""]}
{"code": "\"\"\"\nimport System.IO\n\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Using1Module(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\t\\$using\\$disposable\\$2 = ((f1 = File.OpenText('using0.boo')) as System.IDisposable)\n\t\ttry:\n\t\t\t\\$using\\$disposable\\$1 = ((f2 = File.OpenText('using1.boo')) as System.IDisposable)\n\t\t\ttry:\n\t\t\t\tBoo.Lang.Builtins.print(f2.ReadLine())\n\t\t\tensure:\n\t\t\t\tif \\$using\\$disposable\\$1 is not null:\n\t\t\t\t\t\\$using\\$disposable\\$1.Dispose()\n\t\t\t\t\t\\$using\\$disposable\\$1 = null\n\t\t\tBoo.Lang.Builtins.print(f1.ReadLine())\n\t\tensure:\n\t\t\tif \\$using\\$disposable\\$2 is not null:\n\t\t\t\t\\$using\\$disposable\\$2.Dispose()\n\t\t\t\t\\$using\\$disposable\\$2 = null\n\n\tprivate def constructor():\n\t\tsuper()\n\n\"\"\"\nimport System.IO\n\nusing f1 = File.OpenText('using0.boo'):\n\tusing f2 = File.OpenText('using1.boo'):\n\t\tprint(f2.ReadLine())\n\tprint(f1.ReadLine())\n", "line": 12, "slice": ["\"\"\"", "import System.IO", "", "[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]", "public final transient class Using1Module(object):", "", "\tprivate static def Main(argv as (string)) as void:", "\t\t\\$using\\$disposable\\$2 = ((f1 = File.OpenText('using0.boo')) as System.IDisposable)", "\t\ttry:", "\t\t\t\\$using\\$disposable\\$1 = ((f2 = File.OpenText('using1.boo')) as System.IDisposable)", "\t\t\ttry:", "\t\t\t\tBoo.Lang.Builtins.print(f2.ReadLine())", "\t\t\tensure:", "\t\t\t\tif \\$using\\$disposable\\$1 is not null:", "\t\t\t\t\t\\$using\\$disposable\\$1.Dispose()", "\t\t\t\t\t\\$using\\$disposable\\$1 = null", "\t\t\tBoo.Lang.Builtins.print(f1.ReadLine())", "\t\tensure:", "\t\t\tif \\$using\\$disposable\\$2 is not null:", "\t\t\t\t\\$using\\$disposable\\$2.Dispose()", "\t\t\t\t\\$using\\$disposable\\$2 = null", "\"\"\"", "import System.IO", "", "using f1 = File.OpenText('using0.boo'):", "\tprint(f1.ReadLine())"]}
{"code": "\"\"\"\n-1\n\"\"\"\nimport System\n\nclass FooAttribute(Attribute):\n\tpublic Value as int\n\t\nclass Bar:\n\t[Foo(Value: -1)]\n\tdef Zeng():\n\t\tpass\n\t\t\ndef DumpFooValue(methodName as string):\t\t\n\tattributes = Attribute.GetCustomAttributes(typeof(Bar).GetMethod(methodName), FooAttribute)\n\tassert 1 == len(attributes)\n\tprint((attributes[0] as FooAttribute).Value)\n\t\nDumpFooValue(\"Zeng\")\n", "line": 17, "slice": ["\"\"\"", "-1", "\"\"\"", "import System", "", "class FooAttribute(Attribute):", "\tpublic Value as int", "\t", "class Bar:", "\t[Foo(Value: -1)]", "\tdef Zeng():", "\t\tpass", "\t\t", "def DumpFooValue(methodName as string):\t\t", "\tattributes = Attribute.GetCustomAttributes(typeof(Bar).GetMethod(methodName), FooAttribute)", "\tprint((attributes[0] as FooAttribute).Value)", "\t", "DumpFooValue(\"Zeng\")"]}
{"code": "\"\"\"\nIFoo.Foo\n\"\"\"\ninterface IFoo:\n\n\tdef Foo()\n\t\nclass Foo(IFoo):\n\tdef Foo():\n\t\tprint(\"IFoo.Foo\")\n\ndef fight(foo as IFoo):\n\tfoo.Foo()\n\nfight(Foo())\n", "line": 10, "slice": ["\"\"\"", "interface IFoo:", "", "\tdef Foo()", "\t", "class Foo(IFoo):", "\tdef Foo():", "\t\tprint(\"IFoo.Foo\")", "", "def fight(foo as IFoo):", "\tfoo.Foo()", "", "fight(Foo())", "\"\"\""]}
{"code": "\"\"\"\r\nFOO\r\nfoo\r\n\"\"\"\r\ndef ToUpper(s as string):\r\n\treturn s.toUpperCase()\r\n\t\r\ndef ToLower(s as string):\r\n\treturn s.toLowerCase()\r\n\r\ndef Select(upper as bool):\t\r\n\treturn ToUpper if upper\r\n\treturn ToLower\r\n\r\na = \"Foo\"\r\nprint(Select(true)(a))\r\nprint(Select(false)(a))\r\n", "line": 16, "slice": ["def ToUpper(s as string):", "\treturn s.toUpperCase()", "\t", "def ToLower(s as string):", "\treturn s.toLowerCase()", "", "def Select(upper as bool):\t", "\treturn ToUpper if upper", "\treturn ToLower", "", "a = \"Foo\"", "print(Select(true)(a))"]}
{"code": "\"\"\"\nDerivedClass\n\"\"\"\nimport System\nimport System.Xml.Serialization from System.Xml\nimport BooCompiler.Tests from BooCompiler.Tests\n\nclass C:\n\t[XmlInclude(DerivedClass)]\t\n\tdef GetItem() as BaseClass:\n\t\tpass\n\nGetItem = typeof(C).GetMethod(\"GetItem\")\nxmlinc as XmlIncludeAttribute = Attribute.GetCustomAttribute(GetItem, XmlIncludeAttribute)\nprint(xmlinc.Type.Name)\n", "line": 15, "slice": ["\"\"\"", "DerivedClass", "\"\"\"", "import System", "import System.Xml.Serialization from System.Xml", "", "class C:", "\t[XmlInclude(DerivedClass)]\t", "\tdef GetItem() as BaseClass:", "\t\tpass", "", "GetItem = typeof(C).GetMethod(\"GetItem\")", "xmlinc as XmlIncludeAttribute = Attribute.GetCustomAttribute(GetItem, XmlIncludeAttribute)"]}
{"code": "\"\"\"\r\nadded\r\nclicked!\r\nremoved\r\nadded\r\nclicked!\r\nremoved\r\n\"\"\"\r\nimport BooJs.Tests.Support\r\n\r\nclass Application:\r\n\t\r\n\tdef Run():\t\t\r\n\t\tc = Clickable()\r\n\t\t\r\n\t\tfor i in range(2):\t\t\t\r\n\t\t\tc.Click += clicked\r\n\t\t\tprint(\"added\")\r\n\t\t\r\n\t\t\tc.RaiseClick()\r\n\t\t\r\n\t\t\tc.Click -= clicked\r\n\t\t\tprint(\"removed\")\r\n\t\t\t\r\n\t\t\tc.RaiseClick()\r\n\t\t\r\n\tdef clicked(sender):\r\n\t\tprint(\"clicked!\")\r\n\t\t\r\nApplication().Run()\r\n", "line": 18, "slice": ["class Application:", "\t", "\tdef Run():\t\t", "\t\tc = Clickable()", "\t\t", "\t\tfor i in range(2):\t\t\t", "\t\t\tc.Click += clicked", "\t\t\tprint(\"added\")", "\t\t", "\t\t\tc.RaiseClick()", "\t\t", "\t\t\tc.Click -= clicked", "\t\t\tprint(\"removed\")", "\t\t\t", "\t\t\tc.RaiseClick()", "\t\t", "\tdef clicked(sender):", "\t\tprint(\"clicked!\")", "\t\t", "Application().Run()"]}
{"code": "\"\"\"\r\nA.constructor\r\nA.constructor\r\nB.constructor\r\nC.constructor\r\nA.constructor\r\nA.constructor\r\nB.constructor\r\nD.constructor\r\n\"\"\"\r\nclass A:\r\n\tdef constructor():\r\n\t\tprint(\"A.constructor\")\r\n\t\t\r\nclass B(A):\r\n\tdef constructor():\r\n\t\tsuper()\r\n\t\tprint(\"B.constructor\")\r\n\t\t\r\nclass C(A):\r\n\tdef constructor():\r\n\t\tprint(\"C.constructor\")\r\n\t\tsuper()\r\n\t\t\r\nclass D(B):\r\n\tdef constructor():\r\n\t\tprint(\"D.constructor\")\r\n\t\t\r\nA()\r\nB()\r\nC()\r\nD()\r\n", "line": 13, "slice": ["\"\"\"", "class A:", "\tdef constructor():", "\t\tprint(\"A.constructor\")", "\t\t", "class B(A):", "\tdef constructor():", "\t\tsuper()", "\t\tprint(\"B.constructor\")", "\t\t", "class D(B):", "\tdef constructor():", "\t\tprint(\"D.constructor\")", "\t\t", "B()", "D()", "\"\"\""]}
{"code": "\"\"\"\nimport System.IO\n\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Using1Module(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\t__using2__ = ((f1 = File.OpenText('using0.boo')) as System.IDisposable)\n\t\ttry:\n\t\t\t__using1__ = ((f2 = File.OpenText('using1.boo')) as System.IDisposable)\n\t\t\ttry:\n\t\t\t\tBoo.Lang.Builtins.print(f2.ReadLine())\n\t\t\tensure:\n\t\t\t\tif __using1__ is not null:\n\t\t\t\t\t__using1__.Dispose()\n\t\t\t\t\t__using1__ = null\n\t\t\tBoo.Lang.Builtins.print(f1.ReadLine())\n\t\tensure:\n\t\t\tif __using2__ is not null:\n\t\t\t\t__using2__.Dispose()\n\t\t\t\t__using2__ = null\n\n\tprivate def constructor():\n\t\tsuper()\n\n\"\"\"\nimport System.IO\n\nusing f1 = File.OpenText('using0.boo'):\n\tusing f2 = File.OpenText('using1.boo'):\n\t\tprint(f2.ReadLine())\n\tprint(f1.ReadLine())\n", "line": 12, "slice": ["\"\"\"", "import System.IO", "", "[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]", "public final transient class Using1Module(object):", "", "\tprivate static def Main(argv as (string)) as void:", "\t\t__using2__ = ((f1 = File.OpenText('using0.boo')) as System.IDisposable)", "\t\ttry:", "\t\t\t__using1__ = ((f2 = File.OpenText('using1.boo')) as System.IDisposable)", "\t\t\ttry:", "\t\t\t\tBoo.Lang.Builtins.print(f2.ReadLine())", "\t\t\tensure:", "\t\t\t\tif __using1__ is not null:", "\t\t\t\t\t__using1__.Dispose()", "\t\t\t\t\t__using1__ = null", "\t\t\tBoo.Lang.Builtins.print(f1.ReadLine())", "\t\tensure:", "\t\t\tif __using2__ is not null:", "\t\t\t\t__using2__.Dispose()", "\t\t\t\t__using2__ = null", "\"\"\"", "import System.IO", "", "using f1 = File.OpenText('using0.boo'):", "\tprint(f1.ReadLine())"]}
{"code": "\"\"\"\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Using0Module(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\t__using1__ = ((f = System.IO.File.OpenText('using0.boo')) as System.IDisposable)\n\t\ttry:\n\t\t\tBoo.Lang.Builtins.print(f.ReadLine())\n\t\tensure:\n\t\t\tif __using1__ is not null:\n\t\t\t\t__using1__.Dispose()\n\t\t\t\t__using1__ = null\n\n\tprivate def constructor():\n\t\tsuper()\n\n\"\"\"\nusing f = System.IO.File.OpenText('using0.boo'):\n\tprint(f.ReadLine())\n", "line": 8, "slice": ["[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]", "public final transient class Using0Module(object):", "", "\tprivate static def Main(argv as (string)) as void:", "\t\t__using1__ = ((f = System.IO.File.OpenText('using0.boo')) as System.IDisposable)", "\t\ttry:", "\t\t\tBoo.Lang.Builtins.print(f.ReadLine())", "\t\tensure:", "\t\t\tif __using1__ is not null:", "\t\t\t\t__using1__.Dispose()", "\t\t\t\t__using1__ = null", "", "using f = System.IO.File.OpenText('using0.boo'):", "\tprint(f.ReadLine())"]}
{"code": "\"\"\"\r\nhandler - clicked!\r\nhandler - clicked!\r\n\"\"\"\r\nimport BooJs.Tests.Support\r\n\r\nclass Handler:\r\n\t\r\n\ttag = null\r\n\t\r\n\tdef constructor(tag):\r\n\t\tself.tag = tag\r\n\t\t\r\n\tdef clicked(sender):\r\n\t\tprint(\"${tag} - clicked!\")\r\n\r\nc = Clickable()\r\nc.Click += Handler(\"handler\").clicked\r\nc.RaiseClick()\r\nc.RaiseClick()\r\n", "line": 15, "slice": ["class Handler:", "\t", "\ttag = null", "\t", "\tdef constructor(tag):", "\t\tself.tag = tag", "\t\t", "\tdef clicked(sender):", "\t\tprint(\"${tag} - clicked!\")", "", "c = Clickable()", "c.Click += Handler(\"handler\").clicked", "c.RaiseClick()", "c.RaiseClick()"]}
{"code": "\"\"\"\r\n: foo!\r\n: bar!\r\nspam!\r\nbefore\r\nend.\r\n\"\"\"\r\nclass Foo:\r\n\r\n\tpublic bar = def (msg):\r\n\t\tprint(\"${prefix}${msg}\")\r\n\t\r\n\tprefix = \": \"\r\n\t\r\nf = Foo()\r\nf.bar(\"foo!\")\r\nf.bar(\"bar!\")\r\n\r\nf.bar = def (msg):\r\n\tprint(msg)\r\n\t\r\nf.bar(\"spam!\")\r\n\r\nf.bar = def (msg):\r\n\tpass\r\n\t\r\nprint(\"before\")\r\nf.bar(\"eggs!\")\r\nprint(\"end.\")\r\n", "line": 11, "slice": ["class Foo:", "", "\tpublic bar = def (msg):", "\t\tprint(\"${prefix}${msg}\")", "\t", "\tprefix = \": \"", "\t", "f = Foo()", "f.bar(\"foo!\")", "f.bar(\"bar!\")", "", "f.bar = def (msg):", "\tprint(msg)", "\t", "f.bar(\"spam!\")", "", "f.bar = def (msg):", "\tpass", "\t", "print(\"before\")", "f.bar(\"eggs!\")"]}
{"code": "\"\"\"\nA.Method0\nBaseClass.Method1\nA.Method2\n\n\"\"\"\nimport BooCompiler.Tests from BooCompiler.Tests\n\nclass A(BaseClass):\n\tdef Method0():\n\t\tprint(\"A.Method0\") #overriden method\n\t\t\n\tdef Method2():\n\t\tprint(\"A.Method2\") #new method\n\t\t\nb as BaseClass = A()\nb.Method0()\nb.Method1()\n\n(b as A).Method2()\n\n", "line": 11, "slice": ["\"\"\"", "import BooCompiler.Tests from BooCompiler.Tests", "", "class A(BaseClass):", "\tdef Method0():", "\t\tprint(\"A.Method0\") #overriden method", "\t\t", "\tdef Method2():", "\t\tprint(\"A.Method2\") #new method", "\t\t", "b as BaseClass = A()", "", "(b as A).Method2()", "\"\"\""]}
{"code": "\"\"\"\ncompile time\nruntime\nbefore\nduring\nafter\n\"\"\"\nimport Boo.Lang.Compiler.Ast\nimport Boo.Lang.Compiler.MetaProgramming\n\n[meta]\ndef surround(block as BlockExpression):\n\tprint \"compile time\"\n\treturn [|\n\t\tprint(\"before\")\n\t\t$(block.Body)\n\t\tprint(\"after\")\n\t|]\n\ntypeDef = [|\n\tclass Test:\n\t\tdef Run():\n\t\t\tsurround:\n\t\t\t\tprint \"during\"\n|]\n\ntype = compile(typeDef, System.Reflection.Assembly.GetExecutingAssembly())\nprint \"runtime\"\n(type() as duck).Run()\n\n", "line": 15, "slice": ["\"\"\"", "import Boo.Lang.Compiler.Ast", "import Boo.Lang.Compiler.MetaProgramming", "", "[meta]", "def surround(block as BlockExpression):", "\tprint \"compile time\"", "\treturn [|", "\t\tprint(\"before\")", "\t\t$(block.Body)", "\t\tprint(\"after\")", "\t|]", "", "typeDef = [|", "\tclass Test:", "\t\tdef Run():", "\t\t\tsurround:", "\t\t\t\tprint \"during\"", "|]", "", "type = compile(typeDef, System.Reflection.Assembly.GetExecutingAssembly())", "(type() as duck).Run()", "\"\"\""]}
{"code": "namespace UnityScript.Tests\n\nimport System\nimport System.Reflection\n\nimport NUnit.Framework\nimport UnityScript\nimport Boo.Lang.Compiler.IO\n\n[TestFixture]\nclass EvalCompilationTest(AbstractCompilerTest):\n\t\n\toverride def CreateCompilerPipeline():\n\t\treturn UnityScriptCompiler.Pipelines.CompileToFile()\n\t\n\t[Test]\n\tdef OnlyAssembliesWithReferencedTypesEndUpBeingReferenced():\n\t\t\n\t\texpected = (\"mscorlib\", \"UnityScript\", \"UnityScript.Tests\")\n\t\tcode = \"\"\"\n\t\teval(\"print(\\\"hello\\\")\");\n\t\t\"\"\"\n\t\tAssertAssemblyReferencesForEval expected, code\n\t\t\n\t[Test]\n\tdef OnlyAssembliesWithReferencedTypesEndUpBeingReferencedIncludingGenerics():\n\t\t\n\t\texpected = (\"Boo.Lang\", \"mscorlib\", \"UnityScript\", \"UnityScript.Tests\")\n\t\tcode = \"\"\"\n\t\tvar foo = new Boo.Lang.List.<String>();\n\t\teval(\"print(\\\"hello\\\")\");\n\t\t\"\"\"\n\t\tAssertAssemblyReferencesForEval expected, code\n\t\t\n\tdef AssertAssemblyReferencesForEval(expected as (string), code as string):\n\t\t\n\t\tresult = CompileTestCase(StringInput(\"t$(++_testId).js\", code))\n\t\tassert len(result.Errors) == 0, result.Errors.ToString()\n\t\t\n\t\tactual = array(assemblyName.Name for assemblyName in Assembly.LoadFrom(Parameters.OutputAssembly).GetReferencedAssemblies())\n\t\tArray.Sort(actual)\n\t\tAssert.AreEqual(expected, actual)\n\t\t\n\t_testId = 0\n\t\t\n", "line": 21, "slice": ["namespace UnityScript.Tests", "", "import System", "import System.Reflection", "", "import NUnit.Framework", "import UnityScript", "import Boo.Lang.Compiler.IO", "", "[TestFixture]", "class EvalCompilationTest(AbstractCompilerTest):", "\t", "\toverride def CreateCompilerPipeline():", "\t\treturn UnityScriptCompiler.Pipelines.CompileToFile()", "\t", "\t[Test]", "\tdef OnlyAssembliesWithReferencedTypesEndUpBeingReferenced():", "\t\t", "\t\texpected = (\"mscorlib\", \"UnityScript\", \"UnityScript.Tests\")", "\t\tcode = \"\"\"", "\t\teval(\"print(\\\"hello\\\")\");", "\t\t\"\"\"", "\t\tAssertAssemblyReferencesForEval expected, code", "\t\t", "\tdef AssertAssemblyReferencesForEval(expected as (string), code as string):", "\t\t", "\t\tresult = CompileTestCase(StringInput(\"t$(++_testId).js\", code))", "\t\tassert len(result.Errors) == 0, result.Errors.ToString()", "\t\t", "\t\tactual = array(assemblyName.Name for assemblyName in Assembly.LoadFrom(Parameters.OutputAssembly).GetReferencedAssemblies())", "\t\tArray.Sort(actual)", "\t\tAssert.AreEqual(expected, actual)", "\t\t", "\t_testId = 0"]}
{"code": "\"\"\"\nSystem.String\nget_Name\nnull\nSystem.String\nnull\nset_Name\nSystem.String\nget_Name\nset_Name\n\"\"\"\nimport System.Reflection\n\ninterface IFoo:\n\tName as string:\n\t\tget\n\t\t\ninterface IBar:\n\tName as string:\n\t\tset\n\n\ninterface IBaz:\n\tName as string:\n\t\tget\n\t\tset\n\t\t\ndef dump(property as PropertyInfo):\n\tprint(property.PropertyType)\n\t\n\tgetter = property.GetGetMethod()\n\tif getter is null:\n\t\tprint(\"null\")\n\telse:\n\t\tprint(getter.Name)\n\tsetter = property.GetSetMethod()\n\tif setter is null:\n\t\tprint(\"null\")\n\telse:\n\t\tprint(setter.Name)\n\ndump(typeof(IFoo).GetProperties()[0])\ndump(typeof(IBar).GetProperties()[0])\ndump(typeof(IBaz).GetProperties()[0])\n", "line": 29, "slice": ["\"\"\"", "System.String", "get_Name", "null", "System.String", "null", "set_Name", "System.String", "get_Name", "set_Name", "\"\"\"", "import System.Reflection", "", "interface IFoo:", "\tName as string:", "\t\tget", "\t\t", "interface IBar:", "\tName as string:", "\t\tset", "", "", "interface IBaz:", "\tName as string:", "\t\tget", "\t\tset", "\t\t", "def dump(property as PropertyInfo):", "\tprint(property.PropertyType)", "\t", "\tgetter = property.GetGetMethod()", "\tif getter is null:", "\t\tprint(\"null\")", "\telse:", "\t\tprint(getter.Name)", "\tsetter = property.GetSetMethod()", "\tif setter is null:", "\t\tprint(\"null\")", "\telse:", "\t\tprint(setter.Name)", "", "dump(typeof(IBaz).GetProperties()[0])"]}
{"code": "#UNSUPPORTED: Meta programming not supported yet\r\n\"\"\"\r\ncompile time\r\nruntime\r\nbefore\r\nduring\r\nafter\r\n\"\"\"\r\nimport Boo.Lang.Compiler.Ast\r\nimport Boo.Lang.Compiler.MetaProgramming\r\n\r\n[meta]\r\ndef surround(block as BlockExpression):\r\n\tprint \"compile time\"\r\n\treturn [|\r\n\t\tprint(\"before\")\r\n\t\t$(block.Body)\r\n\t\tprint(\"after\")\r\n\t|]\r\n\r\ntypeDef = [|\r\n\tclass Test:\r\n\t\tdef Run():\r\n\t\t\tsurround:\r\n\t\t\t\tprint \"during\"\r\n|]\r\n\r\ntype = compile(typeDef, System.Reflection.Assembly.GetExecutingAssembly())\r\nprint \"runtime\"\r\n(type() as duck).Run()\r\n\r\n", "line": 16, "slice": ["import Boo.Lang.Compiler.Ast", "import Boo.Lang.Compiler.MetaProgramming", "", "[meta]", "def surround(block as BlockExpression):", "\tprint \"compile time\"", "\treturn [|", "\t\tprint(\"before\")", "\t\t$(block.Body)", "\t\tprint(\"after\")", "\t|]", "", "typeDef = [|", "\tclass Test:", "\t\tdef Run():", "\t\t\tsurround:", "\t\t\t\tprint \"during\"", "|]", "", "type = compile(typeDef, System.Reflection.Assembly.GetExecutingAssembly())", "(type() as duck).Run()"]}
{"code": "\"\"\"module docstring\"\"\"\n\nnamespace My.NameSpace #optional namespace declaration\n\nimport Assembly.Reference #import statements\n\n#followed by the Members of this module (classes, methods, etc.)\nclass MyClass:\n    pass\n\ndef domyfunction(it):\n    print(it)\n\n#start \"main\" section that is executed when script is run\nx as int\nx = 3\ndomyfunction(x)\n\n#optional assembly attribute declarations used when compiling\n[assembly: AssemblyTitle('foo')]\n[assembly: AssemblyDescription('bar')]\n\nimport MyLibrary\nprint (Version)\ndoit()\n\n[Module]\nclass MainClass:\n    public static Version as string\n\n    static def constructor():\n        Version = \"0.1\"\n\ndef doit():\n    #you can refer to \"globals\" from within your library, too:\n    print(\"This library's version is: \"+MainClass.Version)\n\n", "line": 12, "slice": ["namespace My.NameSpace ", "", "import Assembly.Reference ", "", "def domyfunction(it):", "    print(it)", "", "x as int", "x = 3", "domyfunction(x)", "", "class MainClass:", "    public static Version as string", "", "    static def constructor():", "        Version = \"0.1\"", "", "def doit():", "    print(\"This library's version is: \"+MainClass.Version)"]}
{"code": "\"\"\"\r\nbefore\r\nclicked!\r\nafter\r\n\"\"\"\r\nimport BooCompiler.Tests.SupportingClasses\r\n\r\ndef click():\r\n\tprint(\"clicked!\")\r\n\r\nc = Clickable()\r\nc.Click += click\r\n\r\nprint(\"before\")\r\nc.RaiseClick()\r\nprint(\"after\")\r\n", "line": 9, "slice": ["import BooCompiler.Tests.SupportingClasses", "", "def click():", "\tprint(\"clicked!\")", "", "c = Clickable()", "c.Click += click", "", "c.RaiseClick()"]}
{"code": "#UNSUPPORTED: Reflection not supported\r\n\"\"\"\r\nobject: System.Object\r\nBase: Base\r\nDerived: Derived\r\nDerived: DDerived\r\n\"\"\"\r\nimport System.Collections\r\n\r\nclass Base:\r\n\tpass\r\n\t\r\nclass Derived(Base):\r\n\tpass\r\n\t\r\nclass DDerived(Derived):\r\n\tpass\r\n\r\ndef use(obj):\r\n\tprint(\"object: \" + obj.GetType())\r\n\r\ndef use(obj as Base):\r\n\tprint(\"Base: \" + obj.GetType())\r\n\r\ndef use(obj as Derived):\r\n\tprint(\"Derived: \" + obj.GetType())\r\n\r\nuse(object())\r\nuse(Base())\r\nuse(Derived())\r\nuse(DDerived())\r\n", "line": 20, "slice": ["class DDerived(Derived):", "\tpass", "", "use(DDerived())"]}
{"code": "\"\"\"\nTrue\nFalse\n\"\"\"\ninterface IFlag:\n\tValue as bool:\n\t\tget\n\t\tset\n\t\t\nclass Flag(IFlag):\n\t[property(Value)]\n\t_value as bool\n\t\ndef printFlag(flag as IFlag):\n\tprint(flag.Value)\n\t\nf = Flag(Value: true)\nprintFlag(f)\nf.Value = false\nprintFlag(f)\n", "line": 15, "slice": ["\"\"\"", "interface IFlag:", "\tValue as bool:", "\t\tget", "\t\tset", "\t\t", "class Flag(IFlag):", "\t[property(Value)]", "\t_value as bool", "\t", "def printFlag(flag as IFlag):", "\tprint(flag.Value)", "\t", "f = Flag(Value: true)", "printFlag(f)", "f.Value = false", "printFlag(f)", "\"\"\""]}
{"code": "import System\nimport NUnit.Framework\n\na = def (a):\n\tprint(\"closure\")\n\treturn a.ToString()\n\nAssert.IsTrue(a isa ICallable)\nAssert.IsTrue(a isa Delegate)\n\ninvoke = a.GetType().GetMethod(\"Invoke\")\nAssert.IsNotNull(invoke)\nAssert.AreSame(string, invoke.ReturnType)\n\nparameters = invoke.GetParameters()\nAssert.AreEqual(1, len(parameters))\nAssert.AreSame(object, parameters[0].ParameterType)\n\n", "line": 5, "slice": ["import System", "import NUnit.Framework", "", "a = def (a):", "\tprint(\"closure\")", "\treturn a.ToString()", "", "Assert.IsTrue(a isa ICallable)", "", "invoke = a.GetType().GetMethod(\"Invoke\")", "", "parameters = invoke.GetParameters()"]}
{"code": "\"\"\"\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Equality0Module(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\to1 = object()\n\t\to2 = object()\n\t\tb1 = true\n\t\tb2 = false\n\t\tBoo.Lang.Builtins.print(string.op_Equality('foo', 'bar'))\n\t\tBoo.Lang.Builtins.print((3 == 3.0))\n\t\tBoo.Lang.Builtins.print(Boo.Lang.Runtime.RuntimeServices.EqualityOperator(o1, o2))\n\t\tBoo.Lang.Builtins.print(Boo.Lang.Runtime.RuntimeServices.EqualityOperator('foo', o2))\n\t\tBoo.Lang.Builtins.print(Boo.Lang.Runtime.RuntimeServices.EqualityOperator(3.0, o1))\n\t\tBoo.Lang.Builtins.print((b1 == false))\n\t\tBoo.Lang.Builtins.print((b1 == b2))\n\n\tprivate def constructor():\n\t\tsuper()\n\"\"\"\no1 = object()\no2 = object()\nb1 = true\nb2 = false\nprint('foo' == 'bar')\nprint(3 == 3.0)\nprint(o1 == o2)\nprint('foo' == o2)\nprint(3.0 == o1)\nprint(b1 == false)\nprint(b1 == b2)\n", "line": 10, "slice": ["\"\"\"", "o1 = object()", "o2 = object()", "Boo.Lang.Builtins.print(Boo.Lang.Runtime.RuntimeServices.EqualityOperator(o1, o2))", "Boo.Lang.Builtins.print(Boo.Lang.Runtime.RuntimeServices.EqualityOperator('foo', o2))", "Boo.Lang.Builtins.print(Boo.Lang.Runtime.RuntimeServices.EqualityOperator(3.0, o1))", "\"\"\""]}
{"code": "\"\"\"\n54321\nhello world\n\"\"\"\nclass MyClass:\n\t[property(Value)]\n\tvalue = null\n\t\n\tdef constructor(inValue):\n\t\tvalue = inValue\n\ndef ChangeValue(inst as MyClass):\n    inst.Value = \"hello world\"\n\ninst = MyClass(54321)\nprint(inst.Value)\nChangeValue(inst)\nprint(inst.Value)\n", "line": 16, "slice": ["\"\"\"", "class MyClass:", "\t[property(Value)]", "\tvalue = null", "\t", "\tdef constructor(inValue):", "\t\tvalue = inValue", "", "def ChangeValue(inst as MyClass):", "    inst.Value = \"hello world\"", "", "inst = MyClass(54321)", "ChangeValue(inst)", "print(inst.Value)", "\"\"\""]}
{"code": "#IGNORE: Interfaces not supported yet\r\n\"\"\"\r\nBar1.get_Count\r\n1\r\nBar1.Zeng\r\nBar2.get_Count\r\n2\r\nBar2.Zeng\r\n\"\"\"\r\ninterface IFoo:\r\n\tCount as int:\r\n\t\tget\r\n\t\t\r\ninterface IBar(IFoo):\r\n\tdef Zeng()\r\n\t\r\nclass Bar1(IBar):\r\n\tCount as int:\r\n\t\tget:\r\n\t\t\tprint(\"Bar1.get_Count\")\r\n\t\t\treturn 1\r\n\tdef Zeng():\r\n\t\tprint(\"Bar1.Zeng\")\r\n\t\t\r\nclass Bar2(IBar):\r\n\tCount as int:\r\n\t\tget:\r\n\t\t\tprint(\"Bar2.get_Count\")\r\n\t\t\treturn 2\r\n\tdef Zeng():\r\n\t\tprint(\"Bar2.Zeng\")\r\n\t\t\r\ndef use(bar as IBar):\r\n\tprint(bar.Count)\r\n\tbar.Zeng()\r\n\t\r\nuse(Bar1())\r\nuse(Bar2())\r\n", "line": 20, "slice": ["interface IBar(IFoo):", "\tdef Zeng()", "\t", "class Bar1(IBar):", "\tCount as int:", "\t\tget:", "\t\t\tprint(\"Bar1.get_Count\")", "\t\t\treturn 1", "\tdef Zeng():", "\t\tprint(\"Bar1.Zeng\")", "\t\t", "class Bar2(IBar):", "\tCount as int:", "\t\tget:", "\t\t\tprint(\"Bar2.get_Count\")", "\t\t\treturn 2", "\tdef Zeng():", "\t\tprint(\"Bar2.Zeng\")", "\t\t", "def use(bar as IBar):", "\tprint(bar.Count)", "\tbar.Zeng()", "\t", "use(Bar1())", "use(Bar2())"]}
{"code": "\"\"\"\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Using0Module(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\t\\$using\\$disposable\\$1 = ((f = System.IO.File.OpenText('using0.boo')) as System.IDisposable)\n\t\ttry:\n\t\t\tBoo.Lang.Builtins.print(f.ReadLine())\n\t\tensure:\n\t\t\tif \\$using\\$disposable\\$1 is not null:\n\t\t\t\t\\$using\\$disposable\\$1.Dispose()\n\t\t\t\t\\$using\\$disposable\\$1 = null\n\n\tprivate def constructor():\n\t\tsuper()\n\n\"\"\"\nusing f = System.IO.File.OpenText('using0.boo'):\n\tprint(f.ReadLine())\n", "line": 8, "slice": ["\"\"\"", "\\$using\\$disposable\\$1 = ((f = System.IO.File.OpenText('using0.boo')) as System.IDisposable)", "Boo.Lang.Builtins.print(f.ReadLine())", "\"\"\""]}
{"code": "import NUnit.Framework\n\ncallable OutputHandler(message as string) as string\n\nclass Printer:\n\t\n\t_prefix as string\n\t\n\tdef constructor(prefix):\n\t\tself._prefix = prefix\n\t\t\n\tdef print(message as string):\n\t\treturn \"${_prefix}${message}\"\n\t\nhandler as OutputHandler\nhandler = Printer(\"-\").print\ncall = handler.BeginInvoke(\"Testing...\", null, null)\ncall.AsyncWaitHandle.WaitOne()\nvalue = handler.EndInvoke(call)\n\nAssert.AreEqual(\"-Testing...\", value)\n", "line": 12, "slice": ["import NUnit.Framework", "", "callable OutputHandler(message as string) as string", "", "class Printer:", "\t", "\t_prefix as string", "\t", "\tdef constructor(prefix):", "\t\tself._prefix = prefix", "\t\t", "\tdef print(message as string):", "\t\treturn \"${_prefix}${message}\"", "\t", "handler as OutputHandler", "handler = Printer(\"-\").print", "value = handler.EndInvoke(call)", "", "Assert.AreEqual(\"-Testing...\", value)"]}
{"code": "#UNSUPPORTED: Inner classes\r\n\"\"\"\r\nOuter+Inner.Dispose\r\n\"\"\"\r\nclass Outer:\r\n\tclass Inner(System.IDisposable):\r\n\t\tdef Dispose():\r\n\t\t\tprint(\"$(GetType()).Dispose\")\r\n\r\ntypes = typeof(Outer).GetNestedTypes()\r\nassert 1 == len(types)\r\n\r\nassert Outer.Inner is types[0]\r\nassert types[0] is Outer.Inner\r\nassert typeof(Outer.Inner).IsNestedPublic\r\n\r\nusing inner=Outer.Inner():\r\n\tpass\r\n", "line": 8, "slice": ["class Outer:", "\tclass Inner(System.IDisposable):", "\t\tdef Dispose():", "\t\t\tprint(\"$(GetType()).Dispose\")", "", "types = typeof(Outer).GetNestedTypes()", "", "assert Outer.Inner is types[0]", "", "using inner=Outer.Inner():", "\tpass"]}
{"code": "#UNSUPPORTED: Reflection not supported\r\n\"\"\"\r\nSystem.String\r\nget_Name\r\nnull\r\nSystem.String\r\nnull\r\nset_Name\r\nSystem.String\r\nget_Name\r\nset_Name\r\n\"\"\"\r\nimport System.Reflection\r\n\r\ninterface IFoo:\r\n\tName as string:\r\n\t\tget\r\n\t\t\r\ninterface IBar:\r\n\tName as string:\r\n\t\tset\r\n\r\n\r\ninterface IBaz:\r\n\tName as string:\r\n\t\tget\r\n\t\tset\r\n\t\t\r\ndef dump(property as PropertyInfo):\r\n\tprint(property.PropertyType)\r\n\t\r\n\tgetter = property.GetGetMethod()\r\n\tif getter is null:\r\n\t\tprint(\"null\")\r\n\telse:\r\n\t\tprint(getter.Name)\r\n\tsetter = property.GetSetMethod()\r\n\tif setter is null:\r\n\t\tprint(\"null\")\r\n\telse:\r\n\t\tprint(setter.Name)\r\n\r\ndump(typeof(IFoo).GetProperties()[0])\r\ndump(typeof(IBar).GetProperties()[0])\r\ndump(typeof(IBaz).GetProperties()[0])\r\n", "line": 30, "slice": ["interface IBaz:", "\tName as string:", "\t\tget", "\t\tset", "\t\t", "def dump(property as PropertyInfo):", "\tprint(property.PropertyType)", "\t", "\tgetter = property.GetGetMethod()", "\tif getter is null:", "\t\tprint(\"null\")", "\telse:", "\t\tprint(getter.Name)", "\tsetter = property.GetSetMethod()", "\tif setter is null:", "\t\tprint(\"null\")", "\telse:", "\t\tprint(setter.Name)", "", "dump(typeof(IBaz).GetProperties()[0])"]}
{"code": "\"\"\"\r\nbefore\r\nclicked!\r\nafter\r\n\"\"\"\r\nimport BooJs.Tests.Support\r\n\r\n\r\ndef click(o):\r\n\tprint(\"clicked!\")\r\n\r\nc = Clickable()\r\nc.Click += click\r\n\r\nprint(\"before\")\r\nc.RaiseClick()\r\nprint(\"after\")\r\n", "line": 10, "slice": ["import BooJs.Tests.Support", "", "def click(o):", "\tprint(\"clicked!\")", "", "c = Clickable()", "c.Click += click", "", "c.RaiseClick()"]}
{"code": "\"\"\"\na!\nb!\n\"\"\"\ndef invoke(c as callable):\n\treturn c()\n\t\noptions = {\n\t\"a\" : { print(\"a!\") },\n\t\"b\" : { print(\"b!\") }\n}\n\ninvoke(options[\"a\"])\ninvoke(options[\"b\"])\n\n\n", "line": 9, "slice": ["\"\"\"", "def invoke(c as callable):", "\treturn c()", "\t", "options = {", "\t\"a\" : { print(\"a!\") },", "\t\"b\" : { print(\"b!\") }", "}", "", "invoke(options[\"b\"])", "\"\"\""]}
{"code": "\"\"\"\nbefore assignment...\nbefore invocation...\nfoo!\ndone.\n\"\"\"\nimport System.Threading\n\ndef foo():\n\tprint(\"foo!\")\n\t\nfunction as ThreadStart\nprint(\"before assignment...\")\nfunction = foo\nprint(\"before invocation...\")\nfunction()\nprint(\"done.\")\n", "line": 10, "slice": ["\"\"\"", "import System.Threading", "", "def foo():", "\tprint(\"foo!\")", "\t", "function as ThreadStart", "print(\"before assignment...\")", "function = foo", "print(\"before invocation...\")", "function()", "\"\"\""]}
{"code": "\"\"\"\nFOO\nfoo\n\"\"\"\ndef ToUpper(s as string):\n\treturn s.ToUpper()\n\t\ndef ToLower(s as string):\n\treturn s.ToLower()\n\ndef Transform(s, upper as bool):\n\tif upper:\n\t\tt = ToUpper\n\telse:\n\t\tt = ToLower\n\treturn t(s)\n\na = \"Foo\"\nprint(Transform(a, true))\nprint(Transform(a, false))\n\n", "line": 19, "slice": ["def ToUpper(s as string):", "\treturn s.ToUpper()", "\t", "def ToLower(s as string):", "\treturn s.ToLower()", "", "def Transform(s, upper as bool):", "\tif upper:", "\t\tt = ToUpper", "\telse:", "\t\tt = ToLower", "\treturn t(s)", "", "a = \"Foo\"", "print(Transform(a, false))"]}
{"code": "\"\"\"\nfoo -> bar\nfoo -> bar\n\"\"\"\nclass Console:\n\tdef WriteLine(format as string, *args):\n\t\tprint(format % args)\n\t\t\n\tdef WriteLn(format as string, *args as (object)):\n\t\tprint(format % args)\n\n\nc = Console()\nc.WriteLine('{0} -> {1}', 'foo', 'bar')\nc.WriteLn('{0} -> {1}', 'foo', 'bar')\n", "line": 7, "slice": ["\"\"\"", "class Console:", "\tdef WriteLine(format as string, *args):", "\t\tprint(format % args)", "\t\t", "\tdef WriteLn(format as string, *args as (object)):", "\t\tprint(format % args)", "", "", "c = Console()", "c.WriteLine('{0} -> {1}', 'foo', 'bar')", "c.WriteLn('{0} -> {1}', 'foo', 'bar')", "\"\"\""]}
{"code": "\"\"\"\nbefore\nafter\nend\n\"\"\"\nf = def ():\n\tprint('before')\n\tgoto end\n\tprint('skipped')\n\t:end\n\tprint('after')\n\nf()\ngoto end\nprint('skipped')\n:end\nprint(\"end\")\n\n", "line": 7, "slice": ["\"\"\"", "before", "after", "end", "\"\"\"", "f = def ():", "\tprint('before')", "\tgoto end", "\t:end", "\tprint('after')", "", "f()", "goto end", ":end", "print(\"end\")"]}
{"code": "\"\"\"\nobject: System.Object\nBase: Base\nDerived: Derived\nDerived: DDerived\n\"\"\"\nimport System.Collections\n\nclass Base:\n\tpass\n\t\nclass Derived(Base):\n\tpass\n\t\nclass DDerived(Derived):\n\tpass\n\ndef use(obj):\n\tprint(\"object: \" + obj.GetType())\n\ndef use(obj as Base):\n\tprint(\"Base: \" + obj.GetType())\n\ndef use(obj as Derived):\n\tprint(\"Derived: \" + obj.GetType())\n\nuse(object())\nuse(Base())\nuse(Derived())\nuse(DDerived())\n", "line": 19, "slice": ["class Derived(Base):", "\tpass", "\t", "class DDerived(Derived):", "\tpass", "", "def use(obj as Derived):", "\tprint(\"Derived: \" + obj.GetType())", "", "use(Derived())", "use(DDerived())"]}
{"code": "\"\"\"\nnamespace Math\n\ndef square(x as int) as int:\n\treturn (x * x)\n\ndef add(x as int, y as int) as int:\n\tprint(string.Format('x = {0}, y = {1}', x, y))\n\treturn (x + y)\n\"\"\"\nnamespace Math\n\ndef square(x as int) as int:\n\treturn x*x\n\ndef add(x as int, y as int) as int:\n\tprint(string.Format(\"x = {0}, y = {1}\", x, y))\n\treturn x + y\n", "line": 8, "slice": ["\"\"\"", "def add(x as int, y as int) as int:", "\tprint(string.Format('x = {0}, y = {1}', x, y))", "\treturn (x + y)", "\"\"\""]}
{"code": "class Foo:\n\tbar:\n\t\tget:\n\t\t\treturn baz\n\t\t\n\tbaz as object:\n\t\tget:\n\t\t\traise \"hit me\"\n\ndef stackTrace(code as callable()):\n\ttry:\n\t\tcode()\n\texcept x:\n\t\treturn firstLines(x)\n\ndef firstLines(o):\n\treturn join(/\\n/.Split(o.ToString())[:3], \"\\n\").Trim()\n\t\nse = stackTrace({ print Foo().bar })\nde = stackTrace({ print( (Foo() as duck).bar ) })\nassert se == de, \"'${se}' != '${de}'\" \n\t\n\t\n\n\t\n", "line": 20, "slice": ["class Foo:", "\tbar:", "\t\tget:", "\t\t\treturn baz", "\t\t", "\tbaz as object:", "\t\tget:", "\t\t\traise \"hit me\"", "", "def stackTrace(code as callable()):", "\ttry:", "\t\tcode()", "\texcept x:", "\t\treturn firstLines(x)", "", "def firstLines(o):", "\treturn join(/\\n/.Split(o.ToString())[:3], \"\\n\").Trim()", "\t", "se = stackTrace({ print Foo().bar })"]}
{"code": "\"\"\"\nID: 1111\nFirst Name: Bamboo\n\"\"\"\nclass Person:\n\n\t_id as string\n\t_fname as string\n\n\tdef constructor(id as string, fname as string):\n\t\t_id = id\n\t\t_fname = fname\n\n\tdef getID() as string:\n\t\treturn _id\n\n\tdef getFirstName() as string:\n\t\treturn _fname\n\n\tdef dump():\n\t\tprint(\"ID: ${_id}\\nFirst Name: ${_fname}\")\n\np = Person(\"1111\", \"Bamboo\")\np.dump()\n", "line": 21, "slice": ["\"\"\"", "class Person:", "", "\t_id as string", "\t_fname as string", "", "\tdef constructor(id as string, fname as string):", "\t\t_id = id", "\t\t_fname = fname", "", "\tdef dump():", "\t\tprint(\"ID: ${_id}\\nFirst Name: ${_fname}\")", "", "p = Person(\"1111\", \"Bamboo\")", "p.dump()", "\"\"\""]}
{"code": "\"\"\"\r\n1: albatross!\r\n\"\"\"\r\nenum LogMessageLevel:\r\n\tINFO     = 0\r\n\tWARNING  = 1\r\n\tERROR    = 2\r\n\r\nclass FileLogService:\r\n\t\r\n\tdef log(msg as string):\r\n\t\tlog(LogMessageLevel.WARNING, msg)\r\n\r\n\tdef log(logMessageLevel as LogMessageLevel, msg as string):\r\n\t\tprint(\"${logMessageLevel}: ${msg}\")\r\n\r\nFileLogService().log(\"albatross!\")\r\n", "line": 15, "slice": ["\"\"\"", "enum LogMessageLevel:", "\tINFO     = 0", "\tWARNING  = 1", "\tERROR    = 2", "", "class FileLogService:", "\t", "\tdef log(msg as string):", "\t\tlog(LogMessageLevel.WARNING, msg)", "", "\tdef log(logMessageLevel as LogMessageLevel, msg as string):", "\t\tprint(\"${logMessageLevel}: ${msg}\")", "", "FileLogService().log(\"albatross!\")", "\"\"\""]}
{"code": "\"\"\"\ndef foo():\n\tprint 'before'\n\ttry:\n\t\tprint('Hello, world')\n\tensure:\n\t\tprint 'after'\n\"\"\"\nmethod = [|\n\tdef foo():\n\t\tprint(\"Hello, world\")\n|]\n\nmethod.Body = [|\n\tprint \"before\"\n\ttry:\n\t\t$(method.Body)\n\tensure:\n\t\tprint \"after\"\n|]\n\nprint method.ToCodeString()\n", "line": 5, "slice": ["\"\"\"", "def foo():", "\tprint 'before'", "\ttry:", "\t\tprint('Hello, world')", "\tensure:", "\t\tprint 'after'", "\"\"\"", "method = [|", "\tdef foo():", "\t\tprint(\"Hello, world\")", "|]"]}
{"code": "\"\"\"\n2\n3\n1\n\"\"\"\nimport System\n\nclass Foo(object):\n\tpass\n\nclass Bar(Foo):\n\tpass\n\t\ndef classDepth(type as Type):\n\n\tvalue = 1\n\twhile type is not object:\n\t\t++value\n\t\ttype = type.BaseType\n\t\t\n\treturn value\n\nprint(classDepth(Foo))\nprint(classDepth(Bar))\nprint(classDepth(object))\n", "line": 23, "slice": ["import System", "", "class Foo(object):", "\tpass", "", "class Bar(Foo):", "\tpass", "\t", "def classDepth(type as Type):", "", "\tvalue = 1", "\twhile type is not object:", "\t\t++value", "\t\ttype = type.BaseType", "\t\t", "\treturn value", "", "print(classDepth(Bar))"]}
{"code": "def time(description, arg, closure as callable(object)):\n\titerations = 1000000\n\tstart = date.Now\n\tfor i in range(iterations):\n\t\tclosure(arg)\n\telapsed = date.Now-start\n\tprint(\"${description}: ${elapsed}\")\n\tprint(\"${description}: ${elapsed.TotalMilliseconds/iterations} ms per call\")\n\t\ndef foo():\n\tpass\n\t\ntime(\"simple method call\", null) do (item):\n\tfoo()\n\ntime(\"method reference\", foo) do (item as callable()):\n\titem()\n\t\ntime(\"interface call\", foo) do (item as callable):\n\titem()\n\ntime(\"adapted reference\", foo) do (item as callable()):\n\tcast(callable(object), item)(null)\n", "line": 7, "slice": ["def time(description, arg, closure as callable(object)):", "\titerations = 1000000", "\tstart = date.Now", "\tfor i in range(iterations):", "\t\tclosure(arg)", "\telapsed = date.Now-start", "\t", "def foo():", "\tpass", "\t", "time(\"simple method call\", null) do (item):", "\tfoo()"]}
{"code": "\"\"\"\nID: 1111\nFirst Name: Bamboo\n\"\"\"\nclass Person:\n\n\t_id as string\n\n\t_fname as string\n\n\tdef constructor(id, fname):\n\t\t_id = id\n\t\t_fname = fname\n\n\tdef getID() as string:\n\t\treturn _id\n\n\tdef getFirstName() as string:\n\t\treturn _fname\n\n\tpublic static def Dump(p as Person):\n\t\tprint(\"ID: {0}\\nFirst Name: {1}\" % (p._id, p._fname))\n\n\np = Person(\"1111\", \"Bamboo\")\nPerson.Dump(p)\n", "line": 22, "slice": ["\"\"\"", "ID: 1111", "First Name: Bamboo", "\"\"\"", "class Person:", "", "\t_id as string", "", "\t_fname as string", "", "\tdef constructor(id, fname):", "\t\t_id = id", "\t\t_fname = fname", "", "\tpublic static def Dump(p as Person):", "\t\tprint(\"ID: {0}\\nFirst Name: {1}\" % (p._id, p._fname))", "", "", "p = Person(\"1111\", \"Bamboo\")", "Person.Dump(p)"]}
{"code": "\"\"\"\nhandler - clicked!\nhandler - clicked!\n\n\"\"\"\nimport BooCompiler.Tests\n\nclass Handler:\n\t\n\ttag\n\t\n\tdef constructor(tag):\n\t\tself.tag = tag\n\t\t\n\tdef clicked(sender, args as System.EventArgs):\n\t\tprint(\"${tag} - clicked!\")\n\nc = Clickable()\nc.Click += Handler(\"handler\").clicked\nc.RaiseClick()\nc.RaiseClick()\n", "line": 16, "slice": ["\"\"\"", "import BooCompiler.Tests", "", "class Handler:", "\t", "\ttag", "\t", "\tdef constructor(tag):", "\t\tself.tag = tag", "\t\t", "\tdef clicked(sender, args as System.EventArgs):", "\t\tprint(\"${tag} - clicked!\")", "", "c = Clickable()", "c.Click += Handler(\"handler\").clicked", "c.RaiseClick()", "c.RaiseClick()", "\"\"\""]}
{"code": "#IGNORE: Interfaces not supported yet\r\n\"\"\"\r\nbefore\r\nGetEnumerator\r\nMoveNext\r\nDispose\r\nafter\r\n\"\"\"\r\nimport System\r\nimport System.Collections\r\n\r\nclass Enumerable:\r\n\r\n\tclass Enumerator(IEnumerator, IDisposable):\r\n\t\r\n\t\tdef Dispose():\r\n\t\t\tprint(\"Dispose\")\r\n\t\r\n\t\tdef Reset():\r\n\t\t\tprint(\"Reset\")\r\n\t\r\n\t\tdef MoveNext() as bool:\r\n\t\t\tprint(\"MoveNext\")\r\n\t\t\treturn false\r\n\t\r\n\t\tCurrent:\r\n\t\t\tget:\r\n\t\t\t\tprint(\"Current\")\r\n\t\t\t\treturn null\r\n\r\n\tdef GetEnumerator():\r\n\t\tprint(\"GetEnumerator\")\r\n\t\treturn Enumerator()\r\n\t\t\r\nprint(\"before\")\r\nfor i in Enumerable():\r\n\tprint(i)\r\nprint(\"after\")\r\n", "line": 17, "slice": ["import System", "import System.Collections", "", "class Enumerable:", "", "\tclass Enumerator(IEnumerator, IDisposable):", "\t", "\t\tdef Dispose():", "\t\t\tprint(\"Dispose\")", "\t", "\t\tdef MoveNext() as bool:", "\t\t\tprint(\"MoveNext\")", "\t\t\treturn false", "\t", "\t\tCurrent:", "\t\t\tget:", "\t\t\t\tprint(\"Current\")", "\t\t\t\treturn null", "", "\tdef GetEnumerator():", "\t\tprint(\"GetEnumerator\")", "\t\treturn Enumerator()", "\t\t", "for i in Enumerable():", "\tprint(i)"]}
{"code": "#IGNORE: BUG - Static fields not fully supported yet\r\n\"\"\"\r\n0\r\n1\r\n2\r\n\"\"\"\r\nclass Person:\r\n\r\n\tpublic static InstanceCount as int\r\n\t\r\n\tdef constructor():\r\n\t\t++InstanceCount\r\n\r\n\t\t\r\nprint(Person.InstanceCount)\r\np = Person()\r\nprint(Person.InstanceCount)\r\np = Person()\r\nprint(Person.InstanceCount)\r\n", "line": 15, "slice": ["class Person:", "", "\tpublic static InstanceCount as int", "\t", "\tdef constructor():", "\t\t++InstanceCount", "", "\t\t", "print(Person.InstanceCount)", "p = Person()", "print(Person.InstanceCount)", "p = Person()", "print(Person.InstanceCount)"]}
{"code": "\"\"\"\nbefore\nclicked!\nafter\n\"\"\"\nimport BooCompiler.Tests\n\ndef click(sender, args as System.EventArgs):\n\tprint(\"clicked!\")\n\nc = Clickable(Click: System.EventHandler(null, __addressof__(click)))\n\nprint(\"before\")\nc.RaiseClick()\nprint(\"after\")\n", "line": 9, "slice": ["import BooCompiler.Tests", "", "def click(sender, args as System.EventArgs):", "\tprint(\"clicked!\")", "", "c = Clickable(Click: System.EventHandler(null, __addressof__(click)))", "", "c.RaiseClick()"]}
{"code": "#IGNORE: Interfaces not supported\r\n\"\"\"\r\nobject: System.Object\r\nIFoo: Foo\r\nIBar: Bar\r\n\"\"\"\r\n\r\ninterface IFoo:\r\n\tpass\r\n\t\r\ninterface IBar(IFoo):\r\n\tpass\r\n\t\r\nclass Foo(IFoo):\r\n\tpass\r\n\t\r\nclass Bar(IBar):\r\n\tpass\r\n\r\ndef use(obj):\r\n\tprint(\"object: ${obj}\")\r\n\r\ndef use(obj as IFoo):\r\n\tprint(\"IFoo: ${obj}\")\r\n\r\ndef use(obj as IBar):\r\n\tprint(\"IBar: ${obj}\")\r\n\r\nuse(object())\r\nuse(Foo())\r\nuse(Bar())\r\n", "line": 21, "slice": ["interface IFoo:", "\tpass", "\t", "interface IBar(IFoo):", "\tpass", "\t", "class Bar(IBar):", "\tpass", "", "def use(obj as IBar):", "\tprint(\"IBar: ${obj}\")", "", "use(Bar())"]}
{"code": "\"\"\"\nobject: System.Object\nIFoo: Foo\nIBar: Bar\n\"\"\"\nimport System.Collections\n\ninterface IFoo:\n\tpass\n\t\ninterface IBar(IFoo):\n\tpass\n\t\nclass Foo(IFoo):\n\tpass\n\t\nclass Bar(IBar):\n\tpass\n\ndef use(obj):\n\tprint(\"object: ${obj}\")\n\ndef use(obj as IFoo):\n\tprint(\"IFoo: ${obj}\")\n\ndef use(obj as IBar):\n\tprint(\"IBar: ${obj}\")\n\nuse(object())\nuse(Foo())\nuse(Bar())\n", "line": 21, "slice": ["\"\"\"", "object: System.Object", "IFoo: Foo", "IBar: Bar", "\"\"\"", "import System.Collections", "", "interface IFoo:", "\tpass", "\t", "interface IBar(IFoo):", "\tpass", "\t", "class Foo(IFoo):", "\tpass", "\t", "class Bar(IBar):", "\tpass", "", "def use(obj as IBar):", "\tprint(\"IBar: ${obj}\")", "", "use(Bar())"]}
{"code": "\"\"\"\nbefore subscribers\nnothing printed\nclicked!\nclicked!\nclicked again!\nclicked!\n\"\"\"\nimport System\nimport NUnit.Framework\n\nclass Button:\n\tevent Click as EventHandler\n\t\n\tdef RaiseClick():\n\t\tClick(self, EventArgs.Empty)\n\t\ndef click(sender, args as EventArgs):\n\tprint(\"clicked again!\")\n\nb = Button()\n\nprint(\"before subscribers\")\nb.RaiseClick()\nprint(\"nothing printed\")\n\nb.Click += def (sender, args):\n\tprint(\"clicked!\")\n\tAssert.AreSame(sender, b)\n\tAssert.AreSame(EventArgs.Empty, args)\n\t\nb.RaiseClick()\n\nb.Click += click\nb.RaiseClick()\n\t\nb.Click -= click\nb.RaiseClick()\n", "line": 19, "slice": ["\"\"\"", "import System", "import NUnit.Framework", "", "class Button:", "\tevent Click as EventHandler", "\t", "\tdef RaiseClick():", "\t\tClick(self, EventArgs.Empty)", "\t", "def click(sender, args as EventArgs):", "\tprint(\"clicked again!\")", "", "b = Button()", "", "b.Click += def (sender, args):", "\tprint(\"clicked!\")", "\tAssert.AreSame(sender, b)", "\tAssert.AreSame(EventArgs.Empty, args)", "\t", "b.RaiseClick()", "", "b.Click += click", "b.RaiseClick()", "\t", "b.Click -= click", "b.RaiseClick()", "\"\"\""]}
{"code": "#UNSUPPORTED: BeginInvoke not supported\r\n\"\"\"\r\nstarted\r\nexecuting\r\ncallback\r\ndone\r\n\"\"\"\r\nimport System\r\n\r\ndef callback(result as IAsyncResult):\r\n\tprint(\"callback\")\r\n\t\r\ndef run():\r\n\tprint(\"executing\")\r\n\t\r\nprint(\"started\")\r\n\r\nresult = run.BeginInvoke(callback, null)\r\nSystem.Threading.Thread.Sleep(50ms)\r\nrun.EndInvoke(result)\r\n\r\nprint(\"done\")\r\n", "line": 11, "slice": ["import System", "", "def callback(result as IAsyncResult):", "\tprint(\"callback\")", "\t", "def run():", "\tprint(\"executing\")", "\t", "result = run.BeginInvoke(callback, null)", "System.Threading.Thread.Sleep(50ms)", "run.EndInvoke(result)"]}
{"code": "\"\"\"\r\nint: 3\r\nstring: foo\r\n\"\"\"\r\nimport System.Console\r\n\r\ndef print(value as int):\r\n\tWrite(\"int: \")\r\n\tWriteLine(value)\r\n\r\n\t\r\ndef print(value as string):\r\n\tWrite(\"string: \")\r\n\tWriteLine(value)\r\n\r\nprint(3)\r\nprint(\"foo\")\r\n\t\r\n", "line": 7, "slice": ["\"\"\"", "import System.Console", "", "def print(value as int):", "\tWrite(\"int: \")", "\tWriteLine(value)", "", "print(3)", "\"\"\""]}
{"code": "\"\"\"\n1\nafter 1\n2\nafter 2\n2\n\"\"\"\nstruct Vector3:\n    x as single\n    y as single\n    z as single\n\nclass Test:\n\tpublic transform = Transform()\n\t\n\tclass Transform:\n\t\t[property(position)]\n\t\tm_Position = Vector3()\n\t\t\n\tdef go():\n\t\tyield 1\n\t\ttransform.position.x += 1\n\t\tprint(\"after 1\")\n\t\tyield 2\n\t\ttransform.position.x += 1\n\t\tprint(\"after 2\")\n\t\t\ntest = Test()\nfor item in test.go():\n\tprint item\nprint test.transform.position.x\n", "line": 23, "slice": ["\"\"\"", "struct Vector3:", "    x as single", "    y as single", "    z as single", "", "class Test:", "\tpublic transform = Transform()", "\t", "\tclass Transform:", "\t\t[property(position)]", "\t\tm_Position = Vector3()", "\t\t", "\tdef go():", "\t\tyield 1", "\t\ttransform.position.x += 1", "\t\tyield 2", "\t\ttransform.position.x += 1", "\t\t", "test = Test()", "for item in test.go():", "\tprint item", "print test.transform.position.x", "\"\"\""]}
{"code": "\"\"\"\n1, bar\n2, baz\n3, foo\nnull\nnull\n1\n2\n3\n4\n5\n8\nnull\n1, 1\n1, 2\n1, 2, 3\n1, 2, 4\n1, 3\n\"\"\"\ndef sort(items as List):\n\tfor item in items.Sort():\n\t\tif item is null:\n\t\t\tprint(\"null\")\n\t\t\tcontinue\n\t\t\t\n\t\tif item isa System.Array:\n\t\t\tprint(join(item, \", \"))\n\t\t\tcontinue\n\t\t\n\t\tprint(item)\n\nsort([(3, \"foo\"), (1, \"bar\"), (2, \"baz\")])\nsort([4, 5, 8, null, 3, 2, null, 1])\nsort([(1, 2, 3), null, (1, 2, 4), (1, 3), (1, 1), (1, 2)])\n\t\n", "line": 23, "slice": ["\"\"\"", "def sort(items as List):", "\tfor item in items.Sort():", "\t\tif item is null:", "\t\t\tprint(\"null\")", "\t\t\tcontinue", "\t\t\t", "\t\tif item isa System.Array:", "\t\t\tprint(join(item, \", \"))", "\t\t\tcontinue", "\t\t", "\t\tprint(item)", "", "sort([(3, \"foo\"), (1, \"bar\"), (2, \"baz\")])", "sort([4, 5, 8, null, 3, 2, null, 1])", "sort([(1, 2, 3), null, (1, 2, 4), (1, 3), (1, 1), (1, 2)])", "\"\"\""]}
{"code": "\"\"\"\n1 1\n2 2\n3 3\n\"\"\"\ndef onetwothree():\n\ti = 0\n\tyield ++i\n\tyield ++i\n\tyield ++i\n\t\ne1 = onetwothree().GetEnumerator()\ne2 = onetwothree().GetEnumerator()\nwhile e1.MoveNext() and e2.MoveNext():\n\tprint(\"${e1.Current} ${e2.Current}\")\n", "line": 15, "slice": ["\"\"\"", "def onetwothree():", "\ti = 0", "\tyield ++i", "\tyield ++i", "\tyield ++i", "\t", "e1 = onetwothree().GetEnumerator()", "e2 = onetwothree().GetEnumerator()", "while e1.MoveNext() and e2.MoveNext():", "\tprint(\"${e1.Current} ${e2.Current}\")", "\"\"\""]}
{"code": "\"\"\"\nclicked from app!\n\n\"\"\"\nimport BooCompiler.Tests from BooCompiler.Tests\n\nclass App:\n\n\t_clickable as Clickable\n\t\n\tdef constructor():\n\t\t_clickable = Clickable(Click: clicked)\n\t\t\n\tprivate def clicked(sender, args as System.EventArgs):\n\t\tprint(\"clicked from app!\")\n\t\t\n\tdef Run():\n\t\t_clickable.RaiseClick()\n\t\t\nApp().Run()\n\t\t\n", "line": 15, "slice": ["\"\"\"", "import BooCompiler.Tests from BooCompiler.Tests", "", "class App:", "", "\t_clickable as Clickable", "\t", "\tdef constructor():", "\t\t_clickable = Clickable(Click: clicked)", "\t\t", "\tprivate def clicked(sender, args as System.EventArgs):", "\t\tprint(\"clicked from app!\")", "\t\t", "\tdef Run():", "\t\t_clickable.RaiseClick()", "\t\t", "App().Run()", "\"\"\""]}
{"code": "\"\"\"\npublic class Person(object):\n\n\tprotected _name as string\n\n\tpublic Name as string:\n\t\tpublic get:\n\t\t\treturn self._name\n\t\tpublic set:\n\t\t\tself._name = value\n\n\tpublic def constructor():\n\t\tsuper()\n\n[System.Runtime.CompilerServices.CompilerGlobalScopeAttribute]\npublic final transient class Assign_propertyModule(object):\n\n\tprivate static def Main(argv as (string)) as void:\n\t\tp = Person()\n\t\tp.Name = 'boo'\n\t\tBoo.Lang.Builtins.print(p.get_Name())\n\n\tprivate def constructor():\n\t\tsuper()\n\"\"\"\nclass Person:\n\t_name as string\n\t\n\tName:\n\t\tget:\n\t\t\treturn _name\n\t\tset:\n\t\t\t_name = value\n\t\t\t\np = Person()\np.Name = \"boo\"\nprint(p.Name)\n", "line": 21, "slice": ["public class Person(object):", "", "\tprotected _name as string", "", "\tpublic Name as string:", "\t\tpublic get:", "\t\t\treturn self._name", "\t\tpublic set:", "\t\t\tself._name = value", "", "\tprivate static def Main(argv as (string)) as void:", "\t\tp = Person()", "\t\tp.Name = 'boo'", "\t\tBoo.Lang.Builtins.print(p.get_Name())"]}
{"code": "\"\"\"\npublic class ClassWithoutConstructor(object):\n\n\tpublic def run() as void:\n\t\tBoo.Lang.Builtins.print('it worked!')\n\n\tpublic def constructor():\n\t\tsuper()\n\n\"\"\"\nclass ClassWithoutConstructor(object):\n\t\n\tdef run():\n\t\tprint(\"it worked!\")\n\n", "line": 5, "slice": ["The code provided does not have a line 5 that can be influenced by any other lines."]}
{"code": "#UNSUPPORTED: BeginInvoke not supported\r\n\"\"\"\r\nstarted\r\nexecuting\r\ncalled back\r\ndone\r\n\"\"\"\r\nimport System\r\n\t\r\ndef run(message):\r\n\tprint(message)\r\n\treturn 42\r\n\t\r\nprint(\"started\")\r\n\r\n# BeginInvoke is overloaded\r\n# in this example we call the version\r\n# that takes only the callback after the method's parameters\r\nresult = run.BeginInvoke(\"executing\", { print(\"called back\") }, null)\r\nSystem.Threading.Thread.Sleep(50ms)\r\nassert 42 == run.EndInvoke(result)\r\n\r\nprint(\"done\")\r\n", "line": 11, "slice": ["import System", "\t", "def run(message):", "\tprint(message)", "\treturn 42", "\t", "print(\"started\")", "", "result = run.BeginInvoke(\"executing\", { print(\"called back\") }, null)", "System.Threading.Thread.Sleep(50ms)", "assert 42 == run.EndInvoke(result)", "", "print(\"done\")"]}
{"code": "\"\"\"\nHomer\n\"\"\"\nclass Person:\n\n\t[getter(Name)]\n\t_name as string\n\t\n\tdef constructor(name as string):\n\t\t_name = name\n\n\ntype = Person\np as Person = type(\"Homer\")\nprint(p.Name)\n\t\n", "line": 15, "slice": ["\"\"\"", "Homer", "\"\"\"", "class Person:", "", "\t[getter(Name)]", "\t_name as string", "\t", "\tdef constructor(name as string):", "\t\t_name = name", "", "", "type = Person", "p as Person = type(\"Homer\")"]}
{"code": "\"\"\"\nOnIdle1\nOnIdle2\nclosure\n\"\"\"\nimport BooCompiler.Tests\n\nclass Test:\n\t\n\tdef constructor():\n\t\tClickable.Idle += self.OnIdle1\n\t\tClickable.Idle += OnIdle2\n\t\tClickable.Idle += { print(\"closure\") }\n\t\t\n\tdef OnIdle1(sender as object, e as System.EventArgs):\n        print(\"OnIdle1\")\n\t\t\n\tdef OnIdle2():\n\t\tprint(\"OnIdle2\")\n\t\t\nt = Test()\nClickable.RaiseIdle()\n", "line": 13, "slice": ["\"\"\"", "import BooCompiler.Tests", "", "class Test:", "\t", "\tdef constructor():", "\t\tClickable.Idle += self.OnIdle1", "\t\tClickable.Idle += OnIdle2", "\t\tClickable.Idle += { print(\"closure\") }", "\t\t", "\tdef OnIdle1(sender as object, e as System.EventArgs):", "        print(\"OnIdle1\")", "\t\t", "\tdef OnIdle2():", "\t\tprint(\"OnIdle2\")", "\t\t", "t = Test()", "Clickable.RaiseIdle()", "\"\"\""]}
{"code": "\"\"\"\nclass Action:\n\n\tcb\n\n\tdef constructor(callback):\n\t\tcb = callback\n\nclass A:\n\n\t[property(Go)]\n\taction = Action({ print('Hello World') })\n\"\"\"\nclass Action:\n\tcb\n\tdef constructor(callback):\n\t\tcb = callback\n\nclass A:\n\t[property(Go)]\n\taction = Action() def():\n\t\tprint(\"Hello World\")\n", "line": 12, "slice": ["class Action:", "\tcb", "\tdef constructor(callback):", "\t\tcb = callback", "", "class A:", "\taction = Action({ print('Hello World') })"]}
{"code": "#UNSUPPORTED: Threads not supported\r\n\"\"\"\r\nping\r\npong\r\n\"\"\"\r\nimport System.Threading\r\n\r\ndef ping(pong as ThreadStart):\r\n\tprint(\"ping\")\r\n\tpong()\r\n\t\r\ndef pong():\r\n\tprint(\"pong\")\r\n\t\r\nping(pong)\r\n", "line": 9, "slice": ["import System.Threading", "", "def ping(pong as ThreadStart):", "\tprint(\"ping\")", "\tpong()", "\t", "def pong():", "\tprint(\"pong\")", "\t", "ping(pong)"]}
{"code": "#UNSUPPORTED: Interfaces not supported yet\r\n\"\"\"\r\nHomer\r\nEric\r\n\"\"\"\r\nimport System\r\nimport System.Collections\r\n\r\nclass Foo:\r\n\t[getter(Name)]\r\n\t_name as string\r\n\t\r\n\tdef constructor(name as string):\r\n\t\t_name = name\r\n\r\n[EnumeratorItemType(Foo)]\r\nclass FooCollection(ICollection):\r\n\t\r\n\t_items = []\r\n\t\r\n\tSyncRoot:\r\n\t\tget:\r\n\t\t\treturn _items.SyncRoot\r\n\t\r\n\tCount:\r\n\t\tget:\r\n\t\t\treturn len(_items)\r\n\t\r\n\tIsSynchronized:\r\n\t\tget:\r\n\t\t\treturn _items.IsSynchronized\r\n\t\t\t\r\n\tdef CopyTo(target as Array, index as int):\r\n\t\t_items.CopyTo(target, index)\r\n\t\t\r\n\tdef GetEnumerator():\r\n\t\treturn _items.GetEnumerator()\r\n\t\t\r\n\tdef Add([required] item as Foo):\r\n\t\t_items.Add(item)\r\n\t\t\t\r\nc = FooCollection()\r\nc.Add(Foo(\"Homer\"))\r\nc.Add(Foo(\"Eric\"))\r\nfor foo in c:\r\n\tprint(foo.Name)\r\n", "line": 46, "slice": ["class Foo:", "\t[getter(Name)]", "\t_name as string", "\t", "\tdef constructor(name as string):", "\t\t_name = name", "", "[EnumeratorItemType(Foo)]", "class FooCollection(ICollection):", "\t", "\t_items = []", "\t\t", "\tdef GetEnumerator():", "\t\treturn _items.GetEnumerator()", "\t\t", "\tdef Add([required] item as Foo):", "\t\t_items.Add(item)", "\t\t\t", "c = FooCollection()", "c.Add(Foo(\"Homer\"))", "c.Add(Foo(\"Eric\"))", "for foo in c:", "\tprint(foo.Name)"]}
{"code": "\"\"\"\nclass Console:\n\n\tdef WriteLine(format as string, *args):\n\t\tprint(string.Format(format, args))\n\n\tdef WriteLn(format as string, *args as (object)):\n\t\tprint(string.Format(format, args))\n\"\"\"\nclass Console:\n\tdef WriteLine(format as string, *args):\n\t\tprint(string.Format(format, args))\n\t\t\n\tdef WriteLn(format as string, *args as (object)):\n\t\tprint(string.Format(format, args))\n\t\t\n", "line": 5, "slice": ["The code provided does not have a line 5 that can be influenced by other lines. The code is defining two methods within a class, and neither method is called or influenced by any other line in the provided code."]}
{"code": "\"\"\"\nnamespace Foo.Bar\n\nimport System\n\ndef foo():\n\tprint('bar')\n\nfoo()\nfoo()\n\"\"\"\nnamespace Foo.Bar;\n;\nimport System;\n\ndef foo():\n\tprint('bar');\n\t\nfoo(); foo()\n;\n", "line": 7, "slice": ["namespace Foo.Bar", "", "import System", "", "def foo():", "\tprint('bar')", "", "foo()"]}
{"code": "#NOTE: In BooJS generator expressions are resolved immediately\r\n\"\"\"\r\nbefore generator\r\ngen\r\nafter generator\r\nbefore iteration\r\n0\r\n1\r\nafter iteration\r\n\"\"\"\r\ndef gen():\r\n\tprint(\"gen\")\r\n\treturn range(2)\r\n\t\r\nprint(\"before generator\")\r\na = i for i in gen()\r\nprint(\"after generator\")\r\n\r\nprint(\"before iteration\")\r\nfor i in a:\r\n\tprint(i)\r\nprint(\"after iteration\")\r\n", "line": 12, "slice": ["def gen():", "\tprint(\"gen\")", "\treturn range(2)", "\t", "print(\"before generator\")", "a = i for i in gen()", "print(\"after generator\")", "", "print(\"before iteration\")", "for i in a:", "\tprint(i)"]}
{"code": "\"\"\"\nbefore block\n1: constructor\n2: constructor\ninside block\n2: Dispose\n1: Dispose\nafter block\n\"\"\"\nimport NUnit.Framework\n\nclass Disposable(System.IDisposable):\n\t_tag\n\tdef constructor(tag):\n\t\t_tag = tag\n\t\tprint(\"${tag}: constructor\")\n\t\t\n\tdef Dispose():\n\t\tprint(\"${_tag}: Dispose\")\n\nprint(\"before block\")\nusing Disposable(1), d1=Disposable(2):\n\tprint(\"inside block\")\nprint(\"after block\")\nAssert.IsNotNull(d1)\n", "line": 16, "slice": ["\"\"\"", "import NUnit.Framework", "", "class Disposable(System.IDisposable):", "\t_tag", "\tdef constructor(tag):", "\t\t_tag = tag", "\t\tprint(\"${tag}: constructor\")", "\t\t", "\tdef Dispose():", "\t\tprint(\"${_tag}: Dispose\")", "", "using Disposable(1), d1=Disposable(2):", "\tprint(\"inside block\")", "Assert.IsNotNull(d1)", "\"\"\""]}
{"code": "\"\"\"\nHomer\nEric\n\"\"\"\nimport System\nimport System.Collections\n\nclass Foo:\n\t[getter(Name)]\n\t_name as string\n\t\n\tdef constructor(name as string):\n\t\t_name = name\n\n[EnumeratorItemType(Foo)]\nclass FooCollection(ICollection):\n\t\n\t_items = []\n\t\n\tSyncRoot:\n\t\tget:\n\t\t\treturn _items.SyncRoot\n\t\n\tCount:\n\t\tget:\n\t\t\treturn len(_items)\n\t\n\tIsSynchronized:\n\t\tget:\n\t\t\treturn _items.IsSynchronized\n\t\t\t\n\tdef CopyTo(target as Array, index as int):\n\t\t_items.CopyTo(target, index)\n\t\t\n\tdef GetEnumerator():\n\t\treturn _items.GetEnumerator()\n\t\t\n\tdef Add([required] item as Foo):\n\t\t_items.Add(item)\n\t\t\t\nc = FooCollection()\nc.Add(Foo(\"Homer\"))\nc.Add(Foo(\"Eric\"))\nfor foo in c:\n\tprint(foo.Name)\n", "line": 45, "slice": ["\"\"\"", "import System", "import System.Collections", "", "class Foo:", "\t[getter(Name)]", "\t_name as string", "\t", "\tdef constructor(name as string):", "\t\t_name = name", "", "[EnumeratorItemType(Foo)]", "class FooCollection(ICollection):", "\t", "\t_items = []", "\t", "\tdef Add([required] item as Foo):", "\t\t_items.Add(item)", "\t\t\t", "c = FooCollection()", "c.Add(Foo(\"Homer\"))", "c.Add(Foo(\"Eric\"))", "for foo in c:", "\tprint(foo.Name)", "\"\"\""]}
{"code": "\"\"\"\r\nbefore\r\nevaluated\r\nafter\r\nbefore\r\nevaluated\r\nevaluated\r\nafter\r\n\"\"\"\r\ndef fun(value):\r\n\tprint('evaluated')\r\n\treturn value\r\n\t\r\na = null and true\r\nassert a is null\r\n\r\nb = true and 3\r\nassert int is b.GetType()\r\nassert 3 == b\r\n\r\nprint(\"before\")\r\nc = fun(false) and fun(true)\r\nprint(\"after\")\r\nassert not c\r\n\r\nprint(\"before\")\r\nd = fun(true) and fun(null)\r\nprint(\"after\")\r\nassert d is null\r\n\r\ne = 0 and false\r\nassert 0 == e\r\n", "line": 11, "slice": ["\"\"\"", "def fun(value):", "\tprint('evaluated')", "\treturn value", "\t", "print(\"before\")", "c = fun(false) and fun(true)", "print(\"after\")", "assert not c", "\"\"\""]}
{"code": "\"\"\"\n1\n3\n5\n2\n4\n6\n\"\"\"\nimport NUnit.Framework\n\ndef odds(begin, end):\n\treturn i for i in range(begin, end) if i % 2\n\t\ndef evens(begin, end):\n\treturn i for i in range(begin, end) unless i % 2\n\t\nfor expected, actual in zip((1, 3, 5), odds(1, 6)):\n\tprint(actual)\n\tAssert.AreEqual(expected, actual)\n\t\nfor expected, actual in zip((2, 4, 6), evens(1, 7)):\n\tprint(actual)\n\tAssert.AreEqual(expected, actual)\n\t\n\n", "line": 18, "slice": ["\"\"\"", "import NUnit.Framework", "", "def odds(begin, end):", "\treturn i for i in range(begin, end) if i % 2", "\t", "for expected, actual in zip((1, 3, 5), odds(1, 6)):", "\tprint(actual)", "\tAssert.AreEqual(expected, actual)", "\"\"\""]}
{"code": "\"\"\"\r\n1 1\r\n1 2\r\n1 3\r\n2 1\r\n2 2\r\n2 3\r\n3 1\r\n3 2\r\n3 3\r\n\"\"\"\r\ndef onetwothree():\r\n\ti = 0\r\n\tyield ++i\r\n\tyield ++i\r\n\tyield ++i\r\n\t\r\nfor i1 in onetwothree():\r\n\tfor i2 in onetwothree():\r\n\t\tprint(\"$i1 $i2\")\r\n", "line": 20, "slice": ["\"\"\"", "def onetwothree():", "\ti = 0", "\tyield ++i", "\tyield ++i", "\tyield ++i", "\t", "for i1 in onetwothree():", "\tfor i2 in onetwothree():", "\t\tprint(\"$i1 $i2\")", "\"\"\""]}
